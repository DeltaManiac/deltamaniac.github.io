[{"doc":"This page has not yet sprouted","title":"This page has not yet sprouted","hpath":"403","content":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","url":"https://deltamaniac.github.io/notes\\403.html","relUrl":"notes\\403.html"},{"doc":"root","title":"root","hpath":"root","content":"\n\r\n![DeltaManiac](https://raw.githubusercontent.com/DeltaManiac/DeltaManiac/main/vault/assets/banner.svg)\r\n\r\n- üî≠ I‚Äôm currently playing Destiny 2\r\n- üå± I‚Äôm currently learning [Rust](https://www.rust-lang.org) at night and [Go](https://golang.org/) at work\r\n- üì´ How to reach me: [twitter](https://twitter.com/Delta_Maniac)\r\n- üòÑ Pronouns: He/Him\r\n- ‚ö° Fun fact: The banner was provided by [Pushkar Anand](https://github.com/pushkar8723) sourced from [Responsive Cow Jumps Over the Moooooon](https://codepen.io/sdras/pen/doZReX)\r\n<!-- // - üëØ I‚Äôm looking to collaborate on ...\r\n// - ü§î I‚Äôm looking for help with ...\r\n// - üí¨ Ask me about ... -->\r\n","url":"https://deltamaniac.github.io","relUrl":"/"},{"doc":"Todo","title":"Todo","hpath":"todo","content":"\n\r\n\r\n# ToDo BucketList\r\n\r\n- [ ] Headcrab\r\n  - [ ] ELF\r\n    - [ ] Thread Local for x86-64\r\n      https://akkadia.org/drepper/tls.pdf\r\n  - [ ] Dwarf\r\n    http://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf\r\n  - [x] Cirrus Build Conf\r\n- [x] Kafka üìñ\r\n  https://assets.confluent.io/m/1b509accf21490f0/original/20170707-EB-Confluent_Kafka_Definitive-Guide_Complete.pdf\r\n- [x] Distributed Design\r\n  https://azure.microsoft.com/mediahandler/files/resourcefiles/designing-distributed-systems/Designing_Distributed_Systems.pdf\r\n- [x] Migrate from old blog to new blog\r\n- [x] Reddit Bot for Youtube PlayList\r\n- [x] Cloud Events\r\n- [ ] k8s + Nats.io\r\n- [ ] Little Man Computer\r\n  - [ ] WASM Support\r\n- [x] Advent of Code 2020\r\n\r\n","url":"https://deltamaniac.github.io/notes\\42bff885-549f-422e-8ef8-d17ecd01ca52.html","relUrl":"notes\\42bff885-549f-422e-8ef8-d17ecd01ca52.html"},{"doc":"Rust","title":"Rust","hpath":"rust","content":"\r\n# Rust\r\n\r\n## Reddit Bot\r\n\r\n[[Vyom Bot | rust.bots.reddit]]\r\n\r\n\r\n## Kafka\r\n\r\n[[Producer | kafka.producer]]\r\n\r\n[[Consumer | kafka.consumer]]\r\n\r\n## LeetCode\r\n[[MaxDepth |  algos.trees.maxDepth#rust]]\r\n\r\n# DailyByte\r\n\r\n[[dailybyte.d1#rust]]\r\n\r\n[[dailybyte.d2#rust]]\r\n\r\n[[dailybyte.d3#rust]]\r\n\r\n[[dailybyte.d4#rust]]\r\n\r\n[[dailybyte.d5#rust]]\r\n\r\n[[dailybyte.d6#rust]]\r\n\r\n[[dailybyte.d7#rust]]\r\n\r\n[[dailybyte.d8#rust]]\r\n\r\n[[dailybyte.d9#rust]]\r\n\r\n[[dailybyte.d10#rust]]\r\n\r\n[[dailybyte.d11#rust]]\r\n\r\n[[dailybyte.d12#rust]]\r\n\r\n[[dailybyte.d13#rust]]\r\n\r\n[[dailybyte.d14#rust]]\r\n\r\n[[dailybyte.d15#rust]]\r\n\r\n[[dailybyte.d16#rust]]\r\n\r\n[[dailybyte.d17#rust]]\r\n\r\n[[dailybyte.d18#rust]]\r\n\r\n[[dailybyte.d19#rust]]\r\n\r\n[[dailybyte.d20#rust]]\r\n\r\n[[dailybyte.d21#rust]]\r\n\r\n[[dailybyte.d22#rust]]\r\n\r\n[[dailybyte.d23#rust]]\r\n\r\n[[dailybyte.d24#rust]]\r\n\r\n[[dailybyte.d25#rust]]\r\n\r\n[[dailybyte.d26#rust]]\r\n\r\n[[dailybyte.d27#rust]]","url":"https://deltamaniac.github.io/notes\\18962325-b097-4283-9f8e-23a89a24511b.html","relUrl":"notes\\18962325-b097-4283-9f8e-23a89a24511b.html"},{"doc":"Bots","title":"Bots","hpath":"rust.bots","content":"\n\r\n","url":"https://deltamaniac.github.io/notes\\947feb8a-ba58-4fd9-85fb-c599a93c13f3.html","relUrl":"notes\\947feb8a-ba58-4fd9-85fb-c599a93c13f3.html"},{"doc":"Reddit","title":"Reddit","hpath":"rust.bots.reddit","content":"\n\r\n# Vyom\r\n\r\nThe surmised version of how to write a Reddit Bot in [[rust]]\r\n\r\n# Part I\r\n\r\nRecently while browsing [reddit](https://old.reddit.com) I came up on a [post](https://www.reddit.com/r/rust/comments/i1satq/webference_rusty_days_2020_all_recorded_talks/g01rwq8/?context=3) in the [/r/rust](https://old.reddit.com) subreddit which was a link to a YouTube playlist for the Rusty-Days conference, however there was no way I could find the contents of the playlist without going to YouTube on my phone. This was a nuance so I went to YouTube and curated the list.\r\n\r\n![](/assets/images/2020-10-11-18-16-48.png)\r\n\r\n\r\nThis was going to be tiresome if I'd have to do it every time I see a post that links to a YouTube playlist. So here we are writing a bot do this task for everyone. This bot will run on a server somewhere (hopefully forever) and curate playlist info for all the people who avail its service.\r\n\r\n# Creating Credentials For Our Bot\r\n\r\nIn order to write our bot we first need to get some credentials from reddit so that we can access [reddit apis](https://old.reddit.com/dev/api) programmatically.\r\n\r\nFirst we need an application id and secret so that reddit can know our application. We can get this information by going to [preferences/app](https://www.reddit.com/prefs/apps) and clicking `are you a developer? create an app...` button cause **we definitely are.**\r\n\r\nReddit lets us choose the type of the app we want to build. The three types of app are :\r\n\r\n- Web app: Runs as part of a web service on a server you control. Can keep a secret.\r\n\r\n- Installed app: Runs on devices you don't control, such as the user's mobile phone. Cannot keep a secret, and therefore, does not receive one.\r\n\r\n- Script app: Runs on hardware you control, such as your own laptop or server. Can keep a secret. Only has access to your account.\r\n\r\nMore info about about the apps can be found [here](https://github.com/reddit-archive/reddit/wiki/oauth2-app-types).\r\n\r\nWe choose the `script` type, enter a name and description for our bot, and use the dummy url `http://www.example.com/unused/redirect/uri` for the redirect url.\r\n\r\n![](/assets/images/2020-10-11-18-17-29.png)\r\n\r\nWe have now created the credentials with Client Id : `TjC0s2uTaTHYCg` and Client Secret : `mrkAaWitnXLf_DiRagIRS_33cD8`.\r\n\r\n![](/assets/images/2020-10-11-18-18-29.png)\r\n\r\n# Using and Storing the credentials\r\n\r\nWe can now hard code the credentials in our source code and use like this.\r\n\r\n```rust\r\n# main.rs\r\n\r\nstatic  CLIENT_ID:&str=\"TjC0s2uTaTHYCg\";\r\nstatic  CLIENT_SECRET:&str=\"mrkAaWitnXLf_DiRagIRS_33cD8\";\r\n\r\nfn main(){\r\n    println!(\"Client ID: {}\",CLIENT_ID);\r\n    println!(\"Client Secret: {}\",CLIENT_SECRET);\r\n}\r\n```\r\n\r\n```shell\r\nDeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.08s\r\n     Running `target/debug/vyom`\r\nClient ID: SmQ7CzGkKA62yA\r\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g\r\n```\r\n\r\nThis is a very easy and clear way to handle credentials but it is flawed.\r\n\r\n- If we need to change the credentials then we would have to change the code, rebuild the app and restart the app.\r\n\r\n- If we decide to share the code with someone or push it github, it will expose our credentials, which can be used to hijack our account and do bad things.\r\n\r\nSo lets see if we can fix the first problem, by moving the credentials out of the source code. But where do we put it then ? If you're thinking about environment variables then you're absolutely right. Environment variables are a good place to store such values and they are fairly easy to change.\r\n\r\n```rust\r\n# main.rs\r\n\r\nfn main(){\r\n    match std::env::var(\"CLIENT_ID1\") {\r\n        Ok(client_id) => println!(\"Client ID: {}\", client_id),\r\n        Err(e) => panic!(\"Couldn't read CLIENT_ID ({})\", e),\r\n    };\r\n    match std::env::var(\"CLIENT_SECRET1\") {\r\n        Ok(client_secret) => println!(\"Client Secret: {}\", client_secret),\r\n        Err(e) => panic!(\"Couldn't read CLIENT_SECRET ({})\", e),\r\n    };\r\n}\r\n```\r\n\r\nSince our bot wont work without a `client_id` and a `client_secret` we call [panic!](https://doc.rust-lang.org/stable/std/macro.panic.html) so that the application exits with an error.\r\n\r\n```shell\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.41s\r\n     Running `target/debug/vyom`\r\nthread 'main' panicked at \\'Couldn\\'t read CLIENT_ID (environment variable not found),\r\nsrc/main.rs:9:19\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n\r\n# Set the environment variables\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ export CLIENT_SECRET=UItY35BYBEN_rFVnGVzud9Pig6g\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ export CLIENT_ID=SmQ7CzGkKA62yA\r\n\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.47s\r\n     Running `target/debug/vyom`\r\nClient ID: SmQ7CzGkKA62yA\r\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g\r\n```\r\n\r\nMost of the time we don't really want to export a lot of environment variables manually. It is exhausting. We could fix this problem by writing a shell script that has all our `export` statements... or we can use [dotenv](https://crates.io/crates/dotenv). Dotenv is a crate that provides us a way to put environment variables in a `.env` file and read them. Dotenv is smart to enough to only read from the file if the Environment Variable is **not set** on the system.\r\n\r\nWe first add the `dotenv` dependency to our `Cargo.toml` file.\r\n\r\n```toml\r\n# Cargo.toml\r\n[package]\r\nname = \"vyom\"\r\nversion = \"0.1.0\"\r\nauthors = [\"DeltaManiac <maxpaynered@gmail.com>\"]\r\nedition = \"2018\"\r\n\r\n[dependencies]\r\ndotenv_codegen=\"0.15.0\" # dotenv dependency\r\n```\r\n\r\nWe then setup the environment variables in the `.env` file.\r\n\r\n```shell\r\n# .env\r\nCLIENT_ID=test_123\r\nCLIENT_SECRET=test_321\r\nTest=DeezTests\r\n```\r\n\r\nWe finally modify our code to use the `dotenv` crate.\r\n\r\n```rust\r\n# main.rs\r\n\r\n#[macro_use]\r\nextern crate dotenv_codegen;\r\n\r\nfn main(){\r\n    println!(\"Env Not on Sys: {}\",dotenv!(\"Test\"));\r\n    println!(\"Client ID: {}\",dotenv!(\"CLIENT_ID\"));\r\n    println!(\"Client Secret: {}\",dotenv!(\"CLIENT_SECRET\"));\r\n}\r\n```\r\n\r\n```shell\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.08s\r\n     Running `target/debug/vyom`\r\nEnv Not on Sys: ss #Value from the .env file\r\nClient ID: SmQ7CzGkKA62yA #Value from the system\r\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g #Value from the system\r\n```\r\n\r\n# How will the bot work ?\r\n\r\nThe bot will listen to a mention like `/u/VyomBot` and would check if the post is a link to a YouTube playlist or at a later stage if the parent comment of the mention is a YouTube playlist.\r\n\r\n# Setting up Reddit\r\n\r\nWe can follow these steps to setup reddit for testing/developing this bot\r\n\r\n1. Created a new user called [VyomBot](https://old.reddit.com/user/VyomBot) so that the bot can be mentioned via `/u/VyomBot`\r\n\r\n2. Registered a new app of `script` type for `/u/VyomBot`\r\n\r\n3. Create a new [subreddit](https://old.reddit.com/ur/VyomBot) `/r/VyomBot` as a test play ground.\r\n\r\n![](/assets/images/2020-10-11-18-20-37.png)\r\n\r\n4. Create a new [post](https://www.reddit.com/r/VyomBot/comments/i6fk15/test_playlist/?) with the link to the playlist.\r\n\r\n5. Mention `/u/VyomBot` in the comments.\r\n\r\n![](/assets/images/2020-10-11-18-21-13.png)\r\n\r\n# Talking to Reddit\r\n\r\n## Getting Messages from Inbox\r\n\r\nLets start off by querying reddit to see if we have a new mention and printing the message. We will use the [roux](https://crates.io/crates/roux) crate for interacting with the reddit apis.\r\nDirect quote from the description of the crate\r\n\r\n> A simple, asynchronous Reddit API wrapper implemented in Rust.\r\n\r\nThis means that we have to use a framework like [tokio](https://crates.io/crates/tokio) to provide the async runtime for our bot.\r\nLets go about doing that.\r\n\r\nAdd the dependencies to our Cargo.toml file.\r\n\r\n```toml\r\n# Cargo.toml\r\n[package]\r\nname = \"vyom\"\r\nversion = \"0.1.0\"\r\nauthors = [\"DeltaManiac <maxpaynered@gmail.com>\"]\r\nedition = \"2018\"\r\n\r\n[dependencies]\r\ndotenv_codegen=\"0.15.0\" # dotenv dependency\r\nroux=\"1.0.0\" # roux dependency\r\ntokio = {version=\"0.2.22\",features=[\"macros\"]} # tokio dependency and only enable the macro feature\r\n```\r\n\r\nUpdate our code to use the library and call the reddit apis.\r\n\r\n```rust\r\n# main.rs\r\n\r\n#[macro_use]\r\nextern crate dotenv_codegen;\r\n#[macro_use]\r\nextern crate log; // Used for logging\r\nuse roux::Reddit;\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    match Reddit::new(\r\n        dotenv!(\"VYOM_USERAGENT\"),\r\n        dotenv!(\"VYOM_CLIENT_ID\"),\r\n        dotenv!(\"VYOM_CLIENT_SECRET\"),\r\n    )\r\n    .username(dotenv!(\"VYOM_USERNAME\"))\r\n    .password(dotenv!(\"VYOM_PASSWORD\"))\r\n    .login()\r\n    .await\r\n    {   // Try to make a new client with the credentials\r\n        Ok(client) => match client.inbox().await {\r\n            // Fetch the inbox of the logged in user\r\n            Ok(listing) => {\r\n                println!(\"Message Count {}\", listing.data.children.len());\r\n                dbg!(listing.data.children.get(0).unwrap());\r\n            }\r\n            Err(_) => {\r\n                error!(\"Failed to fetch messages\");\r\n            }\r\n        },\r\n        Err(e) => panic!(e),\r\n    }\r\n}\r\n\r\n```\r\n\r\nWhen we run the program we get the number of messages we have and the `dbg!` macro shows what the passed in variable which in this case is a `InboxItem` struct, looks like.\r\n\r\n```shell\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 3.71s\r\n     Running `target/debug/vyom`\r\nMessage Count 5\r\n[src/main.rs:24] &listing.data.children.get(0).unwrap().data = InboxItem {\r\n    id: \"g0vfbra\",\r\n    subject: \"username mention\",\r\n    was_comment: true,\r\n    author: Some(\r\n        \"DeltaManiac\",\r\n    ),\r\n    parent_id: Some(\r\n        \"t3_i6fk15\",\r\n    ),\r\n    subreddit_name_prefixed: Some(\r\n        \"r/VyomBot\",\r\n    ),\r\n    new: true,\r\n    type: \"username_mention\",\r\n    body: \"/u/VyomBot\",\r\n    dest: \"VyomBot\",\r\n    body_html: \"&lt;!-- SC_OFF --&gt;&lt;div class=\\\"md\\\"&gt;&lt;p&gt;&lt;a href=\\\"/u/VyomBot\\\"&gt;/u/VyomBot&lt;/a&gt;&lt;/p&gt;\\n&lt;/div&gt;&lt;!-- SC_ON --&gt;\",\r\n    name: \"t1_g0vfbra\",\r\n    created: 1596987973.0,\r\n    created_utc: 1596959173.0,\r\n    context: \"/r/VyomBot/comments/i6fk15/test_playlist/g0vfbra/?context=3\",\r\n}\r\n```\r\n\r\nWe can use the `new` property to identify if this is a message that we had previously read.\r\nThe type property can be used to determine if the item is a comment or a username mention.\r\nWe can use this to iterate over the messages retrieved and and determine the messages that we have to reply to.\r\n\r\n# Replying to the message\r\n\r\nRoux provides us a convenient method aptly name `comment` to reply to the message. Let's go ahead and use this to reply to the message.\r\n\r\n```rust\r\n# main.rs\r\n\r\nasync fn main() {\r\n...\r\n...\r\n// Fetch the inbox of the logged in user\r\n    Ok(listing) => {\r\n        for message in listing.data.children.iter() {\r\n            is message unread and of type \"username_mention\"\r\n            if message.data.new && message.data.r#type == \"username_mention\" {\r\n                match client\r\n                    .comment(\r\n                        \"You have been Noted by Vyom. Please Stand By!\",\r\n                        &message.data.name.as_str(),\r\n                    )\r\n                    .await\r\n                {\r\n                    Ok(_) => info!(\"Replied to {}\", message.data.name),\r\n                    Err(_) => error!(\"Failed to reply to mention\"),\r\n                };\r\n            }\r\n        }\r\n    }\r\n...\r\n...\r\n```\r\n\r\n> Psst.., I'll let you in on something cool. In rust `type` is a reserved keyword. In most programming languages you can use a keyword only as keyword, e.g. you _cannot_ have a variable called `for`. In rust we can use `type` as an attribute of a struct and access it by specifying it as a raw string using the `r#` like `message.data.r#type`\r\n\r\nNow that we have written the code lets run it and see what happens..\r\n\r\n```shell\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 4.45s\r\n     Running `target/debug/vyom`\r\n```\r\n\r\nNice! It logged that we replied to the mention. Lets run it again, this time it should not reply to an already replied message as we have read it.\r\n\r\n```shell\r\n[2020-08-09T12:59:25Z INFO  vyom] Replied to t1_g0vfbra\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.10s\r\n     Running `target/debug/vyom`\r\n[2020-08-09T12:59:29Z INFO  vyom] Replied to t1_g0vfbra\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.09s\r\n     Running `target/debug/vyom`\r\n[2020-08-09T12:59:32Z INFO  vyom] Replied to t1_g0vfbra\r\n```\r\n\r\nDamn!\r\nIT REPLIED AGAIN!!!üòû\r\nAnd this is what the subreddit looks like now.\r\n\r\n![](/assets/images/2020-10-11-18-22-14.png)\r\n\r\nTime to find that pesky bug and get rid of it for good.\r\n\r\nLets go to reddit and see what the inbox looks like.\r\n\r\n![](/assets/images/2020-10-11-18-22-29.png)\r\n\r\n\r\nWell, its just as we suspected, when we reply to a mention with the `comment` function it does not change the status of the message. Sifting through the [documentation](https://docs.rs/roux/1.0.0/roux/?search=read) of `roux` we can find a method that marks a message as `read`.\r\n\r\nThe place we are at right now reminds of a the poem [The Road Not Taken](https://www.poetryfoundation.org/poems/44272/the-road-not-taken) by Robert Frost. It talks about how the author finds two roads diverging in the wood and he ponders which one to travel upon. I ask you to take a few minutes and read the poem, its beautiful.\r\n\r\nI'll be waiting!\r\n\r\nOh BTW the code can be found on the `part-I` branch [here](https://github.com/DeltaManiac/VyomBot)\r\n\r\n# Part II\r\n\r\nIf you had read the poem mentioned in the previous part, you can be pretty sure what we are going to do right now. You Betcha! We are going to go down the Rabbit Hole.\r\n\r\nJust as in the poem it would have been easy for us to change the library to something that already has a `mark as read` method like many do and continue on, but like Frost we will take the road not taken and that might make all the difference. üòâ\r\n\r\n## Down the Rabbit Hole\r\n\r\nWe actually got stumped on the last part because there was no method to mark a message as read in `roux`. This makes one wonder if there isn't such an api for reddit or that `roux` just didn't implement it.\r\n\r\nLets head to [reddit api docs](https://www.reddit.com/dev/api) and try our luck.\r\n\r\nYep, reddit does have a [`read_message`](https://www.reddit.com/dev/api#POST_api_read_message) api for us to use exactly for this purpose. The api accepts a list of [fullnames](https://www.reddit.com/dev/api#fullnames) with an HTTP POST method.\r\n\r\nWhat is the `fullname` for our message ? Its nothing but the `name` parameter of the struct.\r\n\r\nNow to fix `roux`, so that we can mark the message as read.\r\n\r\nLets clone the [roux source code](https://github.com/halcyonnouveau/roux.rs) into another directory.\r\n\r\nSince the `comment` method we used is an api which POSTS the comment data to reddit. Perhaps we can ~~reuse~~, who are we kidding ? We can definitely _copy-paste_ and modify the code to send some data to the `read_message` api.\r\n\r\n> While searching for a way to mark a message as read, we came up across another api [`message/unread`](https://www.reddit.com/dev/api#GET_message_unread) which returns only the unread messages from our inbox, so we don't have to filter out on the `new` flag of the response anymore. Yay!\r\n\r\n```rust\r\n# src/me/mod.rs\r\n...\r\n/// Get user's submitted posts.\r\n    pub async fn inbox(&self) -> Result<BasicListing<InboxItem>, RouxError> {\r\n        Ok(self\r\n            .get(\"message/inbox\")\r\n            .await?\r\n            .json::<BasicListing<InboxItem>>()\r\n            .await?)\r\n    }\r\n\r\n/** This is our addition **/\r\n///  Get users unread messages\r\n    pub async fn unread(&self) -> Result<BasicListing<InboxItem>, RouxError> {\r\n        Ok(self\r\n            .get(\"message/unread\")\r\n            .await?\r\n            .json::<BasicListing<InboxItem>>()\r\n            .await?)\r\n    }\r\n\r\n/** This is our addition **/\r\n/// Mark message as read\r\n    pub async fn mark_read(&self, ids: &str) -> Result<Response, RouxError> {\r\n        let form = [(\"id\", ids)];\r\n        self.post(\"api/read_message\", &form).await\r\n    }\r\n\r\n/** This is our addition **/\r\n/// Mark messages as unread\r\n    pub async fn mark_read(&self, ids: &str) -> Result<Response, RouxError> {\r\n        let form = [(\"id\", ids)];\r\n        self.post(\"api/unread_message\", &form).await\r\n    }\r\n\r\n    pub async fn comment(&self, text: &str, parent: &str) -> Result<Response, RouxError> {\r\n        let form = [(\"text\", text), (\"parent\", parent)];\r\n        self.post(\"api/comment\", &form).await\r\n    }\r\n...\r\n```\r\n\r\n> I've submitted a [PR](https://github.com/halcyonnouveau/roux.rs/pull/13) to roux with these changes.\r\n\r\nSo all is good and well with the change, but how do we use this changed version with our code ?\r\n\r\n`Cargo.toml` is the answer. We can tell `Cargo.toml` to use the code from a directory or from a url for a specified crate. Since we have a the modified source code in our system, we can point to that to get it working.\r\n\r\n```toml\r\n# Cargo.toml\r\n\r\n[package]\r\nname = \"vyom\"\r\nversion = \"0.1.0\"\r\nauthors = [\"Harikrishnan Menon <harikrishnan.menon@sap.com>\"]\r\nedition = \"2018\"\r\n\r\n[dependencies]\r\nroux={path=\"../roux.rs\"} #This points to our local modified copy\r\n# roux={git = \"https://github.com/DeltaManiac/roux.rs\"} #This points to the modified version on github\r\ndotenv_codegen=\"0.15.0\"\r\ntokio = {version=\"0.2.22\", features=[\"macros\"]}\r\nenv_logger =\"0.7.1\"\r\nlog = \"0.4.11\"\r\n```\r\n\r\nWhen we build our project now, we can see that it picks up the roux source code from the new path specified by us.\r\n\r\n```shell\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo build\r\n   Compiling roux v1.0.1-alpha.0 (/Users/DeltaManiac/git/rust/roux.rs)\r\n   Compiling vyom v0.1.0 (/Users/DeltaManiac/git/rust/vyom)\r\n   Finished dev [unoptimized + debuginfo] target(s) in 6.70s\r\n```\r\n\r\n> If we don't want go through the hassle of doing this, we can point cargo to my fork which has the necessary changes. This is how the code would be in the repository.\r\n\r\n## Actually Squashing the Bug\r\n\r\nNow that we are back from our exceedingly educating trip down the rabbit hole, lets see how we can finally mark a message as read after we reply to it.\r\n\r\n```rust\r\n# main.rs\r\n...\r\n...\r\n// Fetch only the unread messages form the inbox of the logged in user\r\nOk(client) => match client.unread().await {\r\n    Ok(listing) => {\r\n        for message in listing.data.children.iter() {\r\n            // We have removed the `new` check\r\n            if message.data.r#type == \"username_mention\" {\r\n                match client\r\n                    .comment(\r\n                        \"Thank you for standing by while we squished a bug. You shouldn't be seeing this message again!\",\r\n                        &message.data.name.as_str(),\r\n                    )\r\n                    .await\r\n                {\r\n                    Ok(_) => {\r\n                        info!(\"Replied to {}\", message.data.name);\r\n                        match client.mark_read(message.data.name.as_str()).await {\r\n                            Ok(_) => info!(\"Marked {} as read\", message.data.name),\r\n                            Err(_) => {\r\n                                error!(\"Failed to mark {} as read\", message.data.name)\r\n                            }\r\n                        }\r\n                    }\r\n                    Err(_) => error!(\"Failed to reply to mention {}\", message.data.name),\r\n                };\r\n            }\r\n        }\r\n    }\r\n...\r\n...\r\n```\r\n\r\nWe have changed the reply text so that we can identify from reddit that it is actually the new reply that is being sent, and we call the `mark_read` method form the modified crate to mark the message as read.\r\n\r\nLets run the code and see if it works. Fingers Crossed.\r\n\r\n```shell\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n   Compiling vyom v0.1.0\r\n    Finished dev [unoptimized + debuginfo] target(s) in 4.41s\r\n     Running `target/debug/vyom`\r\n[2020-08-09T16:38:11Z INFO  vyom] Replied to t1_g0vfbra\r\n[2020-08-09T16:38:11Z INFO  vyom] Marked t1_g0vfbra as read\r\n```\r\n\r\nCool, but does it actually mark the message as read? Lets run the program again a couple more times and figure it out.\r\n\r\n```shell\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.10s\r\n     Running `target/debug/vyom`\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.10s\r\n     Running `target/debug/vyom`\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $\r\n```\r\n\r\nSince there doesn't seem to to be any logs being printed we can confirm that we are not replying again to the message. But it programming and you never know if you're right until you completely verify from reddit side too. Let go take a look at the subreddit.\r\n\r\n![](/assets/images/2020-10-11-18-24-11.png)\r\n\r\nYep, it has only one comment.\r\n\r\n## Extracting the Intel\r\n\r\nNow that we have figured out how to respond to comments, lets get to the actual crux of the problem.\r\n\r\nWhen a VyomBot gets mentioned where should he look for the Youtube link? There can be many answers to this question like\r\n\r\n1. The immediate parent comment of the mention\r\n2. The title of the post\r\n3. It could be part of the message sent to VyomBot\r\n\r\nThese all seem relevant, but to keep it simple lets start with 2, i.e if the parent is a YouTube playlist link then we fetch the information and post it as a comment.\r\n\r\nIn order to get the link of the playlist we are not going to use the roux library but instead handwrite it ourselves. Why you ask ? CAUSE ITS GONNA BE FUN!!\r\n\r\n> Note to reader the next part of the code is kind of hacky code and do not follow idiomatic rust. Here be Dragons üêâüêâüêâ\r\n\r\n### Constructing the Reddit Post link\r\n\r\nWe can use the `context` field of the response which looks like\r\n\r\n```json\r\n{\r\n...\r\n...\r\n    name: \"t1_g0vfbra\",\r\n    created: 1596987973.0,\r\n    created_utc: 1596959173.0,\r\n    context: \"/r/VyomBot/comments/i6fk15/test_playlist/g0vfbra/?context=3\",\r\n}\r\n```\r\n\r\nto construct the url of the post.\r\n\r\nThe first 5 parts `r`, `VyomBot`, `comments`, `i6fk15`, `test_playlist` can be used to for the url to the post.\r\nLet's do this right now.\r\n\r\n```rust\r\n# main.rs\r\n...\r\n if message.data.r#type == \"username_mention\" {\r\nlet post_url = format!(\r\n    \"https://www.reddit.com/{}/.json\",\r\n    message\r\n        .data\r\n        .context // /r/VyomBot/comments/i6fk15/test_playlist/g0vfbra/?context=3\r\n        .trim() // remove any trailing and leading spaces\r\n        .split('/') // [ \"\", \"r\", \"VyomBot\", \"comments\", \"i6fk15\", \"test_playlist\", \"g0vfbra\", \"?context=3\" ]\r\n        .skip(1) // [ \"r\", \"VyomBot\", \"comments\", \"i6fk15\", \"test_playlist\", \"g0vfbra\", \"?context=3\" ]\r\n        .collect::<Vec<&str>>()[0..=4] // Take the first 5 [ \"r\", \"VyomBot\", \"comments\", \"i6fk15\", \"test_playlist\" ]\r\n        .join(\"/\") // /r/VyomBot/comments/i6fk15/test_playlist/\r\n    );\r\n...\r\n```\r\n\r\nWe now have constructed the url `https://www.reddit.com/{}/r/VyomBot/comments/i6fk15/test_playlist/.json`. The `.json` at the end tells reddit to return the JSON formatted and not the HTML page of the post id specified\r\n\r\n### Extracting the Playlist ID\r\n\r\nIn order to query the url that we crafted above we would be using the [`reqwest`](https://crates.io/crates/reqwest) crate and the [`url`](https://crates.io/crates/url) crate. We fire a GET request to reddit and extract the `url` parameter from the response body which would have our link.\r\n\r\nWe then would convert the response body to a dynamic json using the [`serde_json`](https://crates.io/crates/serde_json) crate and then extract the link from the `url` property of the response.\r\n\r\nThen the [`url`](https://crates.io/crates/url) crate to parse and extract the playlist id from the YouTube link. For our link\r\n`https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ` the playlist id is `PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ`.\r\n\r\n```toml\r\n# Cargo.toml\r\n\r\n[package]\r\nname = \"vyom\"\r\nversion = \"0.1.0\"\r\nauthors = [\"Harikrishnan Menon <harikrishnan.menon@sap.com>\"]\r\nedition = \"2018\"\r\n\r\n[dependencies]\r\nroux={path=\"../roux.rs\"} #This points to our local modified copy\r\n# roux={git = \"https://github.com/DeltaManiac/roux.rs\"} #This points to the modified version on github\r\ndotenv_codegen=\"0.15.0\"\r\ntokio = {version=\"0.2.22\", features=[\"macros\"]}\r\nenv_logger =\"0.7.1\"\r\nlog = \"0.4.11\"\r\nreqwest = {version=\"0.10.7\",features=[\"json\"]} // New\r\nserde_json = \"1.0.57\" // New\r\nurl = \"2.1.1\"  // New\r\n\r\n```\r\n\r\n```rust\r\n# main.rs\r\n...\r\n...\r\n// Make an http request to the post url\r\nlet playlist_id = match reqwest::get(&post_url).await {\r\n    // If the response is received convert it in to dynamic json\r\n    Ok(response) => match response.json::<serde_json::Value>().await {\r\n        Ok(json) => {\r\n            // Get json[0][\"data\"][\"children][0][\"url}\r\n            // NB: DO NOT USE THIS CODE IN PRODUCTION\r\n            let url = match json\r\n                .get(0)\r\n                .unwrap()\r\n                .get(\"data\")\r\n                .unwrap()\r\n                .get(\"children\")\r\n                .unwrap()\r\n                .get(0)\r\n                .unwrap()\r\n                .get(\"data\")\r\n                .unwrap()\r\n                .get(\"url\")\r\n            {\r\n                // Parse the youtube url from the string\r\n                // \"https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\"\r\n                // after trimming `\"`\r\n                Some(url) => match url::Url::parse(\r\n                    &url.to_string().trim_matches('\\\"'),\r\n                ) {\r\n                    Ok(url) => {\r\n                        match (\r\n                            // From the query parameters\r\n                            // find the parameter with key \"list\"\r\n                            url.query_pairs().find(|q| {\r\n                                q.0 == \"list\"\r\n                            }),\r\n                            // Also check if the host is youtube\r\n                            (url.host_str() == Some(\"youtube.com\")\r\n                                || url.host_str()\r\n                                    == Some(\"www.youtube.com\")),\r\n                        ) {\r\n                            (Some((_, val)), true) => {\r\n                                // Return the url\r\n                                Some(val.into_owned())\r\n                            }\r\n                            (_, _) => {\r\n                                error!(\r\n                                    \"Couldn't find `list` param in url {} for message : {}\",\r\n                                    &url.to_string(),\r\n                                    &message.data.name\r\n                                );\r\n                                None\r\n                            }\r\n                        }\r\n                    }\r\n                    // Error Handling\r\n...\r\n\r\ndbg!(playlist_id);\r\n...\r\n...\r\n```\r\n\r\n> A better way to handle the response is to create a struct that mimics the response and just let the `.json()` method of reqwest do the heavy lifting of converting it into rust types. This will help avoid all the calls to `unwrap`.\r\n\r\n> The nested matches statements should be replaced by `.and_then()` for a more cleaner and readable code.\r\n\r\n```shell\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\nCompiling vyom v0.1.0\r\nFinished dev [unoptimized + debuginfo] target(s) in 5.09s     Running `target/debug/vyom`\r\n[src/main.rs:200] \"playlist_id\" = \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\"\r\n[src/main.rs:200] \"playlist_id\" = \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\"\r\n```\r\n\r\nHooray! We've come a long way since we started, written some atrocious code, contributed to a library and even rolled out our own code instead of using library code to talk to talk to reddit.\r\n\r\nI know its getting boring now and we're gonna wrap it up in the next part.\r\n\r\nOh BTW the code can be found on the `part-II` branch [here](https://github.com/DeltaManiac/VyomBot)\r\n\r\n\r\n# Part III\r\n\r\nWe've reached the final chapter. The spoils are just ahead of us, lets go grab em.\r\n\r\n# Obtaining Credentials\r\n\r\nWe need to generate a different set of credentials to talk with YouTube. Lets go do that step by step..\r\n\r\n1. Logon to [Google Developer Console](https://console.developer.google.com)\r\n\r\n2. Click `Enable Apis and Service`\r\n    ![](/assets/images/2020-10-11-18-26-54.png)\r\n\r\n3. Search for `YouTube Data API v3`\r\n    ![](/assets/images/2020-10-11-18-27-09.png)\r\n\r\n4. Click the `Enable` button to enable the API for our account\r\n    ![](/assets/images/2020-10-11-18-27-17.png)\r\n\r\n5. Click the `Create Credentials` button to start creating credentials for us to use.\r\n    ![](/assets/images/2020-10-11-18-27-29.png)\r\n\r\n6. We need to first describe what kind of credentials have to be generated. Don't worry, just follow the screenshot.\r\n    ![](/assets/images/2020-10-11-18-27-39.png)\r\n\r\n7. We're Done!\r\n    ![](/assets/images/2020-10-11-18-27-51.png)\r\n\r\n\r\n# Handling JSON better\r\n\r\nIn the last part we used a dynamic JSON to to retrieve the playlist url from Reddit. This time to interact with the YouTube API we wont do that, instead we will one up ourselves and de-serialize the JSON into structs that we define in rust.\r\n\r\n> We use [`serde`](https://crates.io/crates/serde) to do handle the heavy lifting of JSON de-serialization\r\n\r\nThe response of the YouTube API is a bit more well defined than the Reddit API.\r\n\r\n```json\r\n{\r\n  \"kind\": \"youtube#playlistItemListResponse\",\r\n  \"etag\": \"Fij-lGuELswW5Y6HXEJsEVAZ6Xg\",\r\n  \"nextPageToken\": \"CAUQAA\",\r\n  \"items\": [\r\n    {\r\n      \"kind\": \"youtube#playlistItem\",\r\n      \"etag\": \"KC_3PIeEyspbfuA_AplI4dv2ITA\",\r\n      \"id\": \"UExmM3U4TmhvRWlraFRDNXJhZEdybW1xZGtPSy14TURvWi45ODRDNTg0QjA4NkFBNkQy\",\r\n      \"snippet\": {\r\n        \"publishedAt\": \"2020-08-05T19:31:06Z\",\r\n        \"channelId\": \"UC9X86dyEwpbCnpC18qjt33Q\",\r\n        \"title\": \"Rusty Days 2020 - Hackathon Submissions\",\r\n        \"description\": \"Rules ‚ñ∫ https://rusty-days.org/hackathon/\\n\\nTeams ‚ñ∫\\narrugginiti https://github.com/Rust-Wroclaw/rd-hack-arrugginiti\\nBox-Team https://github.com/Rust-Wroclaw/rd-hack-Box-Team\\nBrighter3D https://github.com/Rust-Wroclaw/rd-hack-Brighter3D\\nhexyoungs https://github.com/Rust-Wroclaw/rd-hack-hexyoungs\\nLastMinute https://github.com/Rust-Wroclaw/rd-hack-LastMinute\\nplanters https://github.com/Rust-Wroclaw/rd-hack-planters\\n\\nFollow ‚ñ∫\\nFacebook: https://rusty-days.org/facebook\\nTwitch: https://rusty-days.org/twitch\\nTwitter: https://rusty-days.org/twitter\",\r\n        \"thumbnails\": {\r\n          \"default\": {\r\n            \"url\": \"https://i.ytimg.com/vi/QaCvUKrxNLI/default.jpg\",\r\n            \"width\": 120,\r\n            \"height\": 90\r\n          },\r\n          \"medium\": {\r\n            \"url\": \"https://i.ytimg.com/vi/QaCvUKrxNLI/mqdefault.jpg\",\r\n            \"width\": 320,\r\n            \"height\": 180\r\n          },\r\n          \"high\": {\r\n            \"url\": \"https://i.ytimg.com/vi/QaCvUKrxNLI/hqdefault.jpg\",\r\n            \"width\": 480,\r\n            \"height\": 360\r\n          },\r\n          \"standard\": {\r\n            \"url\": \"https://i.ytimg.com/vi/QaCvUKrxNLI/sddefault.jpg\",\r\n            \"width\": 640,\r\n            \"height\": 480\r\n          }\r\n        },\r\n        \"channelTitle\": \"Rust Wroc≈Çaw\",\r\n        \"playlistId\": \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\",\r\n        \"position\": 0,\r\n        \"resourceId\": {\r\n          \"kind\": \"youtube#video\",\r\n          \"videoId\": \"QaCvUKrxNLI\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"youtube#playlistItem\",\r\n      \"etag\": \"EgGMmoAJ81l2BJFspcg1idaKy-8\",\r\n      \"id\": \"UExmM3U4TmhvRWlraFRDNXJhZEdybW1xZGtPSy14TURvWi5EMEEwRUY5M0RDRTU3NDJC\",\r\n      \"snippet\": {\r\n        \"publishedAt\": \"2020-08-01T12:17:09Z\",\r\n        \"channelId\": \"UC9X86dyEwpbCnpC18qjt33Q\",\r\n        \"title\": \"Rusty Days 2020 - Tim McNamara: How 10 open source projects manage unsafe code\",\r\n        \"description\": \"Agenda ‚ñ∫ https://rusty-days.org/agenda\\nSlides ‚ñ∫https://rusty-days.org/assets/slides/08-how-10-open-source-projects-manage-unsafe-code.pdf\\nPlaylist with all talks ‚ñ∫ https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\\n\\nFollow ‚ñ∫\\nFacebook: https://rusty-days.org/facebook\\nTwitch: https://rusty-days.org/twitch\\nTwitter: https://rusty-days.org/twitter\\n\\nThis video ‚ñ∫\\nIs it safe to use unsafe? Learn why some projects need unsafe code and how projects manage its risks.\\n\\nThis talk will briefly discuss what the unsafe keyword enables and what its risks are. The bulk of time will be spent discussing how projects manage those risks. It finishes by providing recommendations based on that analysis.\\n\\nProjects surveyed include:\\n* Servo (Mozilla)\\n* Fuchsia OS (Google)\\n* fast_rsync (Dropbox)\\n* winrt-rs (Microsoft)\\n* Firecracker (AWS)\\n* Linkerd2\",\r\n        \"thumbnails\": {\r\n          \"default\": {\r\n            \"url\": \"https://i.ytimg.com/vi/9M0NQI5Cp2c/default.jpg\",\r\n            \"width\": 120,\r\n            \"height\": 90\r\n          },\r\n          \"medium\": {\r\n            \"url\": \"https://i.ytimg.com/vi/9M0NQI5Cp2c/mqdefault.jpg\",\r\n            \"width\": 320,\r\n            \"height\": 180\r\n          },\r\n          \"high\": {\r\n            \"url\": \"https://i.ytimg.com/vi/9M0NQI5Cp2c/hqdefault.jpg\",\r\n            \"width\": 480,\r\n            \"height\": 360\r\n          },\r\n          \"standard\": {\r\n            \"url\": \"https://i.ytimg.com/vi/9M0NQI5Cp2c/sddefault.jpg\",\r\n            \"width\": 640,\r\n            \"height\": 480\r\n          },\r\n          \"maxres\": {\r\n            \"url\": \"https://i.ytimg.com/vi/9M0NQI5Cp2c/maxresdefault.jpg\",\r\n            \"width\": 1280,\r\n            \"height\": 720\r\n          }\r\n        },\r\n        \"channelTitle\": \"Rust Wroc≈Çaw\",\r\n        \"playlistId\": \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\",\r\n        \"position\": 1,\r\n        \"resourceId\": {\r\n          \"kind\": \"youtube#video\",\r\n          \"videoId\": \"9M0NQI5Cp2c\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"youtube#playlistItem\",\r\n      \"etag\": \"3gm-0cEUcjfm1v1vgh_3EjS6mJg\",\r\n      \"id\": \"UExmM3U4TmhvRWlraFRDNXJhZEdybW1xZGtPSy14TURvWi40NzZCMERDMjVEN0RFRThB\",\r\n      \"snippet\": {\r\n        \"publishedAt\": \"2020-08-01T12:16:07Z\",\r\n        \"channelId\": \"UC9X86dyEwpbCnpC18qjt33Q\",\r\n        \"title\": \"Rusty Days 2020 - Luca Palmieri: Are we observable yet?\",\r\n        \"description\": \"Agenda ‚ñ∫ https://rusty-days.org/agenda\\nSlides ‚ñ∫https://rusty-days.org/assets/slides/07-are-we-observable-yet.pdf\\nPlaylist with all talks ‚ñ∫ https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\\n\\nFollow ‚ñ∫\\nFacebook: https://rusty-days.org/facebook\\nTwitch: https://rusty-days.org/twitch\\nTwitter: https://rusty-days.org/twitter\\n\\nThis video ‚ñ∫\\nIs Rust ready for mainstream usage in backend development?\\n\\nThere is a lot of buzz around web frameworks while many other (critical!) Day 2 concerns do not get nearly as much attention.\\n\\nWe will discuss observability: do the tools currently available in the Rust ecosystem cover most of your telemetry needs?\\n\\nI will walk you through our journey here at TrueLayer when we built our first production backend system in Rust, Donate Direct.\\n\\nWe will be touching on the state of Rust tooling for logging, metrics and distributed tracing.\",\r\n        \"thumbnails\": {\r\n          \"default\": {\r\n            \"url\": \"https://i.ytimg.com/vi/HtKnLiFwHJM/default.jpg\",\r\n            \"width\": 120,\r\n            \"height\": 90\r\n          },\r\n          \"medium\": {\r\n            \"url\": \"https://i.ytimg.com/vi/HtKnLiFwHJM/mqdefault.jpg\",\r\n            \"width\": 320,\r\n            \"height\": 180\r\n          },\r\n          \"high\": {\r\n            \"url\": \"https://i.ytimg.com/vi/HtKnLiFwHJM/hqdefault.jpg\",\r\n            \"width\": 480,\r\n            \"height\": 360\r\n          },\r\n          \"standard\": {\r\n            \"url\": \"https://i.ytimg.com/vi/HtKnLiFwHJM/sddefault.jpg\",\r\n            \"width\": 640,\r\n            \"height\": 480\r\n          },\r\n          \"maxres\": {\r\n            \"url\": \"https://i.ytimg.com/vi/HtKnLiFwHJM/maxresdefault.jpg\",\r\n            \"width\": 1280,\r\n            \"height\": 720\r\n          }\r\n        },\r\n        \"channelTitle\": \"Rust Wroc≈Çaw\",\r\n        \"playlistId\": \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\",\r\n        \"position\": 2,\r\n        \"resourceId\": {\r\n          \"kind\": \"youtube#video\",\r\n          \"videoId\": \"HtKnLiFwHJM\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"youtube#playlistItem\",\r\n      \"etag\": \"2C9sX2xuTowOxjn0m95AH53JiA4\",\r\n      \"id\": \"UExmM3U4TmhvRWlraFRDNXJhZEdybW1xZGtPSy14TURvWi5GNjNDRDREMDQxOThCMDQ2\",\r\n      \"snippet\": {\r\n        \"publishedAt\": \"2020-07-31T11:28:34Z\",\r\n        \"channelId\": \"UC9X86dyEwpbCnpC18qjt33Q\",\r\n        \"title\": \"Rusty Days 2020 - Jan-Erik Rediger: Leveraging Rust to build cross-platform mobile libraries\",\r\n        \"description\": \"Agenda ‚ñ∫ https://rusty-days.org/agenda\\nSlides ‚ñ∫https://rusty-days.org/assets/slides/06-cross-platform-mobile-libraries.pdf\\nPlaylist with all talks ‚ñ∫ https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\\n\\nFollow ‚ñ∫\\nFacebook: https://rusty-days.org/facebook\\nTwitch: https://rusty-days.org/twitch\\nTwitter: https://rusty-days.org/twitter\\n\\n\\nThis video ‚ñ∫\\nAt Mozilla, Firefox is not the only product we ship. Many others ‚Äî including a variety of smartphone applications, and certainly not just web browsers ‚Äî are built by various teams across the organization. These applications are composed of a multitude of libraries which, when possible, are reused across platforms.\\n\\nIn the past year we used Rust to rebuild one of these libraries: the library powering the telemetry in our mobile applications is now integrated into Android and iOS applications and will soon be powering our Desktop platforms as well.\\n\\nThis talk will showcase how this small team managed to create a cross-platform Rust library, and ship it to a bunch of platforms all at once.\",\r\n        \"thumbnails\": {\r\n          \"default\": {\r\n            \"url\": \"https://i.ytimg.com/vi/j5rczOF7pzg/default.jpg\",\r\n            \"width\": 120,\r\n            \"height\": 90\r\n          },\r\n          \"medium\": {\r\n            \"url\": \"https://i.ytimg.com/vi/j5rczOF7pzg/mqdefault.jpg\",\r\n            \"width\": 320,\r\n            \"height\": 180\r\n          },\r\n          \"high\": {\r\n            \"url\": \"https://i.ytimg.com/vi/j5rczOF7pzg/hqdefault.jpg\",\r\n            \"width\": 480,\r\n            \"height\": 360\r\n          },\r\n          \"standard\": {\r\n            \"url\": \"https://i.ytimg.com/vi/j5rczOF7pzg/sddefault.jpg\",\r\n            \"width\": 640,\r\n            \"height\": 480\r\n          },\r\n          \"maxres\": {\r\n            \"url\": \"https://i.ytimg.com/vi/j5rczOF7pzg/maxresdefault.jpg\",\r\n            \"width\": 1280,\r\n            \"height\": 720\r\n          }\r\n        },\r\n        \"channelTitle\": \"Rust Wroc≈Çaw\",\r\n        \"playlistId\": \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\",\r\n        \"position\": 3,\r\n        \"resourceId\": {\r\n          \"kind\": \"youtube#video\",\r\n          \"videoId\": \"j5rczOF7pzg\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"youtube#playlistItem\",\r\n      \"etag\": \"pB_4gb7ai1HOgVLz8Jx9SJB1P_g\",\r\n      \"id\": \"UExmM3U4TmhvRWlraFRDNXJhZEdybW1xZGtPSy14TURvWi45NDk1REZENzhEMzU5MDQz\",\r\n      \"snippet\": {\r\n        \"publishedAt\": \"2020-07-31T09:06:09Z\",\r\n        \"channelId\": \"UC9X86dyEwpbCnpC18qjt33Q\",\r\n        \"title\": \"Rusty Days 2020 -  Nell Shamrell - Harrington: The Rust Borrow Checker - A Deep Dive\",\r\n        \"description\": \"Agenda ‚ñ∫ https://rusty-days.org/agenda\\nSlides ‚ñ∫https://rusty-days.org/assets/slides/05-the-rust-borrow-checker.pdf\\nPlaylist with all talks ‚ñ∫ https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\\n\\nFollow ‚ñ∫\\nFacebook: https://rusty-days.org/facebook\\nTwitch: https://rusty-days.org/twitch\\nTwitter: https://rusty-days.org/twitter\\n\\nThis video ‚ñ∫\\n\\nThe Rust compiler's borrow checker is critical for ensuring safe Rust code. Even more critical, however, is how the borrow checker provides useful, automated guidance on how to write safe code when the check fails. \\n\\nEarly in your Rust journey, it may feel like you are fighting the borrow checker. Come to this talk to learn how you can transition from fighting the borrow checker to using its guidance to write safer and more powerful code at any experience level. Walk away not only understanding the what and the how of the borrow checker - but why it works the way it does - and why it is so critical to both the technical functionality and philosophy of Rust.\",\r\n        \"thumbnails\": {\r\n          \"default\": {\r\n            \"url\": \"https://i.ytimg.com/vi/knhpe5IUnlE/default.jpg\",\r\n            \"width\": 120,\r\n            \"height\": 90\r\n          },\r\n          \"medium\": {\r\n            \"url\": \"https://i.ytimg.com/vi/knhpe5IUnlE/mqdefault.jpg\",\r\n            \"width\": 320,\r\n            \"height\": 180\r\n          },\r\n          \"high\": {\r\n            \"url\": \"https://i.ytimg.com/vi/knhpe5IUnlE/hqdefault.jpg\",\r\n            \"width\": 480,\r\n            \"height\": 360\r\n          },\r\n          \"standard\": {\r\n            \"url\": \"https://i.ytimg.com/vi/knhpe5IUnlE/sddefault.jpg\",\r\n            \"width\": 640,\r\n            \"height\": 480\r\n          },\r\n          \"maxres\": {\r\n            \"url\": \"https://i.ytimg.com/vi/knhpe5IUnlE/maxresdefault.jpg\",\r\n            \"width\": 1280,\r\n            \"height\": 720\r\n          }\r\n        },\r\n        \"channelTitle\": \"Rust Wroc≈Çaw\",\r\n        \"playlistId\": \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\",\r\n        \"position\": 4,\r\n        \"resourceId\": {\r\n          \"kind\": \"youtube#video\",\r\n          \"videoId\": \"knhpe5IUnlE\"\r\n        }\r\n      }\r\n    }\r\n  ],\r\n  \"pageInfo\": {\r\n    \"totalResults\": 9,\r\n    \"resultsPerPage\": 5\r\n  }\r\n}\r\n```\r\n\r\nThis JSON response can be constructed from simple structs that we can define.\r\nThe `#[derive(Deserialize)]` helps `serde` understand that it can use this struct to deserialize json into by matching the fields of the struct to those of that in the JSON body.\r\n\r\n> `serde` is an amazing library and a bit too vast to explain in this post.\r\n\r\n```rust\r\n# main.rs\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct Snippet {\r\n    title: String,\r\n    position: i32,\r\n}\r\n#[derive(Debug, Deserialize)]\r\nstruct Item {\r\n    kind: String,\r\n    snippet: Snippet,\r\n}\r\n#[derive(Debug, Deserialize)]\r\nstruct YoutubeResponse {\r\n    items: Vec<Item>,\r\n}\r\n```\r\n\r\nNow that we have defined our struct lets go ahead and call the YouTube API.\r\n\r\n```rust\r\n# main.rs\r\n\r\nlet mut reply: String =\r\n    \"Sorry couldn't find the YouTube Link! :(\".to_string();\r\n\r\nif playlist_id.is_some() {\r\n    // Generate api url\r\n    let url = format!(\"https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId={}&key={}&maxResults={}\",playlist_id.unwrap(), YT_KEY, YT_MAX_RESULT);\r\n                        // Fire the API\r\n    let playlist_items = match reqwest::get(&url).await {\r\n                        // Try to convert the response to our struct\r\n        Ok(response) => match response.json::<YoutubeResponse>().await {\r\n            // Return the array of Item\r\n            Ok(yt_response) => Some(yt_response.items),\r\n            Err(e) => {\r\n                error!(\r\n                    \"Couldn't parse playlist response for comment {} reason : {}\",\r\n                        &message.data.name, e\r\n                            );\r\n                None\r\n            }\r\n        },\r\n        Err(e) => {\r\n            error!(\r\n                \"Couldn't fetch YouTube data for comment {} reason : {}\",\r\n                &message.data.name, e\r\n            );\r\n            None\r\n        }\r\n    };\r\n    //Loop over each item and then create the message.\r\n    if playlist_items.is_some() {\r\n        let items = playlist_items.unwrap();\r\n        if items.len() > 0 {\r\n            reply = \"Playlist Items: \\n\".to_string();\r\n            for item in items {\r\n                reply.push_str(\r\n                    format!(\"\\n {} \\n\", item.snippet.title).as_str(),\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWe first define `reply` with the string that we want to respond with if we fail to identify the playlist id.\r\nIf we have a playlistID we then call YouTube API with the key we generated earlier. We then extract the items of the playlist generated our reply text. The code that we have written in the previous part already handles replying to the message.\r\nLets try it out!\r\n\r\n```shell\r\n(base) DeltaManiac @ ~/git/rust/vyom\r\n‚îî‚îÄ $ cargo run\r\n   Compiling vyom v0.1.0\r\n    Finished dev [unoptimized + debuginfo] target(s) in 5.79s\r\n     Running `target/debug/vyom`\r\n[2020-08-11T18:46:46Z INFO  vyom] Replied to t1_g14nya9\r\n[2020-08-11T18:46:46Z INFO  vyom] Marked t1_g14nya9 as read\r\n```\r\n\r\nAnd on Reddit it looks just as beautiful!\r\n![](/assets/images/2020-10-11-18-30-04.png)\r\n\r\n# Fin\r\n\r\nThanks for joining along while we built our first bot :heart:.\r\nIf this journey has taught you something, feel free to give a shout out!\r\n","url":"https://deltamaniac.github.io/notes\\ecfd8eb4-cdb2-459a-ab1e-8ced6abd9498.html","relUrl":"notes\\ecfd8eb4-cdb2-459a-ab1e-8ced6abd9498.html"},{"doc":"Python","title":"Python","hpath":"python","content":"\n# DailyByte\n\n[[dailybyte.d1#python]]\n\n[[dailybyte.d2#python]]\n\n[[dailybyte.d3#python]]\n\n[[dailybyte.d4#python]]\n\n[[dailybyte.d5#python]]\n\n[[dailybyte.d6#python]]\n\n[[dailybyte.d7#python]]\n\n[[dailybyte.d8#python]]\n\n[[dailybyte.d9#python]]\n\n[[dailybyte.d10#python]]\n\n[[dailybyte.d11#python]]\n\n[[dailybyte.d12#python]]\n\n[[dailybyte.d13#python]]\n\n[[dailybyte.d14#python]]\n\n[[dailybyte.d15#python]]\n\n[[dailybyte.d16#python]]\n\n[[dailybyte.d17#python]]\n\n[[dailybyte.d18#python]]\n\n[[dailybyte.d19#python]]\n\n[[dailybyte.d20#python]]\n\n[[dailybyte.d21#python]]\n\n[[dailybyte.d22#python]]\n\n[[dailybyte.d23#python]]\n\n[[dailybyte.d24#python]]\n\n[[dailybyte.d25#python]]\n\n[[dailybyte.d26#python]]\n\n[[dailybyte.d27#python]]","url":"https://deltamaniac.github.io/notes\\TloiYhmlCN5QxTpf.html","relUrl":"notes\\TloiYhmlCN5QxTpf.html"},{"doc":"Primer","title":"Primer","hpath":"python.primer","content":"\nInterpreted Language\n\nObject Oriented\n\n## Built Ins\n\n| Class     | Desc                                 | Immutable |\n|-----------|--------------------------------------|-----------|\n| bool      | boolean value                        | True      |\n| int       | integer (arbitrary magnitude)        | True      |\n| float     | floating-point number                | True      |\n| list      | mutable sequence of objects          | False     |\n| tuple     | immutable sequence of objects        | True      |\n| str       | character string                     | True      |\n| set       | unordered set of distinct objects    | False     |\n| frozenset | immutable form of set class          | True      |\n| dict      | associative mapping (aka dictionary) | False     |\n\n## Bool\n\nNumbers evaluate to False if 0\n\nSequences Strings Lists Dicts to False if empty\n\n## int\n\nThe `int()` constructor returns 0 by default\n\nint(3.14) -> 3\n\nint(-123.3) -> -123\n\nint('5442') -> 5442 : Automatic handling of `atoi`\n\nint('lol')  -> ValueError\n\nint('7f',16) -> 127 ->int(strval,base)\n\n## float\n\nfixed-precision representation\n\nSimilar to Double in cpp\n\nThe `float()` constructor returns 0 by default\n\nfloat(2) -> 2.0\n\nfloat('3.14') -> 3.14\n\nfloat('meh') -> ValueError\n\n## Sequence Types\n\n- **list** -> array\n- **tuple** -> immutable list\n- **str** -> immutable sequence of char\n\n### list\n\n- Stores sequence of objects\n- Referential Structure -> stores sequence of references to its elements\n- zero-indexed\n\nThe `list()` constructor produces empty list [ ] by default\n\nThe `list()` constructor will accept any parameter that is of **iterable** type\n\nlist('hello') -> [h,e,l,l,o]\n\n## set and frozenset\n\n- unordered collection of elements without duplicate\n- optimized to check existence of elements -> hashtable\n- accepts only immutable types\n\nThe `set()` constructor produces an empty set\n\nset('hello') -> { h,e,l,o}\n\n## dicts\n\nmapping of distinct keys to associated values\n\n## Operator precedence\n\n| Type                                                   | Symbol                                                                |\n|--------------------------------------------------------|-----------------------------------------------------------------------|\n| member access                                          | expr.member                                                           |\n| function/method calls <br> container subscripts/slices | expr(...) <br> expr[...]                                              |\n| exponentiation                                         | **                                                                    |\n| unary operators                                        | +expr, ‚àíexpr,  ~expr                                              |\n| multiplication, division                               | *, /, //, %                                                           |\n| addition, subtraction                                  | +, ‚àí                                                                  |\n| bitwise shifting                                       | <<, >>                                                                |\n| bitwise-and                                            | &                                                                     |\n| bitwise-xor                                            | ÀÜ                                                                     |\n| bitwise-or                                             | \\|                                                                    |\n| comparisons <br>  containment                          | **is**, **is** **not**, ==, !=, <, <=, >, >= <br> **in**,** not in ** |\n| logical-not                                            | **not** expr                                                          |\n| logical-and                                            | **and**                                                               |\n| logical-or                                             | **or**                                                                |\n| conditional                                            | val1 **if** cond **else** val2                                        |\n| assignments                                            | =, +=, ‚àí=, =, etc                                                     |\n\n## Built-In Functions\n\n| Call Syntax               | Description                                                                                                               |\n|---------------------------|---------------------------------------------------------------------------------------------------------------------------|\n| abs(x)                    | Return the absolute value of a number.                                                                                    |\n| all(iterable)             | Return True if bool(e) is True for each element e.                                                                        |\n| any(iterable)             | Return True if bool(e) is True for at least one element e.                                                                |\n| chr(integer)              | Return a one-character string with the given Unicode code point.                                                          |\n| divmod(x, y)              | Return (x // y, x % y) as tuple, if x and y are integers.                                                                 |\n| hash(obj)                 | Return an integer hash value for the object (see Chapter 10).                                                             |\n| id(obj)                   | Return the unique integer serving as an ‚Äúidentity‚Äù for the object.                                                        |\n| input(prompt)             | Return a string from standard input; the prompt is optional.                                                              |\n| isinstance(obj, cls)      | Determine if obj is an instance of the class (or a subclass).                                                             |\n| iter(iterable)            | Return a new iterator object for the parameter (see Section 1.8).                                                         |\n| len(iterable)             | Return the number of elements in the given iteration.                                                                     |\n| map(f, iter1, iter2, ...) | Return an iterator yielding the result of function calls f(e1, e2, ...) for respective elements e1 ‚ààiter1, e2 ‚ààiter2, ... |\n| max(iterable)             | Return the largest element of the given iteration.                                                                        |\n| max(a, b, c, ...)         | Return the largest of the arguments.                                                                                      |\n| min(iterable)             | Return the smallest element of the given iteration.                                                                       |\n| min(a, b, c, ...)         | Return the smallest of the arguments.                                                                                     |\n| next(iterator)            | Return the next element reported by the iterator (see Section 1.8).                                                       |\n| open(filename, mode)      | Open a file with the given name and access mode.                                                                          |\n| ord(char)                 | Return the Unicode code point of the given character.                                                                     |\n| pow(x, y)                 | Return the value xy (as an integer if x and y are integers);<br> equivalent to x**y.                                      |\n| pow(x, y, z)              | Return the value (xy mod z) as an integer.                                                                                |\n| print(obj1, obj2, ...)    | Print the arguments, with separating spaces and trailing newline.                                                         |\n| range(stop)               | Construct an iteration of values 0, 1, . . . ,  stop ‚àí1.                                                                  |\n| range(start, stop)        | Construct an iteration of values start, start + 1, . . . ,  stop ‚àí1.                                                      |\n| range(start, stop, step)  | Construct an iteration of values start, start + step, start + 2 step, . . .                                               |\n| reversed(sequence)        | Return an iteration of the sequence in reverse.                                                                           |\n| round(x)                  | Return the nearest int value (a tie is broken toward the even value).                                                     |\n| round(x, k)               | Return the value rounded to the nearest 10‚àík (return-type matches x).                                                     |\n| sorted(iterable)          | Return a list containing elements of the iterable in sorted order.                                                        |\n| sum(iterable)             | Return the sum of the elements in the iterable (must be numeric).                                                         |\n| type(obj)                 | Return the class to which the instance obj belongs.                                                                       |","url":"https://deltamaniac.github.io/notes\\meI0rYvk2iMNTkSQ.html","relUrl":"notes\\meI0rYvk2iMNTkSQ.html"},{"doc":"Object Oriented Programming","title":"Object Oriented Programming","hpath":"python.oop","content":"\n# Classes\n\n## Sample\n\n```python\nclass CreditCard:\n \"\"\" A CC for consumer \"\"\"\n    def __init__(self,customer,bank,acn,limit):\n        self._customer = customer\n        self._bank = bank\n        self._account = acn\n        self._limit = limit\n\n    def get_customer(self):\n        return self._customer\n\n    def make_payment(self,amount):\n        self.account -= amount\n```\n\n## Special Methods\n\n\n| Syntax                                  | Special Method                                                    |\n|-----------------------------------------|-------------------------------------------------------------------|\n| a + b                                   | a.\\__add\\\\__(b) or b.\\__radd\\\\__(a)                               |\n| a - b                                   | a.\\__sub\\\\__(b) or b.\\__rsub\\__(a)                                |\n| a * b                                   | a.\\__mul\\__(b) or b.\\__rmul\\__(a)                                 |\n| a / b                                   | a.\\__truediv\\__(b) or b.\\__rtruediv\\__(a)                         |\n| a // b                                  | a.\\__floordiv\\__(b) or b.\\__rfloordiv\\__(a)                       |\n| a % b                                   | a.\\__mod\\__(b) or b.\\__rmod\\__(a)                                 |\n| a ** b                                  | a.\\__pow\\__(b) or b.\\__rpow\\__(a)                                 |\n| a << b                                  | a.\\__lshift\\__(b) or b.\\__rlshift\\__(a)                           |\n| a >> b                                  | a.\\__rshift\\__(b) or b.\\__rrshift\\__(a)                           |\n| a & b                                   | a.\\__and\\__(b) or b.\\__rand\\__(a)                                 |\n| a ^ b                                   | a.\\__xor\\__(b) or b.\\__rxor\\__(a)                                 |\n| a \\| b                                  | a.\\__or\\__(b) or b.\\__ror\\__(a)                                   |\n| a += b <br> a -= b <br> a *= b <br> ... | a.\\__iadd\\__(b) <br> a.\\__isub\\__(b) <br> a.\\__imul\\__(b)<br> ... |\n| +a                                      | a.\\__pos\\__()                                                     |\n| -a                                      | a.\\__neg\\__()                                                     |\n| ~a                                      | a.\\__invert\\__()                                                  |\n| abs(a)                                  | a.\\__abs\\__()                                                     |\n| a < b                                   | a.\\__lt\\__(b)                                                     |\n| a <= b                                  | a.\\__le\\__(b)                                                     |\n| a > b                                   | a.\\__gt\\__(b)                                                     |\n| a >= b                                  | a.\\__ge\\__(b)                                                     |\n| a == b                                  | a.\\__eq\\__(b)                                                     |\n| a != b                                  | a.\\__ne\\__(b)                                                     |\n| v in a                                  | a.\\__contains\\__(v)                                               |\n| a[k]                                    | a.\\__getitem\\__(k)                                                |\n| a[k]=v                                  | a.\\__setitem\\__(k,v)                                              |\n| del a[k]                                | a.\\__delitem\\__(k)                                                |\n| a(arg1, arg2)                           | a.\\__call\\__(arg1,arg2)                                           |\n| len(a)                                  | a.\\__len\\__()                                                     |\n| hash(a)                                 | a.\\__hash\\__()                                                    |\n| iter(a)                                 | a.\\__iter\\__()                                                    |\n| next(a)                                 | a.\\__next\\__()                                                    |\n| bool(a)                                 | a.\\__bool\\__()                                                    |\n| float(a)                                | a.\\__float\\__()                                                   |\n| int(a)                                  | a.\\__int\\__()                                                     |\n| repr(a)                                 | a.\\__repr\\__()                                                    |\n| reversed(a)                             | a.\\__reversed\\__()                                                |\n| str(a)                                  | a.\\__str\\__()                                                     |\n\n\n## Operator Overloading\n\n```python\nclass Vector:\n\n    def __init__(self,d):\n        self._coords = [0] * d\n\n    def __len__(self):\n        return len(self._coords)\n\n    def __getitem__(self,j):\n        return self._coords[j]\n\n    def __setitem__(self,j,val):\n        self._coords[j] = val\n\n    def __add__(self,other):\n        if len(self) != len(other):\n            raise ValurError('Dimensions must agree')\n        result = Vector(len(self))\n        for j in range(len(self)):\n            result[j] = self[j] + other[j]\n        return result\n\n    def __eq__(self,other):\n        self._coords == other._coords\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __str__(self):\n        return '<' + str(self._coords)[1:-1] +'>'\n\n```\n\n## Iterators","url":"https://deltamaniac.github.io/notes\\kcHRJQyYTr5pNXNFRiWsi.html","relUrl":"notes\\kcHRJQyYTr5pNXNFRiWsi.html"},{"doc":"Kafka","title":"Kafka","hpath":"kafka","content":"\n\r\n\r\n# Apache Kafka\r\n\r\n- pub-sub messaging system\r\n- basic unit --> message =>`{ Body :[u8], Key:[u8]}`\r\n- writes are mainly batch operations => `Vec<Messages>`\r\n- does not track acknowledgments from consumers but allows consumers to use Kafka to track their position (offset) in each partition.\r\n- Schema --> governs structure of message\r\n  - eg JSON/XML/[Apache Avro](https://avro.apache.org/docs/current/)\r\n- Topics --> collection of messages \"about something same\"\r\n- Topics made of n partitions => Append only queue-like\r\n    ![](/assets/images/2020-10-11-20-30-05.png)\r\n- Stream => Single topic of data irrespective of partitions\r\n\r\n- [[Producer|kafka.producer]]\r\n  - produce message for a topic, can sometimes specify which partition to store\r\n\r\n- [[Consumer|kafka.consumer]]\r\n  - Reads message\r\n  - Subscribes 1:n topics\r\n  - FIFO Read (Queue like)\r\n  - track of consumed messages via offset\r\n  - **Ownership** mapping of consumer to partitions\r\n- Consumer Group -> 1 or more consumers that work together to consumer a topic\r\n- Kafka Broker -> Single Kafka server\r\n  - Receives messages from Producers\r\n  - Assign offset\r\n  - Commit to disk\r\n- Kafka Cluster\r\n\r\n  - Collection of brokers\r\n  - **1** automatically elected broker will function as the cluster **controller**\r\n  - Controller responsibilities\r\n    - administrative operations\r\n    - assigning partitions to broker\r\n    - monitor for broker failures\r\n\r\n    ![](/assets/images/2020-10-11-20-31-20.png)\r\n\r\n- Retention -> Configurable for a period of time or size of topic (GB/MB)\r\n- Kafka : Pitch\r\n\r\n  - Multiple Producers x Multiple Topics\r\n  - Multiple Consumers\r\n  - Disk Based Retention --> No data loss\r\n  - Scalable\r\n  - High Performance\r\n\r\n## Starting Kafka on OSX\r\n\r\n```shell\r\n# Start ZooKeeper\r\n# `zkServer` DOESNT WORK IN TMUX!!!\r\nzookeeper-server-start /usr/local/etc/kafka/zookeeper.properties & kafka-server-start /usr/local/etc/kafka/server.properties\r\n\r\n# Start kafka server\r\nkafka-server-start.sh /usr/local/etc/kafka/server.properties\r\n\r\n# Create a topic\r\nkafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic temptopic\r\n\r\n# Start a producer to temptopic\r\nkafka-console-producer --broker-list localhost:9092 --topic temptopic\r\n\r\n# In another tab start a consumer to temptopic\r\nkafka-console-producer --broker-list localhost:9092 --topic temptopic --from-beginning\r\n```\r\n","url":"https://deltamaniac.github.io/notes\\bbb1f7dc-0a49-4a91-9578-9fff08abaaf8.html","relUrl":"notes\\bbb1f7dc-0a49-4a91-9578-9fff08abaaf8.html"},{"doc":"Producer","title":"Producer","hpath":"kafka.producer","content":"\n\r\n# Producer\r\n\r\nKafka has a binary wire protocol.This means that it is possible for applications to read messages from Kafka or write messages to Kafka simply by sending the correct byte sequences to Kafka‚Äôs network port.\r\n\r\nKey Structure is `ProducerRecord`\r\n\r\n![](/assets/images/2020-10-11-20-37-00.png)\r\n\r\n# Serializer\r\n\r\nConverts between wire format and code\r\n\r\n[Apache Avro](https://https://avro.apache.org/docs/current)\r\nDefine a common schema for serialization and deserialization\r\nStore in schema Registry\r\nStore schema identifier in produced message\r\n![](/assets/images/2020-10-11-20-37-15.png)\r\n\r\n# Creating a Producer\r\n\r\n## In [[rust]]\r\n\r\nCrate : [kafka](https://crates.io/crates/kafka)\r\n\r\n```rust\r\n// Producer Code\r\nuse std::fmt::Write;\r\nuse std::time::Duration;\r\nuse kafka::producer::{Producer, Record, RequiredAcks};\r\n\r\nlet mut producer = Producer::from_hosts(vec!(\"localhost:9092\".to_owned()))\r\n.with_ack_timeout(Duration::from_secs(1))\r\n.with_required_acks(RequiredAcks::One)\r\n.create()\r\n.unwrap();\r\n\r\nlet mut buf = String::with*capacity(2);\r\nfor i in 0..10 {\r\nlet * = write!(&mut buf, \"{}\", i); // some computation of the message data to be sent\r\nproducer.send(&Record::from_value(\"my-topic\", buf.as_bytes())).unwrap();\r\nbuf.clear();\r\n}\r\n```\r\n\r\nCrate : [rdkafka](https://crates.io/crates/rdkafka)\r\n\r\n```rust\r\n sync fn produce(brokers: &str, topic_name: &str) {\r\n    let producer: &FutureProducer = &ClientConfig::new()\r\n        .set(\"bootstrap.servers\", brokers)\r\n        .set(\"message.timeout.ms\", \"5000\")\r\n        .create()\r\n        .expect(\"Producer creation error\");\r\n\r\n    // This loop is non blocking: all messages will be sent one after the other, without waiting\r\n    // for the results.\r\n    let futures = (0..5)\r\n        .map(|i| async move {\r\n            // The send operation on the topic returns a future, which will be\r\n            // completed once the result or failure from Kafka is received.\r\n            let delivery_status = producer\r\n                .send(\r\n                    FutureRecord::to(topic_name)\r\n                        .payload(&format!(\"Message {}\", i))\r\n                        .key(&format!(\"Key {}\", i))\r\n                        .headers(OwnedHeaders::new().add(\"header_key\", \"header_value\")),\r\n                    Duration::from_secs(0),\r\n                )\r\n                .await;\r\n\r\n            // This will be executed when the result is received.\r\n            info!(\"Delivery status for message {} received\", i);\r\n            delivery_status\r\n        })\r\n        .collect::<Vec<_>>();\r\n\r\n    // This loop will wait until all delivery statuses have been received.\r\n    for future in futures {\r\n        info!(\"Future completed. Result: {:?}\", future.await);\r\n    }\r\n}\r\n\r\n```\r\n\r\nSchema Registry for confluent : https://github.com/gklijs/schema_registry_converter\r\n\r\nConfluent Write up : https://www.confluent.io/blog/getting-started-with-rust-and-kafka/\r\n\r\n---\r\n\r\n## In [[go]]\r\n\r\nPackage : [Confluent Inc](https://github.com/confluentinc/confluent-kafka-go)\r\n\r\n```golang\r\nfunc main() {\r\n\r\n\tp, err := kafka.NewProducer(&kafka.ConfigMap{\"bootstrap.servers\": \"localhost\"})\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\r\n\tdefer p.Close()\r\n\r\n\t// Delivery report handler for produced messages\r\n\tgo func() {\r\n\t\tfor e := range p.Events() {\r\n\t\t\tswitch ev := e.(type) {\r\n\t\t\tcase *kafka.Message:\r\n\t\t\t\tif ev.TopicPartition.Error != nil {\r\n\t\t\t\t\tfmt.Printf(\"Delivery failed: %v\\n\", ev.TopicPartition)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfmt.Printf(\"Delivered message to %v\\n\", ev.TopicPartition)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}()\r\n\r\n\t// Produce messages to topic (asynchronously)\r\n\ttopic := \"myTopic\"\r\n\tfor _, word := range []string{\"Welcome\", \"to\", \"the\", \"Confluent\", \"Kafka\", \"Golang\", \"client\"} {\r\n\t\tp.Produce(&kafka.Message{\r\n\t\t\tTopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},\r\n\t\t\tValue:          []byte(word),\r\n\t\t}, nil)\r\n\t}\r\n\r\n\t// Wait for message deliveries before shutting down\r\n\tp.Flush(15 * 1000)\r\n}\r\n```\r\n\r\nPackage : [SegmentIO](https://github.com/segmentio/kafka-go)\r\n\r\n```golang\r\nfunc producer() {\r\n\r\n    topic := \"my-topic\"\r\n    partition := 0\r\n\r\n    conn, _ := kafka.DialLeader(context.Background(), \"tcp\", \"localhost:9092\", topic, partition)\r\n\r\n    conn.SetWriteDeadline(time.Now().Add(10*time.Second))\r\n    conn.WriteMessages(\r\n    kafka.Message{Value: []byte(\"one!\")},\r\n    kafka.Message{Value: []byte(\"two!\")},\r\n    kafka.Message{Value: []byte(\"three!\")},\r\n    )\r\n\r\n    conn.Close()\r\n}\r\n```\r\n\r\nPackage : [Sarama](https://github.com/Shopify/sarama)\r\n\r\n```golang\r\n//Sync Producer\r\nfunc newDataCollector(brokerList []string) sarama.SyncProducer {\r\n\r\n\t// For the data collector, we are looking for strong consistency semantics.\r\n\t// Because we don't change the flush settings, sarama will try to produce messages\r\n\t// as fast as possible to keep latency low.\r\n\tconfig := sarama.NewConfig()\r\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll // Wait for all in-sync replicas to ack the message\r\n\tconfig.Producer.Retry.Max = 10                   // Retry up to 10 times to produce the message\r\n\tconfig.Producer.Return.Successes = true\r\n\ttlsConfig := createTlsConfiguration()\r\n\tif tlsConfig != nil {\r\n\t\tconfig.Net.TLS.Config = tlsConfig\r\n\t\tconfig.Net.TLS.Enable = true\r\n\t}\r\n\r\n\t// On the broker side, you may want to change the following settings to get\r\n\t// stronger consistency guarantees:\r\n\t// - For your broker, set `unclean.leader.election.enable` to false\r\n\t// - For the topic, you could increase `min.insync.replicas`.\r\n\r\n\tproducer, err := sarama.NewSyncProducer(brokerList, config)\r\n\tif err != nil {\r\n\t\tlog.Fatalln(\"Failed to start Sarama producer:\", err)\r\n\t}\r\n\r\n\treturn producer\r\n}\r\n\r\n// Async Producer\r\nfunc newAccessLogProducer(brokerList []string) sarama.AsyncProducer {\r\n\r\n\t// For the access log, we are looking for AP semantics, with high throughput.\r\n\t// By creating batches of compressed messages, we reduce network I/O at a cost of more latency.\r\n\tconfig := sarama.NewConfig()\r\n\ttlsConfig := createTlsConfiguration()\r\n\tif tlsConfig != nil {\r\n\t\tconfig.Net.TLS.Enable = true\r\n\t\tconfig.Net.TLS.Config = tlsConfig\r\n\t}\r\n\tconfig.Producer.RequiredAcks = sarama.WaitForLocal       // Only wait for the leader to ack\r\n\tconfig.Producer.Compression = sarama.CompressionSnappy   // Compress messages\r\n\tconfig.Producer.Flush.Frequency = 500 * time.Millisecond // Flush batches every 500ms\r\n\r\n\tproducer, err := sarama.NewAsyncProducer(brokerList, config)\r\n\tif err != nil {\r\n\t\tlog.Fatalln(\"Failed to start Sarama producer:\", err)\r\n\t}\r\n\r\n\t// We will just log to STDOUT if we're not able to produce messages.\r\n\t// Note: messages will only be returned here after all retry attempts are exhausted.\r\n\tgo func() {\r\n\t\tfor err := range producer.Errors() {\r\n\t\t\tlog.Println(\"Failed to write access log entry:\", err)\r\n\t\t}\r\n\t}()\r\n\r\n\treturn producer\r\n}\r\n\r\ngo func sendMessage(){\r\n        // Synch\r\n\t\tpartition, offset, err := s.DataCollector.SendMessage(&sarama.ProducerMessage{\r\n\t\t\tTopic: \"important\",\r\n\t\t\tValue: sarama.StringEncoder(r.URL.RawQuery),\r\n        })\r\n        // Async\r\n        s.AccessLogProducer.Input() <- &sarama.ProducerMessage{\r\n\t\t\tTopic: \"access_log\",\r\n\t\t\tKey:   sarama.StringEncoder(r.RemoteAddr),\r\n\t\t\tValue: entry,\r\n\t\t}\r\n}\r\n```\r\n","url":"https://deltamaniac.github.io/notes\\b7749cd1-50ef-4a06-9ff3-08fec8a8c80a.html","relUrl":"notes\\b7749cd1-50ef-4a06-9ff3-08fec8a8c80a.html"},{"doc":"Consumer","title":"Consumer","hpath":"kafka.consumer","content":"\n\r\n\r\n# Consumer\r\n\r\n- Subscribes to topics and receives message\r\n- Consumer Group -> method of scaling consumption\r\n\r\n  - Membership triggered by a `JoinGroup` call\r\n  - First member is the de-facto group leader\r\n  - leader assigns partitions to consumers in the consumer group\r\n  - Membership is maintained by sending _heartbeats_ at intervals regularly to the _group coordinator_\r\n  - Sent during `poll` and `commit`\r\n  - missing heartbeats for a period will trigger rebalance as the consumer is thought to be dead\r\n\r\n- _Rebalance_ moving partition ownership from one consumer to another\r\n  - high scalability and availability\r\n  - creates a short unavailability window\r\n\r\n![](/assets/images/2020-10-11-20-47-04.png)\r\n\r\n# Creating a Consumer\r\n\r\n## In [[Rust | rust]]\r\n\r\nCrate : [kafka](https://crates.io/crates/kafka)\r\n\r\n```rust\r\nuse kafka::consumer::{Consumer, FetchOffset, GroupOffsetStorage};\r\nlet mut consumer =\r\n   Consumer::from_hosts(vec!(\"localhost:9092\".to_owned()))\r\n      .with_topic_partitions(\"my-topic\".to_owned(), &[0, 1])\r\n      .with_fallback_offset(FetchOffset::Earliest)\r\n      .with_group(\"my-group\".to_owned())\r\n      .with_offset_storage(GroupOffsetStorage::Kafka)\r\n      .create()\r\n      .unwrap();\r\nloop {\r\n  for ms in consumer.poll().unwrap().iter() {\r\n    for m in ms.messages() {\r\n      println!(\"{:?}\", m);\r\n    }\r\n    consumer.consume_messageset(ms);\r\n  }\r\n  consumer.commit_consumed().unwrap();\r\n}\r\n```\r\n\r\nCrate : [rdkafka](https://crates.io/crates/rdkafka)\r\n\r\n```rust\r\nasync fn consume(brokers: &str, group_id: &str, topics: &[&str]) {\r\n    let context = CustomContext;\r\n\r\n    let consumer: LoggingConsumer = ClientConfig::new()\r\n        .set(\"group.id\", group_id)\r\n        .set(\"bootstrap.servers\", brokers)\r\n        .set(\"enable.partition.eof\", \"false\")\r\n        .set(\"session.timeout.ms\", \"6000\")\r\n        .set(\"enable.auto.commit\", \"true\")\r\n        //.set(\"statistics.interval.ms\", \"30000\")\r\n        //.set(\"auto.offset.reset\", \"smallest\")\r\n        .set_log_level(RDKafkaLogLevel::Debug)\r\n        .create_with_context(context)\r\n        .expect(\"Consumer creation failed\");\r\n\r\n    consumer\r\n        .subscribe(&topics.to_vec())\r\n        .expect(\"Can't subscribe to specified topics\");\r\n\r\n    // consumer.start() returns a stream. The stream can be used ot chain together expensive steps,\r\n    // such as complex computations on a thread pool or asynchronous IO.\r\n    let mut message_stream = consumer.start();\r\n\r\n    while let Some(message) = message_stream.next().await {\r\n        match message {\r\n            Err(e) => warn!(\"Kafka error: {}\", e),\r\n            Ok(m) => {\r\n                let payload = match m.payload_view::<str>() {\r\n                    None => \"\",\r\n                    Some(Ok(s)) => s,\r\n                    Some(Err(e)) => {\r\n                        warn!(\"Error while deserializing message payload: {:?}\", e);\r\n                        \"\"\r\n                    }\r\n                };\r\n                info!(\"key: '{:?}', payload: '{}', topic: {}, partition: {}, offset: {}, timestamp: {:?}\",\r\n                      m.key(), payload, m.topic(), m.partition(), m.offset(), m.timestamp());\r\n                if let Some(headers) = m.headers() {\r\n                    for i in 0..headers.count() {\r\n                        let header = headers.get(i).unwrap();\r\n                        info!(\"  Header {:#?}: {:?}\", header.0, header.1);\r\n                    }\r\n                }\r\n                consumer.commit_message(&m, CommitMode::Async).unwrap();\r\n            }\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## In [[go]]\r\n\r\nPackage : [Confluent Inc](https://github.com/confluentinc/confluent-kafka-go)\r\n\r\n```golang\r\nfunc main() {\r\n\r\n\tc, err := kafka.NewConsumer(&kafka.ConfigMap{\r\n\t\t\"bootstrap.servers\": \"localhost\",\r\n\t\t\"group.id\":          \"myGroup\",\r\n\t\t\"auto.offset.reset\": \"earliest\",\r\n\t})\r\n\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\r\n\tc.SubscribeTopics([]string{\"myTopic\", \"^aRegex.*[Tt]opic\"}, nil)\r\n\r\n\tfor {\r\n\t\tmsg, err := c.ReadMessage(-1)\r\n\t\tif err == nil {\r\n\t\t\tfmt.Printf(\"Message on %s: %s\\n\", msg.TopicPartition, string(msg.Value))\r\n\t\t} else {\r\n\t\t\t// The client will automatically try to recover from all errors.\r\n\t\t\tfmt.Printf(\"Consumer error: %v (%v)\\n\", err, msg)\r\n\t\t}\r\n\t}\r\n\r\n\tc.Close()\r\n}\r\n```\r\n\r\n## Package : [SegmentIO](https://github.com/segmentio/kafka-go)\r\n\r\n```golang\r\nfunc consumer(){\r\n  r := kafka.NewReader(kafka.ReaderConfig{\r\n      Brokers:   []string{\"localhost:9092\"},\r\n      Topic:     \"topic-A\",\r\n      Partition: 0,\r\n      MinBytes:  10e3, // 10KB\r\n      MaxBytes:  10e6, // 10MB\r\n  })\r\n  r.SetOffset(42)\r\n\r\n  for {\r\n      m, err := r.ReadMessage(context.Background())\r\n      if err != nil {\r\n          break\r\n      }\r\n      fmt.Printf(\"message at offset %d: %s = %s\\n\", m.Offset, string(m.Key), string(m.Value))\r\n  }\r\n\r\n  r.Close()\r\n}\r\n```\r\n\r\nPackage : [Sarama](https://github.com/Shopify/sarama)\r\n\r\n```golang\r\n// ConsumeClaim must start a consumer loop of ConsumerGroupClaim's Messages().\r\nfunc (consumer *Consumer) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\r\n\r\n\t// NOTE:\r\n\t// Do not move the code below to a goroutine.\r\n\t// The `ConsumeClaim` itself is called within a goroutine, see:\r\n\t// https://github.com/Shopify/sarama/blob/master/consumer_group.go#L27-L29\r\n\tfor message := range claim.Messages() {\r\n\t\tlog.Printf(\"Message claimed: value = %s, timestamp = %v, topic = %s\", string(message.Value), message.Timestamp, message.Topic)\r\n\t\tsession.MarkMessage(message, \"\")\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\ngo func() comsumer{\r\n\t\tdefer wg.Done()\r\n\t\tfor {\r\n\t\t\t// `Consume` should be called inside an infinite loop, when a\r\n\t\t\t// server-side rebalance happens, the consumer session will need to be\r\n\t\t\t// recreated to get the new claims\r\n\t\t\tif err := client.Consume(ctx, strings.Split(topics, \",\"), &consumer); err != nil {\r\n\t\t\t\tlog.Panicf(\"Error from consumer: %v\", err)\r\n\t\t\t}\r\n\t\t\t// check if context was cancelled, signaling that the consumer should stop\r\n\t\t\tif ctx.Err() != nil {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tconsumer.ready = make(chan bool)\r\n\t\t}\r\n\t}()\r\n\r\n```\r\n\r\n# Commits\r\n\r\n- Consumers use kafka to track their position in each partition\r\n- `commit` act of updating current position in kafka\r\n- message `__consumer_offsets` topic with the offset for each partition\r\n- when rebalance each consumer receives a new partition and obtains the latest committed offset from where to start reading\r\n- Commit Strategy\r\n\r\n  - Automatic\r\n\r\n    - Done by consumer every 5 seconds configurable\r\n    - Commits largest offset from `poll`\r\n    - call to `poll` will always commit the last offset\r\n    - results in double processing if `rebalance` occurs in between a 5 sec window\r\n\r\n  - Commit Current Offset\r\n\r\n    - Gives control to the developer\r\n    - `commitSync` triggers commit of the last offset returned by `poll`\r\n    - must be called after processing all messages\r\n    - Synchronous call blocks the application\r\n    - Auto retry till success of non retry-able failure\r\n\r\n  - Asynchronous Commit\r\n\r\n    - Fire and forget till we get a callback\r\n    - Does not auto retry as a later commit request might have latest Offset\r\n\r\n  - Async + Sync Commit\r\n\r\n    - `CommitAsync` always\r\n    - Trigger a CommitSync just before exit\r\n","url":"https://deltamaniac.github.io/notes\\21de6682-6669-43c0-8d66-68ceb823205d.html","relUrl":"notes\\21de6682-6669-43c0-8d66-68ceb823205d.html"},{"doc":"Go","title":"Go","hpath":"go","content":"\n# Go\n\n## Kafka\n\n[[Producer | kafka.producer]]\n\n\n[[Consumer | kafka.consumer]]\n\n# LetCode\n[[MaxDepth |  algos.trees.maxDepth#go]]\n\n\n# DailyByte\n\n[[dailybyte.d1#go]]\n\n[[dailybyte.d2#go]]\n\n[[dailybyte.d3#go]]\n\n[[dailybyte.d4#go]]\n\n[[dailybyte.d5#go]]\n\n[[dailybyte.d6#go]]\n\n[[dailybyte.d7#go]]\n\n[[dailybyte.d8#go]]\n\n[[dailybyte.d9#go]]\n\n[[dailybyte.d10#go]]\n\n[[dailybyte.d11#go]]\n\n[[dailybyte.d12#go]]\n\n[[dailybyte.d13#go]]\n\n[[dailybyte.d14#go]]\n\n[[dailybyte.d15#go]]\n\n[[dailybyte.d16#go]]\n\n[[dailybyte.d17#go]]\n\n[[dailybyte.d18#go]]\n\n[[dailybyte.d19#go]]\n\n[[dailybyte.d20#go]]\n\n[[dailybyte.d21#go]]\n\n[[dailybyte.d22#go]]\n\n[[dailybyte.d23#go]]\n\n[[dailybyte.d24#go]]\n\n[[dailybyte.d25#go]]\n\n[[dailybyte.d26#go]]\n\n[[dailybyte.d27#go]]","url":"https://deltamaniac.github.io/notes\\72f47187-278f-4a21-a56f-4abda62fea03.html","relUrl":"notes\\72f47187-278f-4a21-a56f-4abda62fea03.html"},{"doc":"Framework","title":"Framework","hpath":"go.framework","content":"\n\r\n","url":"https://deltamaniac.github.io/notes\\8e750d99-269a-4d2c-ba5d-35903d2b04c9.html","relUrl":"notes\\8e750d99-269a-4d2c-ba5d-35903d2b04c9.html"},{"doc":"Gokit","title":"Gokit","hpath":"go.framework.gokit","content":"\n\r\n\r\n# Gokit\r\n\r\nSpring boot like framework for [[go]]. It has 3 major Components\r\n\r\n## Service Layer\r\n\r\n- Innermost layer where business logic resides.\r\n- Modeled as services\r\n- Oblivious to Endpoint/Transport Layers\r\n- Can be used by multiple Transports (grpc/json/http)\r\n\r\n## Endpoint Layer\r\n\r\n- Represents a single RPC Method\r\n- Service exposed as an Endpoint\r\n- Endpoint can be exposed by multiple Transports\r\n\r\n## Transport Layer\r\n\r\n- Exposes various Transports\r\n  - grpc\r\n  - http\r\n\r\n# Building a `pastebin` clone\r\n\r\n## Define a service blueprint interface\r\n\r\n```go\r\n// PbService provides storage capabilities\r\ntype PbService interface {\r\n\tCreate(content string, ctx context.Context) (string, error)\r\n\tDelete(key string, ctx context.Context) (string, error)\r\n\tGet(key string, ctx context.Context) (string, error)\r\n}\r\n```\r\n\r\n## Make a new struct to define the PasteBin Service\r\n\r\nThis struct is used to group together the functionalities of pastebin service\r\n\r\n```go\r\ntype pbService struct {\r\n\tmemory map[uuid.UUID]string\r\n}\r\n\r\n// NewPbService make a new PbService\r\nfunc NewPbService() PbService {\r\n\treturn pbService{\r\n\t\tmemory: make(map[uuid.UUID]string),\r\n\t}\r\n}\r\n```\r\n\r\n## Implement the PbService Interface on the struct\r\n\r\nIn [[go]] we do not have a key word to define that this structs implements a specific interface like the `implements` in Java.\r\n\r\nThey way we enforce contracts is by implementing all the methods of the contract interface in our case here its the `PbService` interface.\r\n\r\nSince our `NewPbService` method returns the type of `PbService` the go compiler will ensure that `NewPbService` confirms to the `PbService` interface.\r\n\r\n```go\r\n//Create: Here we store the content and return a uuid\r\nfunc (s pbService) Create(ctx context.Context, content string) (string, error) {\r\n\tid := uuid.New()\r\n\ts.memory[id] = content\r\n\treturn id.String(), nil\r\n}\r\n\r\n//Delete: Here we use the key to find and delete the content stored\r\nfunc (s pbService) Delete(ctx context.Context, key string) (string, error) {\r\n\tid, err := uuid.Parse(key)\r\n\tif err != nil {\r\n\t\treturn \"\", errors.New(\"Invalid Uuid Format\")\r\n\t}\r\n\tdelete(s.memory, id)\r\n\treturn \"ok\", nil\r\n}\r\n\r\n//Get: Here we use the key to find and return the content stored\r\nfunc (s pbService) Get(ctx context.Context, key string) (string, error) {\r\n\tid, err := uuid.Parse(key)\r\n\tif err != nil {\r\n\t\treturn \"\", errors.New(\"Invalid Uuid Format\")\r\n\t}\r\n\tcontent, exists := s.memory[id]\r\n\tif exists {\r\n\t\treturn content, nil\r\n\t}\r\n\treturn \"\", errors.New(\"Invalid Uuid\")\r\n}\r\n```\r\n\r\n## Request and Response\r\n\r\nIn Go kit, the primary messaging pattern is RPC.\r\n\r\nSo, every method in our interface will be modeled as a remote procedure call. For each method, we define request and response structs, capturing all of the input and output parameters respectively.\r\n\r\n### Create Request Response\r\n\r\n```go\r\ntype createPbRequest struct {\r\n\tcontent string `json:\"content\"`\r\n}\r\n\r\ntype createPbResponse struct {\r\n\tkey string `json:\"key\"`\r\n\tErr string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\r\n}\r\n```\r\n\r\n### Delete Request Response\r\n\r\n```go\r\ntype deletePbRequest struct {\r\n\tkey string `json:\"key\"`\r\n}\r\n\r\ntype deletePbResponse struct {\r\n\tstatus string `json:\"status\"`\r\n\tErr    string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\r\n}\r\n```\r\n\r\n### Get Request Response\r\n\r\n```go\r\ntype getPbRequest struct {\r\n\tkey string `json:\"key\"`\r\n}\r\n\r\ntype getPbResponse struct {\r\n\tcontent string `json:\"content\"`\r\n\tErr     string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\r\n}\r\n```\r\n\r\n## Define Endpoints\r\n\r\nAn endpoint represents a single RPC, which is a single method in our service.\r\n\r\n### Create Endpoint\r\n\r\n```go\r\nfunc createPbEndpoint(svc PbService) endpoint.Endpoint {\r\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\r\n\t\treq := request.(createPbRequest)\r\n\t\tkey, err := svc.Create(ctx, req.Content)\r\n\t\tif err != nil {\r\n\t\t\treturn createPbResponse{key, err.Error()}, nil\r\n\t\t}\r\n\t\treturn createPbResponse{key, \"\"}, nil\r\n\t}\r\n}\r\n```\r\n\r\n### Delete Endpoint\r\n\r\n```go\r\nfunc deletePbEndpoint(svc PbService) endpoint.Endpoint {\r\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\r\n\t\treq := request.(deletePbRequest)\r\n\t\tstatus, err := svc.Delete(ctx, req.Key)\r\n\t\tif err != nil {\r\n\t\t\treturn deletePbResponse{status, err.Error()}, nil\r\n\t\t}\r\n\t\treturn deletePbResponse{status, \"\"}, nil\r\n\t}\r\n}\r\n```\r\n\r\n### Get Endpoint\r\n\r\n```go\r\nfunc getPbEndpoint(svc PbService) endpoint.Endpoint {\r\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\r\n\t\treq := request.(getPbRequest)\r\n\t\tcontent, err := svc.Get(ctx, req.Key)\r\n\t\tif err != nil {\r\n\t\t\treturn getPbResponse{content, err.Error()}, nil\r\n\t\t}\r\n\t\treturn getPbResponse{content, \"\"}, nil\r\n\t}\r\n}\r\n```\r\n## Define Transport\r\n\r\nSince this trivial example used JSON over HTTP we would have to decode the JSON to structs that our service can understand\r\n\r\n### Create Requester Decoder\r\n\r\n```go\r\nfunc decodeCreatePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\r\n\tvar request createPbRequest\r\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn request, nil\r\n}\r\n```\r\n\r\n### Delete Request Decoder\r\n\r\n```go\r\nfunc decodeDeletePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\r\n\tvar request deletePbRequest\r\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn request, nil\r\n}\r\n```\r\n\r\n### Get Request Decoder\r\n\r\n```go\r\nfunc decodeGetPbRequest(_ context.Context, r *http.Request) (interface{}, error) {\r\n\tvar request getPbRequest\r\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn request, nil\r\n}\r\n```\r\n### Response Encoder\r\n\r\nThis method would accept an `interface` type and convert it JSON, this allows it to accept `createPbResponse`,`deletePbResponse`,`getPbResponse` as an `interface{}` and encode it as json using the annotations in the struct definition.\r\n\r\n```go\r\nfunc encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {\r\n\treturn json.NewEncoder(w).Encode(response)\r\n}\r\n```\r\n\r\n## Main\r\n\r\n```go\r\nimport (\r\n\t\"context\"\r\n\t\"encoding/json\"\r\n\t\"errors\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/go-kit/kit/endpoint\"\r\n\t\"github.com/google/uuid\"\r\n\r\n\thttptransport \"github.com/go-kit/kit/transport/http\"\r\n)\r\n\r\nfunc main() {\r\n\tsvc := NewPbService()\r\n\tcreatePbHandler := httptransport.NewServer(\r\n\t\tcreatePbEndpoint(svc),\r\n\t\tdecodeCreatePbRequest,\r\n\t\tencodeResponse,\r\n\t)\r\n\r\n\tdeletePbHandler := httptransport.NewServer(\r\n\t\tdeletePbEndpoint(svc),\r\n\t\tdecodeDeletePbRequest,\r\n\t\tencodeResponse,\r\n\t)\r\n\r\n\tgetPbHandler := httptransport.NewServer(\r\n\t\tgetPbEndpoint(svc),\r\n\t\tdecodeGetPbRequest,\r\n\t\tencodeResponse,\r\n\t)\r\n\r\n\thttp.Handle(\"/create\", createPbHandler)\r\n\thttp.Handle(\"/delete\", deletePbHandler)\r\n\thttp.Handle(\"/get\", getPbHandler)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\r\n}\r\n```\r\n## Divide and Conquer\r\nAt this point the `main.go` has a lot of code so lets move to different files so that we have separation of concerns.\r\n\r\n### `service.go`\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"errors\"\r\n\r\n\t\"github.com/google/uuid\"\r\n)\r\n\r\n// PbService provides storage capabilities\r\ntype PbService interface {\r\n\tCreate(ctx context.Context, content string) (string, error)\r\n\tDelete(ctx context.Context, key string) (string, error)\r\n\tGet(ctx context.Context, key string) (string, error)\r\n}\r\n\r\ntype pbService struct {\r\n\tmemory map[uuid.UUID]string\r\n}\r\n\r\n// NewPbService make a new PbService\r\nfunc NewPbService() PbService {\r\n\treturn pbService{\r\n\t\tmemory: make(map[uuid.UUID]string),\r\n\t}\r\n}\r\n\r\n//Create: Here we store the content and return a uuid\r\nfunc (s pbService) Create(ctx context.Context, content string) (string, error) {\r\n\tid := uuid.New()\r\n\ts.memory[id] = content\r\n\treturn id.String(), nil\r\n}\r\n\r\n//Get: Here we use the key to find and return the content stored\r\nfunc (s pbService) Get(ctx context.Context, key string) (string, error) {\r\n\tid, err := uuid.Parse(key)\r\n\tif err != nil {\r\n\t\treturn \"\", errors.New(\"Invalid Uuid Format\")\r\n\t}\r\n\tcontent, exists := s.memory[id]\r\n\tif exists {\r\n\t\treturn content, nil\r\n\t}\r\n\treturn \"\", errors.New(\"Invalid Uuid\")\r\n}\r\n\r\n//Delete: Here we use the key to find and delete the content stored\r\nfunc (s pbService) Delete(ctx context.Context, key string) (string, error) {\r\n\tid, err := uuid.Parse(key)\r\n\tif err != nil {\r\n\t\treturn \"\", errors.New(\"Invalid Uuid Format\")\r\n\t}\r\n\tdelete(s.memory, id)\r\n\treturn \"ok\", nil\r\n}\r\n```\r\n\r\n### `transport.go`\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"encoding/json\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/go-kit/kit/endpoint\"\r\n)\r\n\r\ntype createPbRequest struct {\r\n\tContent string `json:\"content\"`\r\n}\r\n\r\ntype createPbResponse struct {\r\n\tKey string `json:\"key\"`\r\n\tErr string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\r\n}\r\n\r\ntype getPbRequest struct {\r\n\tKey string `json:\"key\"`\r\n}\r\n\r\ntype getPbResponse struct {\r\n\tContent string `json:\"content\"`\r\n\tErr     string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\r\n}\r\n\r\ntype deletePbRequest struct {\r\n\tKey string `json:\"key\"`\r\n}\r\n\r\ntype deletePbResponse struct {\r\n\tStatus string `json:\"status\"`\r\n\tErr    string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\r\n}\r\n\r\nfunc createPbEndpoint(svc PbService) endpoint.Endpoint {\r\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\r\n\t\treq := request.(createPbRequest)\r\n\t\tkey, err := svc.Create(ctx, req.Content)\r\n\t\tif err != nil {\r\n\t\t\treturn createPbResponse{key, err.Error()}, nil\r\n\t\t}\r\n\t\treturn createPbResponse{key, \"\"}, nil\r\n\t}\r\n}\r\n\r\nfunc deletePbEndpoint(svc PbService) endpoint.Endpoint {\r\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\r\n\t\treq := request.(deletePbRequest)\r\n\t\tstatus, err := svc.Delete(ctx, req.Key)\r\n\t\tif err != nil {\r\n\t\t\treturn deletePbResponse{status, err.Error()}, nil\r\n\t\t}\r\n\t\treturn deletePbResponse{status, \"\"}, nil\r\n\t}\r\n}\r\n\r\nfunc getPbEndpoint(svc PbService) endpoint.Endpoint {\r\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\r\n\t\treq := request.(getPbRequest)\r\n\t\tcontent, err := svc.Get(ctx, req.Key)\r\n\t\tif err != nil {\r\n\t\t\treturn getPbResponse{content, err.Error()}, nil\r\n\t\t}\r\n\t\treturn getPbResponse{content, \"\"}, nil\r\n\t}\r\n}\r\n\r\nfunc decodeCreatePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\r\n\tvar request createPbRequest\r\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn request, nil\r\n}\r\n\r\nfunc decodeGetPbRequest(_ context.Context, r *http.Request) (interface{}, error) {\r\n\tvar request getPbRequest\r\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn request, nil\r\n}\r\n\r\nfunc decodeDeletePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\r\n\tvar request deletePbRequest\r\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn request, nil\r\n}\r\n```\r\n\r\n### `main.go`\r\n\r\n```go\r\nfunc main() {\r\n\tsvc := NewPbService()\r\n\tcreatePbHandler := httptransport.NewServer(\r\n\t\tcreatePbEndpoint(svc),\r\n\t\tdecodeCreatePbRequest,\r\n\t\tencodeResponse,\r\n\t)\r\n\r\n\tdeletePbHandler := httptransport.NewServer(\r\n\t\tdeletePbEndpoint(svc),\r\n\t\tdecodeDeletePbRequest,\r\n\t\tencodeResponse,\r\n\t)\r\n\tgetPbHandler := httptransport.NewServer(\r\n\t\tgetPbEndpoint(svc),\r\n\t\tdecodeGetPbRequest,\r\n\t\tencodeResponse,\r\n\t)\r\n\thttp.Handle(\"/create\", createPbHandler)\r\n\thttp.Handle(\"/delete\", deletePbHandler)\r\n\thttp.Handle(\"/get\", getPbHandler)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\r\n}\r\n```\r\n## Logging Middleware\r\n\r\nAll applications need to log information, this can be enabled by adding a logging middleware that we create in a file called `logging.go`\r\n\r\nMiddleware in go-kit work on `Endpoint`\r\n\r\nThe interface definition is `type Middleware func(Endpoint) Endpoint`, which means it is a function that takes in an endpoint and returns an endpoint\r\n\r\nWe can create the `loggingMiddleware` so that it adheres to the `PbService` by implementing the `Create` `Delete` `Get` methods.\r\n```go\r\ntype loggingMiddleware struct {\r\n\tlogger log.Logger\r\n\tnext   PbService\r\n}\r\n```\r\n\r\n### Create\r\n```go\r\nfunc (m loggingMiddleware) Create(ctx context.Context, content string) (output string, err error) {\r\n\t// This defered function would be invoked just before the retuen statement\r\n\tdefer func(begin time.Time) {\r\n\t\tm.logger.Log(\r\n\t\t\t\"method\", \"CreatePb\",\r\n\t\t\t\"input\", content,\r\n\t\t\t\"output\", output,\r\n\t\t\t\"err\", err,\r\n\t\t\t\"took\", time.Since(begin),\r\n\t\t)\r\n\t}(time.Now())\r\n\toutput, err = m.next.Create(ctx, content)\r\n\treturn\r\n}\r\n```\r\n\r\n### Delete\r\n```go\r\n func (m loggingMiddleware) Delete(ctx context.Context, key string) (output string, err error) {\r\n\tdefer func(begin time.Time) {\r\n\t\tm.logger.Log(\r\n\t\t\t\"method\", \"DeletePb\",\r\n\t\t\t\"input\", key,\r\n\t\t\t\"output\", output,\r\n\t\t\t\"err\", err,\r\n\t\t\t\"took\", time.Since(begin),\r\n\t\t)\r\n\t}(time.Now())\r\n\toutput, err = m.next.Delete(ctx, key)\r\n\treturn\r\n}\r\n```\r\n\r\n### Get\r\n```go\r\nfunc (m loggingMiddleware) Get(ctx context.Context, key string) (output string, err error) {\r\n\tdefer func(begin time.Time) {\r\n\t\tm.logger.Log(\r\n\t\t\t\"method\", \"GetPb\",\r\n\t\t\t\"input\", key,\r\n\t\t\t\"output\", output,\r\n\t\t\t\"err\", err,\r\n\t\t\t\"took\", time.Since(begin),\r\n\t\t)\r\n\t}(time.Now())\r\n\toutput, err = m.next.Get(ctx, key)\r\n\treturn\r\n}\r\n```\r\n\r\n## Wiring the Middleware\r\n\r\nIn order to wire the middleware in all we have to do is link it up with the service that we have defined\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"encoding/json\"\r\n\t\"net/http\"\r\n\t\"os\"\r\n\r\n\t\"github.com/go-kit/kit/log\"\r\n\r\n\thttptransport \"github.com/go-kit/kit/transport/http\"\r\n)\r\n\r\nfunc main() {\r\n\t// Use the global logger\r\n\tlogger := log.NewLogfmtLogger(os.Stderr)\r\n\tvar svc PbService\r\n\tsvc = NewPbService()\r\n\t// Wire the middleware and thats it\r\n\tsvc = loggingMiddleware{logger, svc}\r\n\r\n\tcreatePbHandler := httptransport.NewServer(\r\n\t\tcreatePbEndpoint(svc),\r\n\t\tdecodeCreatePbRequest,\r\n\t\tencodeResponse,\r\n\t)\r\n\r\n\tdeletePbHandler := httptransport.NewServer(\r\n\t\tdeletePbEndpoint(svc),\r\n\t\tdecodeDeletePbRequest,\r\n\t\tencodeResponse,\r\n\t)\r\n\r\n\tgetPbHandler := httptransport.NewServer(\r\n\t\tgetPbEndpoint(svc),\r\n\t\tdecodeGetPbRequest,\r\n\t\tencodeResponse,\r\n\t)\r\n\thttp.Handle(\"/create\", createPbHandler)\r\n\thttp.Handle(\"/delete\", deletePbHandler)\r\n\thttp.Handle(\"/get\", getPbHandler)\r\n\tlogger.Log(\"msg\", \"HTTP\", \"addr\", \":8080\")\r\n\tlogger.Log(\"err\", http.ListenAndServe(\":8080\", nil))\r\n}\r\n\r\nfunc encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {\r\n\treturn json.NewEncoder(w).Encode(response)\r\n}\r\n```\r\n\r\n## PasteBin\r\n### Client\r\n```sh\r\n\r\n$ curl localhost:8080/create -XPOST -d '{\"content\":\"THIS IS SPARTA\"}'\r\n\r\n{\"key\":\"c449250a-d74c-4d23-acbb-6785b0bd822a\"}\r\n\r\n$ curl localhost:8080/get -XPOST -d '{\"key\":\"c449250a-d74c-4d23-acbb-6785b0bd822a\"}'\r\n\r\n{\"content\":\"THIS IS SPARTA\"}\r\n\r\n$ curl localhost:8I00/delete -XPOST -d '{\"key\":\"c449250a-d74c-4d23-acbb-6785b0bd822a\"}'\r\n\r\n{\"status\":\"ok\"}\r\n\r\n$ curl localhost:8080/get -XPOST -d '{\"key\":\"c449250a-d74c-4d23-acbb-6785b0bd822a\"}'\r\n\r\n{\"content\":\"\",\"err\":\"Invalid Uuid\"}\r\n\r\n```\r\n\r\n### Server\r\n```sh\r\n$ ./pastebin-II\r\n\r\nmsg=HTTP addr=:8080\r\n\r\nmethod=CreatePb input=\"THIS IS SPARTA\" output=c449250a-d74c-4d23-acbb-6785b0bd822a err=null took=67.92¬µs\r\n\r\nmethod=GetPb input=c449250a-d74c-4d23-acbb-6785b0bd822a output=\"THIS IS SPARTA\" err=null took=1.675¬µs\r\n\r\nmethod=DeletePb input=c449250a-d74c-4d23-acbb-6785b0bd822a output=ok err=null took=1.45¬µs\r\n\r\nmethod=GetPb input=c449250a-d74c-4d23-acbb-6785b0bd822a output= err=\"Invalid Uuid\" took=803ns\r\n```\r\n","url":"https://deltamaniac.github.io/notes\\8f8f58c7-8ffc-4b8b-98e9-c4e8eb563e70.html","relUrl":"notes\\8f8f58c7-8ffc-4b8b-98e9-c4e8eb563e70.html"},{"doc":"Games","title":"Games","hpath":"games","content":"\n\r\n","url":"https://deltamaniac.github.io/notes\\7f7613d7-a18e-4c9f-aac2-59a0c98561c3.html","relUrl":"notes\\7f7613d7-a18e-4c9f-aac2-59a0c98561c3.html"},{"doc":"Tis-100","title":"Tis-100","hpath":"games.tis-100","content":"\n\r\n","url":"https://deltamaniac.github.io/notes\\5c421f85-a4d9-4581-9b82-e1aebfb60420.html","relUrl":"notes\\5c421f85-a4d9-4581-9b82-e1aebfb60420.html"},{"doc":"Segment","title":"Segment","hpath":"games.tis-100.segment","content":"\n\r\n","url":"https://deltamaniac.github.io/notes\\773dd5dc-f267-4a01-bb29-e433bcabca8c.html","relUrl":"notes\\773dd5dc-f267-4a01-bb29-e433bcabca8c.html"},{"doc":"31904","title":"31904","hpath":"games.tis-100.segment.31904","content":"\n\r\n# Sequence Counter\r\n\r\n# Solution\r\n\r\n```\r\n@0\r\n\r\n\r\n@1\r\nMOV UP ACC\r\nMOV ACC RIGHT\r\nMOV ACC DOWN\r\n\r\n@2\r\nSTART:\r\nMOV LEFT ACC\r\nJNZ ADD\r\nJMP TERMINATE\r\nADD:\r\nSWP\r\nADD 1\r\nSAV\r\nJMP START\r\nTERMINATE:\r\nSWP\r\nMOV ACC DOWN\r\nMOV 0 ACC\r\n\r\n@3\r\nMOV RIGHT ACC\r\nMOV ACC RIGHT\r\n\r\n@4\r\nSTART:\r\nMOV UP ACC\r\nJNZ ADD\r\nJMP TERMINATE\r\nADD:\r\nMOV ACC LEFT\r\nSWP\r\nADD LEFT\r\nSAV\r\nJMP START\r\nTERMINATE:\r\nSWP\r\nMOV ACC DOWN\r\nMOV 0 ACC\r\n\r\n@5\r\nMOV UP DOWN\r\n\r\n@6\r\n\r\n\r\n@7\r\n\r\n\r\n@8\r\nMOV UP DOWN\r\n\r\n@9\r\nMOV UP DOWN\r\n\r\n@10\r\n\r\n```\r\n\r\n# Solution\r\n\r\n![](/assets/images/2020-12-26-13-50-24.png)\n","url":"https://deltamaniac.github.io/notes\\de4f35ff-985c-40fb-af0c-5c8440a6b73b.html","relUrl":"notes\\de4f35ff-985c-40fb-af0c-5c8440a6b73b.html"},{"doc":"30647","title":"30647","hpath":"games.tis-100.segment.30647","content":"\n# Sequence Generator\n\n# Solution\n\n```\n@0\n\n\n@1\nMOV UP, ACC\nMOV ACC,RIGHT\nMOV ACC,DOWN\n\n@2\nMOV UP,ACC\nSAV\nSUB LEFT\nMOV ACC,DOWN\nSWP\nMOV ACC DOWN\n\n@3\n\n\n@4\n\n\n@5\nMOV UP,RIGHT\n\n@6\nSTART:\nMOV UP,ACC\nJLZ ACCEPT_TOP\n\nACCEPT_LEFT:\nMOV LEFT,DOWN\nMOV UP,DOWN\nJMP START\n\nACCEPT_TOP:\nMOV UP,DOWN\nMOV LEFT,DOWN\nJMP START\n\n@7\n\n\n@8\n\n\n@9\nMOV -2,ACC\nSTART:\nJEZ RESET\nMOV UP,DOWN\nADD 1\nJMP START\n\nRESET:\nMOV 0,DOWN\nMOV -2,ACC\nJMP START\n\n@10\n\n```\n\n# Solution\n\n![](/assets/images/2020-11-05-21-29-23.png)\n","url":"https://deltamaniac.github.io/notes\\c6de8a46-6510-46dd-a8fd-9eac3b993fb3.html","relUrl":"notes\\c6de8a46-6510-46dd-a8fd-9eac3b993fb3.html"},{"doc":"22280","title":"22280","hpath":"games.tis-100.segment.22280","content":"\n# Signal Multiplexer\n\n# Solution\n\n```\n@0\n\n\n@1\nMOV UP,DOWN\n\n@2\nMOV UP,DOWN\n\n@3\nMOV UP,DOWN\n\n@4\n\n\n@5\nMOV UP,RIGHT\n\n@6\nSTART:\nMOV UP,ACC\nJEZ READ_BOTH\nJGZ READ_RIGHT\nMOV RIGHT,ACC\nMOV LEFT,DOWN\nJMP START\nREAD_RIGHT:\nMOV LEFT,ACC\nMOV RIGHT,DOWN\nJMP START\nREAD_BOTH:\nMOV RIGHT,ACC\nADD LEFT\nMOV ACC,DOWN\n\n@7\nMOV UP,LEFT\n\n@8\n\n\n@9\nMOV UP,DOWN\n\n@10\n\n```\n\n# Solution\n![](/assets/images/2020-11-05-21-27-40.png)\n","url":"https://deltamaniac.github.io/notes\\18792729-fd0e-457a-bb67-fd1cd7e1dcfc.html","relUrl":"notes\\18792729-fd0e-457a-bb67-fd1cd7e1dcfc.html"},{"doc":"21340","title":"21340","hpath":"games.tis-100.segment.21340","content":"\n# Signal Comparator\n\n# Solution\n\n```\n@0\nMOV UP,DOWN\n\n@1\n\n\n@2\n\n\n@3\n\n\n@4\nMOV UP,DOWN\n\n@5\nMOV UP,RIGHT\n\n@6\nSTART:\nMOV LEFT,ACC\nJGZ WRITE1\nMOV ACC,RIGHT\nMOV 0,DOWN\nJMP START\n\n\nWRITE1:\nMOV ACC,RIGHT\nMOV 1,DOWN\nJMP START\n\n@7\nSTART:\nMOV LEFT,ACC\nJEZ WRITE1\nMOV ACC,RIGHT\nMOV 0,DOWN\nJMP START\n\n\nWRITE1:\nMOV ACC,RIGHT\nMOV 1,DOWN\nJMP START\n\n@8\nSTART:\nMOV LEFT,ACC\nJLZ WRITE1\nMOV 0,DOWN\nJMP START\n\n\nWRITE1:\nMOV 1,DOWN\nJMP START\n```\n\n# Solution\n\n![](/assets/images/2020-11-05-21-23-20.png)\n","url":"https://deltamaniac.github.io/notes\\54c5c95f-6a43-444d-bca9-55842b793a8a.html","relUrl":"notes\\54c5c95f-6a43-444d-bca9-55842b793a8a.html"},{"doc":"20176","title":"20176","hpath":"games.tis-100.segment.20176","content":"\n\r\n# Differential Converter\r\n\r\n# Solution\r\n\r\n```\r\n@0\r\n\r\n\r\n@1\r\nMOV UP,ACC\r\nMOV ACC,RIGHT\r\nSUB RIGHT\r\nMOV ACC,DOWN\r\n\r\n@2\r\nMOV UP,ACC\r\nSAV\r\nSUB LEFT\r\nMOV ACC,DOWN\r\nSWP\r\nMOV ACC,LEFT\r\n\r\n@3\r\n\r\n\r\n@4\r\n\r\n\r\n@5\r\nMOV UP,DOWN\r\n\r\n@6\r\nMOV UP,DOWN\r\n\r\n@7\r\n\r\n\r\n@8\r\nMOV UP,DOWN\r\n\r\n@9\r\nMOV UP,DOWN\r\n\r\n@10\r\n\r\n```\r\n\r\n# Solution\r\n\r\n![](/assets/images/2020-10-25-21-46-37.png)\n","url":"https://deltamaniac.github.io/notes\\c2e71c4f-5214-4c80-a678-4e2f1cde11ad.html","relUrl":"notes\\c2e71c4f-5214-4c80-a678-4e2f1cde11ad.html"},{"doc":"10981","title":"10981","hpath":"games.tis-100.segment.10981","content":"\n\r\n# Signal Amplifier\r\n\r\n# Solution\r\n\r\n```\r\n@0\r\n\r\n\r\n@1\r\nMOV UP,DOWN\r\n\r\n@2\r\n\r\n\r\n@3\r\n\r\n\r\n@4\r\nMOV UP,DOWN\r\n\r\n@5\r\n\r\n\r\n@6\r\n\r\n\r\n@7\r\nMOV UP,RIGHT\r\n\r\n@8\r\nMOV LEFT,ACC\r\nADD ACC\r\nMOV ACC,DOWN\r\n\r\n@9\r\n```\r\n\r\n# Solution\r\n![](/assets/images/2020-10-25-21-46-17.png)\n","url":"https://deltamaniac.github.io/notes\\70899221-a056-4a90-bd18-eb70f749b27b.html","relUrl":"notes\\70899221-a056-4a90-bd18-eb70f749b27b.html"},{"doc":"00150","title":"00150","hpath":"games.tis-100.segment.00150","content":"\n\r\n# Self-Test Diagnostic\r\n\r\n# Solution\r\n\r\n```\r\n@0\r\nMOV UP,DOWN\r\n\r\n@1\r\nMOV RIGHT, DOWN\r\n\r\n@2\r\nMOV UP,LEFT\r\n\r\n@3\r\nMOV UP, DOWN\r\n\r\n@4\r\nMOV UP,DOWN\r\n\r\n@5\r\nMOV UP, DOWN\r\n\r\n@6\r\nMOV UP,RIGHT\r\n\r\n@7\r\nMOV LEFT,DOWN\r\n```\r\n\r\n# Solution\r\n\r\n![](/assets/images/2020-10-25-21-45-52.png)\n","url":"https://deltamaniac.github.io/notes\\2f9f6f35-8e0d-4016-b62b-8c76b7710d46.html","relUrl":"notes\\2f9f6f35-8e0d-4016-b62b-8c76b7710d46.html"},{"doc":"Destiny","title":"Destiny","hpath":"games.destiny","content":"\n\r\n","url":"https://deltamaniac.github.io/notes\\317f9bc7-7931-429b-9fa9-1737534e8a1a.html","relUrl":"notes\\317f9bc7-7931-429b-9fa9-1737534e8a1a.html"},{"doc":"Gamerdungeon","title":"Gamerdungeon","hpath":"games.destiny.gamerdungeon","content":"\n\r\n","url":"https://deltamaniac.github.io/notes\\022f0d91-14d1-4ee7-904b-18f474b84c49.html","relUrl":"notes\\022f0d91-14d1-4ee7-904b-18f474b84c49.html"},{"doc":"Lore","title":"Lore","hpath":"games.destiny.gamerdungeon.lore","content":"\n\r\n","url":"https://deltamaniac.github.io/notes\\aac395c2-48dc-4c24-afb8-310bb7757e54.html","relUrl":"notes\\aac395c2-48dc-4c24-afb8-310bb7757e54.html"},{"doc":"Zek","title":"Zek","hpath":"games.destiny.gamerdungeon.lore.zek","content":"\n\r\n++ The Archives of T√ù-√π√º√± ++\r\nCodex Entry : ¬ß585--1874¬ß\r\nTitle : [ERR-7634]...Zek Tras Resnaz\r\nContent:\r\n\r\n    Knowledge, absolutely sure of its infallibility, is faith\r\n\r\nWarlocks are the scholars of our world. They spend great many ages pursuing the knowledge that makes them whole. Zek Tras Resnaz was one such warlock, and her poison was the infamous black armoury papers. To Zek they meant more than just knowledge, she thought it was meant to lead the way to the most powerful weapons in the universe.. to protect humanity. To her this meant the tireless pursuit of using the great forges of old to forge weapon after weapon in order to find the perfect weapon with which she could protect herself. Just like any other warlock, she was had contempt for the titans and the hunters around her. Titans those buffoons who only care about punching things and those hunters who just didn't care about any higher purpose other than themselves. She always wondered why did Ikora even listen to Zavala, he was not fit to be the leader of the vanguard, the man didn't even know anything about the history of the golden age or even talked to Ada-1.\r\n...\r\n[ERR-7634]\r\n...\r\nSiviks was her nemesis as he was the one who used the great forge of Gofannon and tainted it. This was heresy and Siviks and his Kell's Scourge would have to pay the price. She knew that he was here on earth, and had defiled the greatest vault of the black armory and stole its content. She quickly guided here fireteam of lesser gaurdians to the vault, but she was too late. Sivik's had mocked her again and fled.. however this made her resolve absolute, **Siviks Must Die, I shall be the bane of Kells Scourge**\r\n...\r\n[ERR-7634]\r\n[ERR-9532]\r\n[ERR-0001]\r\n.... Aborting archive reconstruction.. too many errors to continue grammar reconstruction.\n","url":"https://deltamaniac.github.io/notes\\81183eb8-e34d-4588-aff1-bd8592e91791.html","relUrl":"notes\\81183eb8-e34d-4588-aff1-bd8592e91791.html"},{"doc":"Swift","title":"Swift","hpath":"games.destiny.gamerdungeon.lore.swift","content":"\n\r\n","url":"https://deltamaniac.github.io/notes\\ea93896f-e8c2-49c3-a90f-5ebe71795a75.html","relUrl":"notes\\ea93896f-e8c2-49c3-a90f-5ebe71795a75.html"},{"doc":"Lucan","title":"Lucan","hpath":"games.destiny.gamerdungeon.lore.lucan","content":"\n","url":"https://deltamaniac.github.io/notes\\2bfcbd54-a3b5-40dc-9192-4f7607233d13.html","relUrl":"notes\\2bfcbd54-a3b5-40dc-9192-4f7607233d13.html"},{"doc":"Chimi","title":"Chimi","hpath":"games.destiny.gamerdungeon.lore.chimi","content":"\n\r\n++ The Archives of T√ù-√π√º√± ++\r\nCodex Entry : ¬ß145--124¬ß\r\nTitle : [ERR-7634]...Chimichanga\r\nContent:\r\n\r\nWhat connects 20000 years of Genocide? Too much power in a single hand\r\n\r\n[ERR-7634]\r\nThere use be an all powerful \"Chimichanga\", powerful enough that the rivers flowed as his will decided. The flora and fauna were overwhelmed by his willpower that they could feel their very essence of soul being burnt up, their physical form fades to dust. He attained the power of such magnitude not by chance, but pure will and a cold and unwavering heart.\r\n...\r\n[ERR-7634]\r\n...\r\nIn his duel with the great protector of ≈†z≈∏-√êN√íX Saint Lucan1x he had become too overconfident in his power that he thought the Saint wouldn't be able to shoot let alone kill him if he couldn't be seen. He could just disappear from the visual spectrum of Saint and simple Solar Infused knife thrown from the back would be the first and last blow for this so called \"saint among peasants\". He infused the blade in his hand with his will and it shone red with heat and hatred, threw it at the saints back. As the knife was flying through the air the Saint started shimmering with a purple glow, the air around him rippling with energy. As the knife moved closer its pace increased and so did its weight, as was the will of it creator. Just before it could hit saints neck a purple disc appeared in its path. The knife disintegrated upon hitting it and before the knife thrower could blink he heard the shot of a long lost weapon of legend, the weapon that wielded the power of a small star, Izanagi's Burden. The next thing he felt was his soul, his will and his body splitting apart from each other. \"How had he lost ?\" was the last thought that crossed his mind before darkness enveloped him.\r\n...\r\n[ERR-7634]\r\n[ERR-9532]\r\n[ERR-0001]\r\n\r\n.... Aborting archive reconstruction.. too many errors to continue grammar reconstruction.\n","url":"https://deltamaniac.github.io/notes\\b4d422fa-d456-428e-8e48-b3d6b2a5cbcb.html","relUrl":"notes\\b4d422fa-d456-428e-8e48-b3d6b2a5cbcb.html"},{"doc":"DailyByte","title":"DailyByte","hpath":"dailybyte","content":"","url":"https://deltamaniac.github.io/notes\\mVQvTk97aKzhqLZ2.html","relUrl":"notes\\mVQvTk97aKzhqLZ2.html"},{"doc":"Moving Average","title":"Moving Average","hpath":"dailybyte.d27","content":"\n# Problem\n\nThis question is asked by Microsoft.\n\nDesign a class, MovingAverage, which contains a method, next that is responsible for returning the moving average from a stream of integers.\n\nNote: a moving average is the average of a subset of data at a given point in time.\n\nEx: Given the following series of events...\n\n> // i.e. the moving average has a capacity of 3.\n>\n> MovingAverage movingAverage = new MovingAverage(3);\n>\n> m.next(3) returns 3 because (3 / 1) = 3\n>\n> m.next(5) returns 4 because (3 + 5) / 2 = 4\n>\n> m.next(7) = returns 5 because (3 + 5 + 7) / 3 = 5\n>\n> m.next(6) = returns 6 because (5 + 7 + 6) / 3 = 6\n\n\nMovingAverage class definition:\n```\npublic class MovingAverage {\n    // TODO: declare any instance variables you require.\n\n    /**\n    * Initializes a MovingAverage with a\n    * capacity of `size`.\n    */\n    public MovingAverage(int size) {\n    // TODO: initialize your MovingAverage.\n    }\n\n    /**\n    * Adds `val` to the stream of numbers\n    * and returns the current average of the numbers.\n    */\n    public double next(int val) {\n    // TODO: implement this method.\n    }\n\n}\n```\n\n## [[python]]\n\n```python\nfrom collections import deque\n\nclass MovingAverage:\n    def __init__(self,size=3) -> None:\n        self.size = size\n        self.q = deque([],maxlen=size)\n\n    def next(self,val):\n        self.q.append(val)\n        return sum(self.q)/len(self.q)\n```\n\n## [[go]]\n\n## [[rust]]","url":"https://deltamaniac.github.io/notes\\ntUHj2XM938RWkHDS7u6j.html","relUrl":"notes\\ntUHj2XM938RWkHDS7u6j.html"},{"doc":"Stones and Jewels","title":"Stones and Jewels","hpath":"dailybyte.d9","content":"\n# Problem\n\nThis question is asked by Amazon.\n\nGiven a string representing your stones and another string representing a list of jewels, return the number of stones that you have that are also jewels.\n\nEx: Given the following jewels and stones...\n\n> jewels = \"abc\", stones = \"ac\", return 2\n>\n> jewels = \"Af\", stones = \"AaaddfFf\", return 3\n>\n> jewels = \"AYOPD\", stones = \"ayopd\", return 0\n\n## [[python]]\n\n```python\ndef is_jewel_and_stone(jewels,stones):\n    return len(set(jewels).intersection(set(stones)))\n```\n\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\aD28cj9vhLvlrp0y3mO6P.html","relUrl":"notes\\aD28cj9vhLvlrp0y3mO6P.html"},{"doc":"Two Sum","title":"Two Sum","hpath":"dailybyte.d8","content":"\n# Problem\n\nThis question is asked by Google.\n\nGiven an array of integers, return whether or not two numbers sum to a given target, k.\n\nNote: you may not sum a number with itself.\n\nEx: Given the following...\n\n> [1, 3, 8, 2], k = 10, return true (8 + 2)\n>\n> [3, 9, 13, 7], k = 8, return false\n>\n> [4, 2, 6, 5, 2], k = 4, return true (2 + 2)\n\n## [[python]]\n```python\ndef twoSum(nums: List[int], target: int) -> List[int]:\n    num_map = {}\n    for idx,x in enumerate(nums):\n        if target-x in num_map:\n            return true\n            #return[idx,num_map[target-x]]\n        else:\n            num_map[x] = idx\n\n```\n\n## [[go]]\n```go\nfunc twoSum(nums []int, target int) []int {\n    var seen  = make(map[int]int)\n    for i,v := range nums{\n        idx := target - v\n        _,exists := seen[idx]\n        if exists {\n            return true\n            //return []int{i,seen[idx]}\n        }\n        seen[v]=i\n    }\n    return[]int{}\n}\n```\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\UEoXlw6FLqsYyqXRSSw6C.html","relUrl":"notes\\UEoXlw6FLqsYyqXRSSw6C.html"},{"doc":"Is Palindrome Again ??","title":"Is Palindrome Again ??","hpath":"dailybyte.d7","content":"\n# Problem\n\nThis question is asked by Facebook.\n\nGiven a string and the ability to delete at most one character, return whether or not it can form a palindrome.\n\nNote: a palindrome is a sequence of characters that reads the same forwards and backwards.\n\nEx: Given the following strings...\n\n> \"abcba\", return true\n>\n> \"foobof\", return true (remove the first 'o', the second 'o', or 'b')\n>\n> \"abccab\", return false\n\n## [[python]]\n```python\ndef validPalindrome(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            one, two = s[left:right], s[left + 1:right + 1]\n            return one == one[::-1] or two == two[::-1]\n        left, right = left + 1, right - 1\n    return True\n```\n## [[go]]\n\n## [[rust]]\n\n","url":"https://deltamaniac.github.io/notes\\OyydTG024M8K7pkeZzgAF.html","relUrl":"notes\\OyydTG024M8K7pkeZzgAF.html"},{"doc":"Longest Common Shared Prefix","title":"Longest Common Shared Prefix","hpath":"dailybyte.d6","content":"\n# Problem\n\nThis question is asked by Microsoft.\n\nGiven an array of strings, return the longest common prefix that is shared amongst all strings.\n\nNote: you may assume all strings only contain lowercase alphabetical characters.\n\nEx: Given the following arrays...\n\n> [\"colorado\", \"color\", \"cold\"], return \"col\"\n>\n> [\"a\", \"b\", \"c\"], return \"\"\n>\n> [\"spot\", \"spotty\", \"spotted\"], return \"spot\"\n\n## [[python]]\n```python\ndef longestCommonPrefix(strs)->string:\n        sz, ret = zip(*strs), \"\"\n        for c in sz:\n            if len(set(c)) > 1: break\n            ret += c[0]\n        return ret\n```\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\diI4VBMv8iMMUStWIFnUE.html","relUrl":"notes\\diI4VBMv8iMMUStWIFnUE.html"},{"doc":"Binary Sum","title":"Binary Sum","hpath":"dailybyte.d5","content":"\n# Problem\n\nThis question is asked by Apple.\n\nGiven two binary strings (strings containing only 1s and 0s) return their sum (also as a binary string).\n\nNote: neither binary string will contain leading 0s unless the string itself is 0\n\nEx: Given the following binary strings...\n\n> \"100\" + \"1\", return \"101\"\n>\n> \"11\" + \"1\", return \"100\"\n>\n> \"1\" + \"0\", return  \"1\"\n\n\n## [[python]]\n```python\ndef add(num1:str, num2:str)->str:\n    return bin(int(num1,2)+int(num2,2))[2:]\n```\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\eN5kq8a6uewxD6Lgvlj9V.html","relUrl":"notes\\eN5kq8a6uewxD6Lgvlj9V.html"},{"doc":"Capitalized Properly ??","title":"Capitalized Properly ??","hpath":"dailybyte.d4","content":"\n# Problem\n\nThis question is asked by Google.\n\nGiven a string, return whether or not it uses capitalization correctly. A string correctly uses capitalization if all letters are capitalized, no letters are capitalized, or only the first letter is capitalized.\n\nEx: Given the following strings...\n\n> \"USA\", return true\n>\n> \"Calvin\", return true\n>\n> \"compUter\", return false\n>\n> \"coding\", return true\n\n\n## [[python]]\n```python\ndef check(word:str)->bool:\n    if word.isupper():\n        return True\n    if word.islower():\n        return True\n    if word[0].isupper() and word[1:].islower():\n        return True\n    return False\n```\n\n## [[go]]\n```go\nfunc check(word string) bool {\n\tif isUpper(word) {\n\t\treturn true\n\t}\n\tif isLower(word) {\n\t\treturn true\n\t}\n\tif isUpper(word[:1]) && isLower(word[1:]) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isUpper(word string) bool {\n\tfor _, c := range word {\n\t\tif !unicode.IsUpper(c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc isLower(word string) bool {\n\tfor _, c := range word {\n\t\tif !unicode.IsLower(c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```\n## [[rust]]\n\n","url":"https://deltamaniac.github.io/notes\\03eyZc0twc2pjdAY6FnIl.html","relUrl":"notes\\03eyZc0twc2pjdAY6FnIl.html"},{"doc":"Will It Return ??","title":"Will It Return ??","hpath":"dailybyte.d3","content":"\n# Problem\n\nThis question is asked by Amazon.\n\n Given a string representing the sequence of moves a robot vacuum makes, return whether or not it will return to its original position. The string will only contain L, R, U, and D characters, representing left, right, up, and down respectively.\n\nEx: Given the following strings...\n\n> \"LR\", return true\n>\n> \"URURD\", return false\n>\n> \"RUULLDRD\", return true\n\n## [[python]]\n```python\ndef does_it_return(word)->bool:\n    x,y = 0,0\n    for c in word:\n        if c == 'R':\n            x+=1\n        elif c == 'L':\n            x-=1\n        elif c == 'U':\n            y += 1\n        elif c == 'D':\n            y-=1\n    return x==0 and y==0\n```\n\n## [[go]]\n```go\nfunc doesitreturn(word string) bool {\n\tx := 0\n\ty := 00\n\tfor _, c := range word {\n\t\tif c == 'R' {\n\t\t\tx = x + 1\n\t\t} else if c == 'L' {\n\t\t\tx = x - 1\n\t\t} else if c == 'U' {\n\t\t\ty += 1\n\t\t} else if c == 'D' {\n\t\t\ty -= 1\n\t\t}\n\t}\n\treturn x == 0 && y == 0\n}\n```\n\n## [[rust]]\n\n```rust\nfn does_it_return(word:&str)->bool{\n    let mut x = 0;\n    let mut y = 0;\n\n    for c in word.chars() {\n        if c == 'R' {\n            x += 1;\n        } else if c == 'L' {\n            x -= 1;\n        } else if c == 'U' {\n            y += 1;\n        } else {\n            y -= 1;\n        }\n    }\n    x == 0 && y == 0\n}\n\n}\n```","url":"https://deltamaniac.github.io/notes\\eoYphw1j9uLzHmsMBWZHv.html","relUrl":"notes\\eoYphw1j9uLzHmsMBWZHv.html"},{"doc":"Call Counter","title":"Call Counter","hpath":"dailybyte.d26","content":"\n# Problem\n\nThis question is asked by Google.\n\nCreate a class `CallCounter` that tracks the number of calls a client has made within the last 3 seconds.\n\nYour class should contain one method, `ping(int t)` that receives the current timestamp (in milliseconds) of a new call being made and returns the number of calls made within the last 3 seconds.\n\nNote: you may assume that the time associated with each subsequent call to `ping` is strictly increasing.\n\nEx: Given the following calls to ping‚Ä¶\n\n>ping(1), return 1 (1 call within the last 3 seconds)\n>\n>ping(300), return 2 (2 calls within the last 3 seconds)\n>\n>ping(3000), return 3 (3 calls within the last 3 seconds)\n>\n>ping(3002), return 3 (3 calls within the last 3 seconds)\n>\n>ping(7000), return 1 (1 call within the last 3 seconds)\n\n## [[python]]\n\n```python\nclass CallCounter:\n\n    def __init__(self):\n        self.ts_dict = {}\n\n    def ping(self,timestamp):\n        if timestamp not in self.ts_dict:\n            self.ts_dict[timestamp] = 1\n        else:\n            self.ts_dict[timestamp] += 1\n        return self.getPings(timestamp)\n\n    def getPings(self,timestamp):\n        t1 = timestamp - 3000\n        tc = 0\n        for ts, c in self.ts_dict.items():\n            if ts > t1:\n                tc += c\n        return tc\n```\n## [[go]]\n\n## [[rust]]","url":"https://deltamaniac.github.io/notes\\PmgizaDsnrmKkTukqgykG.html","relUrl":"notes\\PmgizaDsnrmKkTukqgykG.html"},{"doc":"Next Greater Element","title":"Next Greater Element","hpath":"dailybyte.d25","content":"\n# Problem\n\nThis question is asked by Amazon.\n\nGiven two arrays of numbers, where the first array is a subset of the second array, return an array containing all the next greater elements for each element in the first array, in the second array. If there is no greater element for any element, output -1 for that number.\n\nEx: Given the following arrays‚Ä¶\n\n\n>nums1 = [4,1,2], nums2 = [1,3,4,2], return [-1, 3, -1] because no element in nums2 is greater than 4, 3 is the first number in nums2 greater than 1, and no element in nums2 is greater than 2.\n>\n>nums1 = [2,4], nums2 = [1,2,3,4], return [3, -1] because 3 is the first greater element that occurs in nums2 after 2 and no element is greater than 4.\n\n## [[python]]\n\n```python\ndef nextGreaterElement( nums1, nums2):\n    map = dict()\n    stk = nums2[0:1]\n\n    for num in nums2[1:]:\n        while stk and stk[-1] < num:\n            map[stk.pop()] = num\n        stk.append(num)\n    return [map.get(num, -1) for num in nums1]\n```\n\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\cAmRmCV8llN7jThulyHoH.html","relUrl":"notes\\cAmRmCV8llN7jThulyHoH.html"},{"doc":"Remove Adjacent Chars","title":"Remove Adjacent Chars","hpath":"dailybyte.d24","content":"\n# Problem\n\nThis question is asked by Facebook.\n\nGiven a string s containing only lowercase letters, continuously remove adjacent characters that are the same and return the result.\n\nEx: Given the following strings...\n\n\n>s = \"abccba\", return \"\"\n>\n>s = \"foobar\", return \"fbar\"\n>\n>s = \"abccbefggfe\", return \"a\"\n\n## [[python]]\n\n```python\ndef remove_adjacent(s1):\n    stk = []\n    for x in s1:\n        if len(stk)>0 and stk[-1] == x:\n            stk.pop()\n        else:\n            stk.append(x)\n\n    return \"\".join(stk)\n```\n\n## [[go]]\n\n## [[rust]]\n\n","url":"https://deltamaniac.github.io/notes\\8t7YNvufpspeCNGMpPBJ3.html","relUrl":"notes\\8t7YNvufpspeCNGMpPBJ3.html"},{"doc":"Compare Keystrokes","title":"Compare Keystrokes","hpath":"dailybyte.d23","content":"# Problem\n\nThis question is asked by Amazon.\n\nGiven two strings s and t, which represents a sequence of keystrokes, where # denotes a backspace, return whether or not the sequences produce the same result.\n\nEx: Given the following strings...\n\n> s = \"ABC#\", t = \"CD##AB\", return true\n>\n> s = \"como#pur#ter\", t = \"computer\", return true\n>\n> s = \"cof#dim#ng\", t = \"code\", return false\n\n\n## [[python]]\n\n```python\ndef compare_keystrokes(s1,s2) -> bool:\n    stk = []\n    stk2 = []\n    for x in s1:\n        if x == '#':\n            stk.pop()\n        else:\n            stk.append(x)\n    for x in s2:\n        if x == '#':\n            stk2.pop()\n        else:\n            stk2.append(x)\n    return stk==stk2\n```\n\n## [[go]]\n\n## [[rust]]\n\n","url":"https://deltamaniac.github.io/notes\\4mrBS2RU7D32N7wAlPABr.html","relUrl":"notes\\4mrBS2RU7D32N7wAlPABr.html"},{"doc":"Balanced Brackets","title":"Balanced Brackets","hpath":"dailybyte.d22","content":"# Problem\n\nThis question is asked by Google.\n\nGiven a string only containing the following characters `(`, `)`, `{`, `}`, `[`, and `]` return whether or not the opening and closing characters are in a valid order.\n\nEx: Given the following strings...\n\n>\"(){}[]\", return true\n>\n>\"(({[]}))\", return true\n>\n>\"{(})\", return false\n\n## [[python]]\n\n```python\ndef check_brackets(a):\n    stk = []\n    chars = { \"{\":\"}\",\"[\":\"]\",\"(\":\")\"}\n    for x in a:\n        if x in chars.keys():\n            stk.append(x)\n        if x in chars.values():\n            if x== chars.get(stk[-1]):\n                stk.pop()\n            else:\n                return False\n\n    return len(stk) == 0\n```\n\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\H8MXI19M4LJ0SbFIX5H36.html","relUrl":"notes\\H8MXI19M4LJ0SbFIX5H36.html"},{"doc":"Reverse Linked List","title":"Reverse Linked List","hpath":"dailybyte.d21","content":"\n\n# Problem\n\nThis question is asked by Facebook.\n\nGiven a linked list, containing unique values, reverse it, and return the result.\n\nEx: Given the following linked lists...\n\n>1->2->3->null, return a reference to the node that contains 3 which points to a list that looks like the following: 3->2->1->null\n>\n>7->15->9->2->null, return a reference to the node that contains 2 which points to a list that looks like the following: 2->9->15->7->null\n>\n>1->null, return a reference to the node that contains 1 which points to a list that looks like the following: 1->null\n\n## [[python]]\n\n```python\ndef reverseList(self, head: ListNode) -> ListNode:\n    prev = None\n    curr = head\n    while curr:\n        temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = temp\n    return prev\n```\n\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\Vr5yZIX8oIXKBoAxdXPfr.html","relUrl":"notes\\Vr5yZIX8oIXKBoAxdXPfr.html"},{"doc":"Where Cycle ?!","title":"Where Cycle ?!","hpath":"dailybyte.d20","content":"# Problem\n\nThis question is asked by Apple.\n\nGiven a potentially cyclical linked list where each value is unique, return the node at which the cycle starts. If the list does not contain a cycle, return null.\n\nEx: Given the following linked lists...\n\n>1->2->3, return null\n>\n>1->2->3->4->5->2 (5 points back to 2), return a reference to the node containing 2\n>\n>1->9->3->7->7 (7 points to itself), return a reference to the node containing 7\n\n## [[python]]\n\n```python\ndef whereCycle(self, head)->Node:\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            break\n    else:\n        return None\n    while head != slow:\n        slow = slow.next\n        head = head.next\n    return head\n```\n\n## [[go]]\n\n## [[rust]]\n\n","url":"https://deltamaniac.github.io/notes\\XuV0VyaWXmEV3OSOKmMTp.html","relUrl":"notes\\XuV0VyaWXmEV3OSOKmMTp.html"},{"doc":"Is Palindrome ??","title":"Is Palindrome ??","hpath":"dailybyte.d2","content":"\n\r\n# Problem\r\n\r\nThis question is asked by Facebook.\r\n\r\nGiven a string, return whether or not it forms a palindrome ignoring case and non-alphabetical characters.\r\n\r\nNote: a palindrome is a sequence of characters that reads the same forwards and backwards.\r\n\r\nEx: Given the following strings...\r\n\r\n> \"level\", return true\r\n>\r\n> \"algorithm\", return false\r\n>\r\n> \"A man, a plan, a canal: Panama.\", return true\r\n\r\n ## [[python]]\r\n\r\n```python\r\ndef is_palindrome(word)->bool:\r\n    w1 = \"\".join(list(filter(lambda x: x.isalpha(),word.lower())))\r\n    return w1==w1[::-1]\r\n```\r\n\r\n ## [[go]]\r\n\r\n```go\r\nfunc isPalindrome(word string) bool{\r\n    s := strings.ToLower(word)\r\n    i, j := 0, len(s)-1\r\n    for i < j {\r\n        if !isValid(s[i]) {\r\n            i++\r\n            continue\r\n        }\r\n        if !isValid(s[j]) {\r\n            j--\r\n            continue\r\n        }\r\n        if !strings.EqualFold(string(s[i]), string(s[j])) {\r\n            return false\r\n        }\r\n        i++\r\n        j--\r\n    }\r\n    return true\r\n}\r\n\r\nfunc isValid(a byte) bool {\r\n    if (a >= 'a' && a <= 'z') {\r\n        return true\r\n    }\r\n    return false\r\n}\r\n}\r\n```\r\n\r\n ## [[rust]]\r\n\r\n```rust\r\nfn isPalindrome(word:&str)-> bool{\r\n    extern crate unicode_segmentation;\r\n    use unicode_segmentation::UnicodeSegmentation;\r\n    word == word\r\n        .graphemes(true)\r\n        .rev()\r\n        .flat_map(|g| g.chars())\r\n        .collect::<String>()\r\n}\r\n\r\n```","url":"https://deltamaniac.github.io/notes\\8CvV1rkawfYZGgMX.html","relUrl":"notes\\8CvV1rkawfYZGgMX.html"},{"doc":"Has Cycle ?!","title":"Has Cycle ?!","hpath":"dailybyte.d19","content":"# Problem\n\nThis question is asked by Microsoft.\n\nGiven a linked list, containing unique numbers, return whether or not it has a cycle.\n\nNote: a cycle is a circular arrangement (i.e. one node points back to a previous node)\n\nEx: Given the following linked lists...\n\n>1->2->3->1 -> true (3 points back to 1)\n>\n>1->2->3 -> false\n>\n>1->1 true (1 points to itself)\n\n## [[python]]\n\n```python\ndef hasCycle(self, head: ListNode) -> bool:\n    if not head: return False\n    if head.next is None:\n        return False\n\n    ptr = head.next\n    if head.next.next is None:\n        return False\n    cur = head.next.next\n    while cur != ptr:\n        if cur is None or cur.next is None:\n            return False\n        ptr = ptr.next\n        cur = cur.next.next\n    return True\n```\n\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\7SLTuaGEjIASOWk6cOxFB.html","relUrl":"notes\\7SLTuaGEjIASOWk6cOxFB.html"},{"doc":"Middle Node of Linked List","title":"Middle Node of Linked List","hpath":"dailybyte.d18","content":"# Problem\nThis question is asked by Amazon.\n\nGiven a non-empty linked list, return the middle node of the list. If the linked list contains an even number of elements, return the node closer to the end.\n\nEx: Given the following linked lists...\n\n>1->2->3->null, return 2\n>\n>1->2->3->4->null, return 3\n>\n>1->null, return 1\n\n## [[python]]\n\n```python\ndef middleNode(self, head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    return slow\n```\n\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\XHoNtrP3cDd1zyAA0wKv7.html","relUrl":"notes\\XHoNtrP3cDd1zyAA0wKv7.html"},{"doc":"Remove All Node Containing Value","title":"Remove All Node Containing Value","hpath":"dailybyte.d17","content":"\n# Problem\n\nThis question is asked by Google.\n\nGiven a linked list and a value, remove all nodes containing the provided value, and return the resulting list.\n\nEx: Given the following linked lists and values...\n\n>1->2->3->null, value = 3, return 1->2->null\n>\n>8->1->1->4->12->null, value = 1, return 8->4->12->null\n>\n>7->12->2->9->null, value = 7, return 12->2->9->null\n\n## [[python]]\n\n```python\ndef remove_nodes(head,val)\n    while head and head.val == val:\n        head = head.next\n    if not head:\n        return head\n    prev, cur = head, head.next\n    while cur:\n        while cur and cur.val == val:\n            cur = cur.next\n        prev.next = cur\n        if cur:\n            prev, cur = prev.next, cur.next\n    return head\n```\n\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\K0VoYfbceBQ4Cl0p5VPy0.html","relUrl":"notes\\K0VoYfbceBQ4Cl0p5VPy0.html"},{"doc":"Remove nth to last node","title":"Remove nth to last node","hpath":"dailybyte.d16","content":"\n# Problem\n\nThis question is asked by Facebook.\n\nGiven a linked list and a value n, remove the nth to last node and return the resulting list.\n\nEx: Given the following linked lists...\n\n>1->2->3->null, n = 1, return 1->2->null\n>\n>1->2->3->null, n = 2, return 1->3->null\n>\n>1->2->3->null, n = 3, return 2->3->null\n\n## [[python]]\n\n```python\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n    fast = slow = head\n    for _ in range(n):\n        fast = fast.next\n    if not fast:\n        return head.next\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n    slow.next = slow.next.next\n    return head\n```\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\6ywEeMzNQG1KazrhY8KFk.html","relUrl":"notes\\6ywEeMzNQG1KazrhY8KFk.html"},{"doc":"Merge Sorted Linked Lists","title":"Merge Sorted Linked Lists","hpath":"dailybyte.d15","content":"\n# Problem\nThis question is asked by Apple.\n\nGiven two sorted linked lists, merge them together in ascending order and return a reference to the merged list\n\nEx: Given the following lists...\n\n> list1 = 1->2->3, list2 = 4->5->6->null, return 1->2->3->4->5->6->null\n>\n> list1 = 1->3->5, list2 = 2->4->6->null, return 1->2->3->4->5->6->null\n>\n> list1 = 4->4->7, list2 = 1->5->6->null, return 1->4->4->5->6->7->null\n\n## [[python]]\n\n```python\n\nclass LinkedList:\n    def __init__(self,value):\n        self.value = value\n        self.next = None\n\ndef mergeLists(h1,h2):\n    ptr1 = h1\n    ptr1_prev =None\n    ptr2 = h2\n    while ptr1 is not None and ptr2 is not None:\n        if ptr1.value < ptr2.value:\n            ptr1_prev = ptr1\n            ptr1 = ptr1.net\n        else:\n            if ptr1_prev is not None:\n                ptr1_prev.next = ptr2\n            ptr1_prev = p2\n            ptr2 = ptr2.next\n            ptr1_prev.next = ptr1\n    if ptr1 is None:\n        ptr1_prev.next = ptr2\n    return h1 if h1.value < h2.value else h2\n```\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\my4RiJMT1PiDRIDt7nKCJ.html","relUrl":"notes\\my4RiJMT1PiDRIDt7nKCJ.html"},{"doc":"String Symmetric Difference","title":"String Symmetric Difference","hpath":"dailybyte.d14","content":"\n# Problem\n\nThis question is asked by Amazon.\n\nGiven two strings representing sentences, return the words that are not common to both strings (i.e. the words that only appear in one of the sentences). You may assume that each sentence is a sequence of words (without punctuation) correctly separated using space characters.\n\nEx: given the following strings...\n\n> sentence1 = \"the quick\", sentence2 = \"brown fox\", return [\"the\", \"quick\", \"brown\", \"fox\"]\n>\n> sentence1 = \"the tortoise beat the haire\", sentence2 = \"the tortoise lost to the haire\", return [\"beat\", \"to\", \"lost\"]\n>\n> sentence1 = \"copper coffee pot\", sentence2 = \"hot coffee pot\", return [\"copper\", \"hot\"]\n\n## [[python]]\n\n```python\ndef findCommon(s1,s2):\n    def findCommon(s1,s2):\n    s = set()\n    t = set()\n    for w in s1.split():\n       s.add(w)\n    for w in s2.split():\n       t.add(w)\n    return s.symmetric_difference(t)\n```\n\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\Whvb7ZHAghpNfv3WiTZBj.html","relUrl":"notes\\Whvb7ZHAghpNfv3WiTZBj.html"},{"doc":"Intersection Of Two Arrays","title":"Intersection Of Two Arrays","hpath":"dailybyte.d13","content":"# Problem\n\nThis question is asked by Google. Given two integer arrays, return their intersection.\n\nNote: the intersection is the set of elements that are common to both arrays.\n\nEx: Given the following arrays...\n\n> nums1 = [2, 4, 4, 2], nums2 = [2, 4], return [2, 4]\n>\n> nums1 = [1, 2, 3, 3], nums2 = [3, 3], return [3]\n>\n> nums1 = [2, 4, 6, 8], nums2 = [1, 3, 5, 7], return []`\n\n## [[python]]\n```python\ndef intersection(nums1,nums2):\n    return set(nums1).intersection(set(nums2))\n```\n\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\Ca7OMVPVMEBpr8rb3Xy94.html","relUrl":"notes\\Ca7OMVPVMEBpr8rb3Xy94.html"},{"doc":"Find Randomly Added Letter","title":"Find Randomly Added Letter","hpath":"dailybyte.d12","content":"\n# Problem\n\nThis question is asked by Google.\n\nYou are given two strings, s and t which only consist of lowercase letters. t is generated by shuffling the letters in s as well as potentially adding an additional random character. Return the letter that was randomly added to t if it exists, otherwise, return ' '.\n\nNote: You may assume that at most one additional character can be added to t.\n\nEx: Given the following strings...\n\n> s = \"foobar\", t = \"barfoot\", return 't'\n>\n> s = \"ide\", t = \"idea\", return 'a'\n>\n> s = \"coding\", t \"ingcod\", return ''\n\n## [[python]]\n```python\nfrom collections import Counter\ndef findDiff(word1,word2):\n    for x in (Counter(word2)-Counter(word1)).keys():\n        return x\n    return ' '\n```\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\y4jogEsAtJALkc4Hohe63.html","relUrl":"notes\\y4jogEsAtJALkc4Hohe63.html"},{"doc":"First Unique Character Index","title":"First Unique Character Index","hpath":"dailybyte.d11","content":"\n# Problem\n\nThis question is asked by Microsoft.\n\nGiven a string, return the index of its first unique character.\nIf a unique character does not exist, return -1.\n\nEx: Given the following strings...\n\n> \"abcabd\", return 2\n>\n> \"thedailybyte\", return 1\n>\n> \"developer\", return 0\n\n## [[python]]\n```python\ndef first_unique_char(s):\n    for i,j in OrderedDict(Counter(s)).items():\n        if j == 1:\n            return s.index(i)\n    return -1\n```\n\n## [[go]]\n\n## [[rust]]\n","url":"https://deltamaniac.github.io/notes\\MK4zqoIqZbpAulNuIoBLk.html","relUrl":"notes\\MK4zqoIqZbpAulNuIoBLk.html"},{"doc":"Is Anagram ??","title":"Is Anagram ??","hpath":"dailybyte.d10","content":"\n# Problem\n\nThis question is asked by Facebook.\n\nGiven two strings s and t return whether or not s is an anagram of t.\n\nNote: An anagram is a word formed by reordering the letters of another word.\n\nEx: Given the following strings...\n\n> s = \"cat\", t = \"tac\", return true\n>\n> s = \"listen\", t = \"silent\", return true\n>\n> s = \"program\", t = \"function\", return false\n\n\n## [[python]]\n\n```python\ndef is_anagram(s1,s2):\n    return len(s1)==len(s2) and set(s1) == set(s2)\n```\n## [[go]]\n\n## [[rust]]","url":"https://deltamaniac.github.io/notes\\dFYESCBrjrDtYUYc6l2d4.html","relUrl":"notes\\dFYESCBrjrDtYUYc6l2d4.html"},{"doc":"Reverse String","title":"Reverse String","hpath":"dailybyte.d1","content":"\n# Problem\n\nThis question is asked by Google.\n\nGiven a string, reverse all of its characters and return the resulting string.\n\nEx: Given the following strings...\n\n> \"Cat\", return \"taC\"\n>\n> \"The Daily Byte\", return \"etyB yliaD ehT\"\n>\n> \"civic\", return \"civic\"\n\n## [[python]]\n\n```python\ndef reverse(word)\n    return word[::-1]\n```\n\n## [[go]]\n\n```go\nfunc reverse(s string) string {\n    // Handle UTF-16\n    rns := []rune(s)\n    for i, j := 0, len(rns)-1; i < j; i, j = i+1, j-1 {\n        rns[i], rns[j] = rns[j], rns[i]\n    }\n    return string(rns)\n}\n```\n\n## [[rust]]\n```rust\n// Handle UTF-16\nuse unicode_segementation:UnicodeSegmentation;\nfn reverse(word:&str)-> String{\n    word\n        .graphemes(true)\n        .rev()\n        .flat_map(|g| g.chars())\n        .collect()\n}\n```\n","url":"https://deltamaniac.github.io/notes\\8G20ZdvZxsbNNsw2.html","relUrl":"notes\\8G20ZdvZxsbNNsw2.html"},{"doc":"Advent of Code","title":"Advent of Code","hpath":"aoc","content":"\nAdvent of Code is an Advent calendar of small programming puzzles for a variety of skill sets and skill levels that can be solved in any programming language you like. People use them as a speed contest, interview prep, company training, university coursework, practice problems, or to challenge each other.\n","url":"https://deltamaniac.github.io/notes\\941adaa5-d22f-4bf9-831a-35bb5ac4100c.html","relUrl":"notes\\941adaa5-d22f-4bf9-831a-35bb5ac4100c.html"},{"doc":"2015","title":"2015","hpath":"aoc.2015","content":"\n\r\n","url":"https://deltamaniac.github.io/notes\\bb5ef214-cf28-4a7d-9c1e-15e8e9829ca3.html","relUrl":"notes\\bb5ef214-cf28-4a7d-9c1e-15e8e9829ca3.html"},{"doc":"Day 9","title":"Day 9","hpath":"aoc.2015.d9","content":"\n# All in a Single Night\n\n## Part I\n\n\nEvery year, Santa manages to deliver all of his presents in a single night.\n\nThis year, however, he has some new locations to visit; his elves have provided him the distances between every pair of locations. He can start and end at any two (different) locations he wants, but he must visit each location exactly once. What is the shortest distance he can travel to achieve this?\n\nFor example, given the following distances:\n\n```\nLondon to Dublin = 464\nLondon to Belfast = 518\nDublin to Belfast = 141\n```\nThe possible routes are therefore:\n\n```\nDublin -> London -> Belfast = 982\nLondon -> Dublin -> Belfast = 605\nLondon -> Belfast -> Dublin = 659\nDublin -> Belfast -> London = 659\nBelfast -> Dublin -> London = 605\nBelfast -> London -> Dublin = 982\n```\nThe shortest of these is `London -> Dublin -> Belfast = 605`, and so the answer is `605` in this example.\n\nWhat is the distance of the shortest route?\n\n## Solution\n```rust\nuse std::collections::HashMap;\n\nstruct Graph<'a> {\n    nodes: Vec<&'a str>,\n    edges: HashMap<(&'a str, &'a str), u16>,\n}\n\nimpl<'a> Graph<'a> {\n    fn new() -> Graph<'a> {\n        Graph {\n            nodes: Vec::new(),\n            edges: HashMap::new(),\n        }\n    }\n\n    fn permutations<'b>(collection: &[&'b str]) -> Vec<Vec<&'b str>> {\n        if collection.len() == 1 {\n            return vec![vec![collection[0]]];\n        }\n        let mut result = vec![];\n        for el in collection {\n            for tail in Self::permutations(\n                &collection\n                    .iter()\n                    .filter(|x| *x != el)\n                    .copied()\n                    .collect::<Vec<&'b str>>(),\n            ) {\n                let mut whole = vec![*el];\n                whole.extend(tail);\n                result.push(whole.clone())\n            }\n        }\n        result\n    }\n\n    fn cheapest(&self) -> u16 {\n        Graph::permutations(self.nodes.clone().as_ref())\n            .iter()\n            .map(|x| {\n                let mut last = \"\";\n                x.iter().fold(0, |tot, node| {\n                    if last != \"\" && last != *node {\n                        let price = &self.edges[&(last, *node)];\n                        last = node;\n                        tot + price\n                    } else {\n                        last = node;\n                        tot\n                    }\n                })\n            })\n            .min()\n            .unwrap()\n    }\n}\n\nfn input_to_graph(input: &str) -> Graph {\n    let mut graph = Graph::new();\n    input.lines().for_each(|line| {\n        let mut w = line.split_whitespace();\n        let s = w.next().unwrap();\n        w.next();\n        let d = w.next().unwrap();\n        w.next();\n        let l = w.next().unwrap().to_string().parse::<u16>().unwrap();\n        if !graph.nodes.contains(&s) {\n            graph.nodes.push(s);\n        }\n        if !graph.nodes.contains(&d) {\n            graph.nodes.push(d);\n        }\n        graph.edges.insert((s, d), l);\n        graph.edges.insert((d, s), l);\n    });\n    graph\n}\n\n#[aoc(day9, part1)]\npub fn part1(input: &str) -> u16 {\n    input_to_graph(input).cheapest()\n}\n```\n## Part II\n\nThe next year, just to show off, Santa decides to take the route with the longest distance instead.\n\nHe can still start and end at any two (different) locations he wants, and he still must visit each location exactly once.\n\nFor example, given the distances above, the longest route would be `982` via (for example) `Dublin -> London -> Belfast`.\n\nWhat is the distance of the longest route?\n\n## Solution\n\n```rust\nimpl<'a> Graph<'a> {\n    //New Method\n    fn costliest(&self) -> u16 {\n        Graph::permutations(self.nodes.clone().as_ref())\n            .iter()\n            .map(|x| {\n                let mut last = \"\";\n                x.iter().fold(0, |tot, node| {\n                    if last != \"\" && last != *node {\n                        let price = &self.edges[&(last, *node)];\n                        last = node;\n                        tot + price\n                    } else {\n                        last = node;\n                        tot\n                    }\n                })\n            })\n            .max()\n            .unwrap()\n    }\n}\n#[aoc(day9, part2)]\npub fn part2(input: &str) -> u16 {\n    input_to_graph(input).costliest()\n}\n```\n","url":"https://deltamaniac.github.io/notes\\a9f77b09-feb1-417c-ac20-57a63cb6e1b7.html","relUrl":"notes\\a9f77b09-feb1-417c-ac20-57a63cb6e1b7.html"},{"doc":"Day 8","title":"Day 8","hpath":"aoc.2015.d8","content":"\n# Matchsticks\n\nSpace on the sleigh is limited this year, and so Santa will be bringing his list as a digital copy. He needs to know how much space it will take up when stored.\n\nIt is common in many programming languages to provide a way to escape special characters in strings. For example, C, JavaScript, Perl, Python, and even PHP handle special characters in very similar ways.\n\nHowever, it is important to realize the difference between the number of characters in the code representation of the string literal and the number of characters in the in-memory string itself.\n\nFor example:\n\n>`\"\"` is `2` characters of code (the two double quotes), but the string contains zero characters.\n>\n>`\"abc\"` is `5` characters of code, but 3 characters in the string data.\n`\"aaa\\\"aaa\"` is `10` characters of code, but the string itself contains six \"a\" characters and a single, escaped quote character, for a total of `7` characters in the string data.\n>\n>`\"\\x27\"` is `6` characters of code, but the string itself contains just one - an apostrophe (`'`), escaped using hexadecimal notation.\n\nSanta's list is a file that contains many double-quoted string literals, one on each line. The only escape sequences used are `\\\\` (which represents a single backslash), `\\\"` (which represents a lone double-quote character), and `\\x` plus two hexadecimal characters (which represents a single character with that ASCII code).\n\nDisregarding the whitespace in the file, what is the number of characters of code for string literals minus the number of characters in memory for the values of the strings in total for the entire file?\n\nFor example, given the four strings above, the total number of characters of string code (`2 + 5 + 10 + 6 = 23`) minus the total number of characters in memory for string values (`0 + 3 + 7 + 1 = 11`) is `23 - 11 = 12`.\n\n## Solution\n```rust\n#[aoc(day8, part1)]\npub fn part1(input: &str) -> u16 {\n    let mut mem_count: Vec<u16> = Vec::new();\n    let mut char_count: Vec<u16> = Vec::new();\n    input.lines().for_each(|line| {\n        char_count.push(line.chars().count() as u16);\n        let mut chars = line.chars();\n        let mut count: u16 = 0;\n        chars.next();\n        loop {\n            match chars.next() {\n                Some(c) => match c {\n                    '\\\"' => {}\n                    '\\\\' => match chars.next() {\n                        Some(c) => {\n                            if c == 'x' {\n                                chars.next();\n                                chars.next();\n                                count += 1;\n                            } else if c == '\"' || c == '\\\\' {\n                                count += 1;\n                            }\n                        }\n                        None => (),\n                    },\n                    _ => {\n                        count += 1;\n                    }\n                },\n                None => break,\n            }\n        }\n        mem_count.push(count);\n    });\n    char_count.iter().sum::<u16>() - mem_count.iter().sum::<u16>()\n}\n```\n\n## Part II\n\nNow, let's go the other way. In addition to finding the number of characters of code, you should now encode each code representation as a new string and find the number of characters of the new encoded representation, including the surrounding double quotes.\n\nFor example:\n\n>`\"\"` encodes to `\"\\\"\\\"\"`, an increase from `2` characters to `6`.\n>\n>`\"abc\"` encodes to `\"\\\"abc\\\"\"`, an increase from `5` characters to `9`.\n>\n>`\"aaa\\\"aaa\"` encodes to `\"\\\"aaa\\\\\\\"aaa\\\"\"`, an increase from `10` characters to `16`.\n>\n>`\"\\x27`\" encodes to `\"\\\"\\\\x27\\\"\"`, an increase from `6` characters to `11`.\n\nYour task is to find the total number of characters to represent the newly encoded strings minus the number of characters of code in each original string literal. For example, for the strings above, the total encoded length (`16 + 9 + 16 + 11 = 42`) minus the characters in the original code representation (`23`, just like in the first part of this puzzle) is `42 - 23 = 19`.\n\n# Solution\n```rust\n#[aoc(day8, part2)]\npub fn part2(input: &str) -> u16 {\n    let mut mem_count: Vec<u16> = Vec::new();\n    let mut char_count: Vec<u16> = Vec::new();\n    input.lines().for_each(|line| {\n        char_count.push(line.chars().count() as u16);\n        let mut chars = line.chars();\n        let mut esc_count: u16 = 2;\n        loop {\n            match chars.next() {\n                Some(c) => match c {\n                    '\\\"' => {\n                        esc_count += 1;\n                    }\n                    '\\\\' => match chars.next() {\n                        Some(c) => {\n                            if c == 'x' {\n                                chars.next();\n                                chars.next();\n                                esc_count += 1;\n                            } else if c == '\"' || c == '\\\\' {\n                                esc_count += 2;\n                            }\n                        }\n                        None => (),\n                    },\n                    _ => {}\n                },\n                None => break,\n            }\n        }\n        mem_count.push(line.chars().count() as u16 + esc_count);\n    });\n    mem_count.iter().sum::<u16>() - char_count.iter().sum::<u16>()\n}\n```\n","url":"https://deltamaniac.github.io/notes\\ef7af9d9-d9f5-46f2-bb1a-be6e0e18862c.html","relUrl":"notes\\ef7af9d9-d9f5-46f2-bb1a-be6e0e18862c.html"},{"doc":"Day 7","title":"Day 7","hpath":"aoc.2015.d7","content":"\n# Some Assembly Required\n\n## Part I\n\nThis year, Santa brought little Bobby Tables a set of wires and bitwise logic gates! Unfortunately, little Bobby is a little under the recommended age range, and he needs help assembling the circuit.\n\nEach wire has an identifier (some lowercase letters) and can carry a 16-bit signal (a number from `0` to `65535`). A signal is provided to each wire by a gate, another wire, or some specific value. Each wire can only get a signal from one source, but can provide its signal to multiple destinations. A gate provides no signal until all of its inputs have a signal.\n\nThe included instructions booklet describes how to connect the parts together: `x AND y -> z` means to connect wires `x` and `y` to an AND gate, and then connect its output to wire `z`.\n\nFor example:\n\n>`123 -> x` means that the signal 123 is provided to wire `x`.\n>\n>`x AND y -> z` means that the bitwise AND of wire `x` and wire `y` is provided to wire `z`.\n>\n>`p LSHIFT 2 -> q` means that the value from wire `p` is left-shifted by `2` and then provided to wire `q`.\n>\n>`NOT e -> f` means that the bitwise complement of the value from wire `e` is provided to wire `f`.\n\nOther possible gates include `OR` (bitwise OR) and `RSHIFT` (right-shift). If, for some reason, you'd like to emulate the circuit instead, almost all programming languages (for example, C, JavaScript, or Python) provide operators for these gates.\n\nFor example, here is a simple circuit:\n```\n123 -> x\n456 -> y\nx AND y -> d\nx OR y -> e\nx LSHIFT 2 -> f\ny RSHIFT 2 -> g\nNOT x -> h\nNOT y -> i\n```\n\nAfter it is run, these are the signals on the wires:\n\n```\nd: 72\ne: 507\nf: 492\ng: 114\nh: 65412\ni: 65079\nx: 123\ny: 456\n```\n\nIn little Bobby's kit's instructions booklet (provided as your puzzle input), what signal is ultimately provided to wire `a`?\n\n## Solution\n```rust\nuse std::collections::HashMap;\n#[derive(Debug)]\npub enum Gate {\n    Value(u16, String),\n    Source(String, String),\n    And(String, String, String),\n    AndValue(u16, String, String),\n    Or(String, String, String),\n    LShift(String, u16, String),\n    RShift(String, u16, String),\n    Not(String, String),\n}\n\n#[aoc_generator(day7)]\npub fn input_to_struct(input: &str) -> Vec<Gate> {\n    input\n        .lines()\n        .map(|line| {\n            let words = line.split_whitespace().collect::<Vec<_>>();\n            if words[0] == \"NOT\" {\n                Gate::Not(words[1].to_string(), words[3].to_string())\n            } else if words[1] == \"LSHIFT\" {\n                Gate::LShift(\n                    words[0].to_string(),\n                    words[2].to_string().trim().parse::<u16>().unwrap(),\n                    words[4].to_string(),\n                )\n            } else if words[1] == \"RSHIFT\" {\n                Gate::RShift(\n                    words[0].to_string(),\n                    words[2].to_string().trim().parse::<u16>().unwrap(),\n                    words[4].to_string(),\n                )\n            } else if words[0].to_string().trim().parse::<i64>().is_ok() && words[1] == \"AND\" {\n                Gate::AndValue(\n                    words[0].to_string().trim().parse::<u16>().unwrap(),\n                    words[2].to_string(),\n                    words[4].to_string(),\n                )\n            } else if words[1] == \"AND\" {\n                Gate::And(\n                    words[0].to_string(),\n                    words[2].to_string(),\n                    words[4].to_string(),\n                )\n            } else if words[1] == \"OR\" {\n                Gate::Or(\n                    words[0].to_string(),\n                    words[2].to_string(),\n                    words[4].to_string(),\n                )\n            } else if words[0].to_string().trim().parse::<i64>().is_ok() && words[1] == \"->\" {\n                Gate::Value(\n                    words[0].to_string().trim().parse::<u16>().unwrap(),\n                    words[2].to_string(),\n                )\n            } else if words[1] == \"->\" {\n                Gate::Source(words[0].to_string(), words[2].to_string())\n            } else {\n                unreachable!()\n            }\n        })\n        .collect::<Vec<Gate>>()\n}\n\nfn solve_circuit(gates: &[Gate], values: &mut HashMap<String, u16>) -> HashMap<String, u16> {\n    let mut unresolved = true;\n    let constants = values.clone();\n    while unresolved {\n        let values_prev = values.clone();\n        gates.iter().for_each(|item| {\n            for (k, v) in &constants {\n                values.insert(k.clone(), *v);\n            }\n            match item {\n                Gate::Value(ref num, ref dst) => {\n                    values.insert(dst.to_string(), *num);\n                }\n                Gate::Source(ref src0, ref dst) => {\n                    if values.contains_key(src0) {\n                        let v0 = *values.get(src0).unwrap();\n                        values.insert(dst.to_string(), v0);\n                    }\n                }\n                Gate::And(ref src0, ref src1, ref dst) => {\n                    if values.contains_key(src0) && values.contains_key(src1) {\n                        let v0 = *values.get(src0).unwrap();\n                        let v1 = *values.get(src1).unwrap();\n                        values.insert(dst.to_string(), v0 & v1);\n                    }\n                }\n                Gate::AndValue(ref v0, ref src1, ref dst) => {\n                    if values.contains_key(src1) {\n                        let v1 = *values.get(src1).unwrap();\n                        values.insert(dst.to_string(), *v0 & v1);\n                    }\n                }\n                Gate::Or(ref src0, ref src1, ref dst) => {\n                    if values.contains_key(src0) && values.contains_key(src1) {\n                        let v0 = *values.get(src0).unwrap();\n                        let v1 = *values.get(src1).unwrap();\n                        values.insert(dst.to_string(), v0 | v1);\n                    }\n                }\n                Gate::LShift(ref src0, ref num, ref dst) => {\n                    if values.contains_key(src0) {\n                        let v0 = *values.get(src0).unwrap();\n                        values.insert(dst.to_string(), v0 << *num);\n                    }\n                }\n                Gate::RShift(ref src0, ref num, ref dst) => {\n                    if values.contains_key(src0) {\n                        let v0 = *values.get(src0).unwrap();\n                        values.insert(dst.to_string(), v0 >> *num);\n                    }\n                }\n                Gate::Not(ref src0, ref dst) => {\n                    if values.contains_key(src0) {\n                        let v0 = *values.get(src0).unwrap();\n                        values.insert(dst.to_string(), !v0);\n                    }\n                }\n            }\n            unresolved = values_prev != *values;\n        });\n    }\n    values.clone()\n}\n\n#[aoc(day7, part1)]\npub fn part1(input: &[Gate]) -> u16 {\n    *solve_circuit(input, &mut HashMap::new()).get(\"a\").unwrap()\n}\n```\n\n## Part II\n\nNow, take the signal you got on wire a, override wire b to that signal, and reset the other wires (including wire a).\n\nWhat new signal is ultimately provided to wire `a`?\n\n## Solution\n\n```rust\n#[aoc(day7, part2)]\npub fn part2(input: &[Gate]) -> u16 {\n    let mut map = HashMap::new();\n    map.insert(\n        \"b\".to_string(),\n        *solve_circuit(&input, &mut HashMap::new()).get(\"a\").unwrap(),\n    );\n    *solve_circuit(&input, &mut map).get(\"a\").unwrap()\n}\n```\n","url":"https://deltamaniac.github.io/notes\\c536b676-d9cb-43fb-b14d-ce9ad08627bb.html","relUrl":"notes\\c536b676-d9cb-43fb-b14d-ce9ad08627bb.html"},{"doc":"Day 6","title":"Day 6","hpath":"aoc.2015.d6","content":"\n# Probably a Fire Hazard\n\n## Part I\n\nBecause your neighbors keep defeating you in the holiday house decorating contest year after year, you've decided to deploy one million lights in a 1000x1000 grid.\n\nFurthermore, because you've been especially nice this year, Santa has mailed you instructions on how to display the ideal lighting configuration.\n\nLights in your grid are numbered from 0 to 999 in each direction; the lights at each corner are at `0,0`, `0,999`, `999,999`, and `999,0`. The instructions include whether to `turn on`, `turn off`, or `toggle` various inclusive ranges given as coordinate pairs. Each coordinate pair represents opposite corners of a rectangle, inclusive; a coordinate pair like `0,0 through 2,2` therefore refers to 9 lights in a 3x3 square. The lights all start turned off.\n\nTo defeat your neighbors this year, all you have to do is set up your lights by doing the instructions Santa sent you in order.\n\nFor example:\n\n> `turn on 0,0 through 999,999` would turn on (or leave on) every light.\n>\n> `toggle 0,0 through 999,0` would toggle the first line of 1000 lights, turning off the ones that were on, and turning on the ones that were off.\n>\n> `turn off 499,499 through 500,500` would turn off (or leave off) the middle four lights.\n\nAfter following the instructions, how many lights are lit?\n\n## Solution\n\n\n```rust\nenum Action {\n    On,\n    Off,\n    Toggle,\n}\n\npub struct Instruction {\n    start: (usize, usize),\n    end: (usize, usize),\n    action: Action,\n}\n\n#[aoc_generator(day6)]\npub fn input_to_struct(input: &str) -> Vec<Instruction> {\n    input\n        .lines()\n        .map(|line| {\n            let mut c = line.split_whitespace().rev();\n            let mut d = c.next().unwrap().split(',');\n            let end = (\n                d.next().unwrap().parse::<usize>().unwrap(),\n                d.next().unwrap().parse::<usize>().unwrap(),\n            );\n            c.next();\n            let mut d = c.next().unwrap().split(',');\n            let start = (\n                d.next().unwrap().parse::<usize>().unwrap(),\n                d.next().unwrap().parse::<usize>().unwrap(),\n            );\n            let action = match c.next().unwrap() {\n                \"on\" => Action::On,\n                \"off\" => Action::Off,\n                \"toggle\" => Action::Toggle,\n                _ => unreachable!(),\n            };\n\n            Instruction {\n                start: start,\n                end: end,\n                action: action,\n            }\n        })\n        .collect::<Vec<Instruction>>()\n}\n\n#[aoc(day6, part1)]\npub fn part1(input: &Vec<Instruction>) -> i64 {\n    let mut switch: [[u8; 1000]; 1000] = [[0; 1000]; 1000];\n    let mut count: i64 = 0;\n    for x in input {\n        for i in x.start.0..=x.end.0 {\n            for j in x.start.1..=x.end.1 {\n                match x.action {\n                    Action::Off => {\n                        if switch[i][j] == 1 {\n                            count -= 1;\n                            switch[i][j] = 0;\n                        }\n                    }\n                    Action::On => {\n                        if switch[i][j] == 0 {\n                            count += 1;\n                            switch[i][j] = 1;\n                        }\n                    }\n                    Action::Toggle => {\n                        if switch[i][j] == 0 {\n                            count += 1;\n                            switch[i][j] = 1;\n                        } else {\n                            count += -1;\n                            switch[i][j] = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    count\n}\n```\n\n## Part II\n\n\nYou just finish implementing your winning light pattern when you realize you mistranslated Santa's message from Ancient Nordic Elvish.\n\nThe light grid you bought actually has individual brightness controls; each light can have a brightness of zero or more. The lights all start at zero.\n\nThe phrase `turn on` actually means that you should increase the brightness of those lights by `1`.\n\nThe phrase `turn off` actually means that you should decrease the brightness of those lights by `1`, to a minimum of zero.\n\nThe phrase toggle actually means that you should increase the brightness of those lights by `2`.\n\nWhat is the total brightness of all lights combined after following Santa's instructions?\n\nFor example:\n\n> `turn on 0,0 through 0,0` would increase the total brightness by `1`.\n>\n> `toggle 0,0 through 999,999` would increase the total brightness by `2000000`.\n\n## Solution\n\n```rust\n#[aoc(day6, part2)]\npub fn part2(input: &Vec<Instruction>) -> i64 {\n    let mut switch: [[i16; 1000]; 1000] = [[0; 1000]; 1000];\n    let mut bright: i64 = 0;\n    for x in input {\n        for i in x.start.0..=x.end.0 {\n            for j in x.start.1..=x.end.1 {\n                match x.action {\n                    Action::Off => {\n                        if switch[i][j] > 0 {\n                            bright -= 1;\n                            switch[i][j] -= 1;\n                        }\n                    }\n                    Action::On => {\n                        bright += 1;\n                        switch[i][j] += 1;\n                    }\n                    Action::Toggle => {\n                        bright += 2;\n                        switch[i][j] += 2;\n                    }\n                }\n            }\n        }\n    }\n    bright\n}\n```\n","url":"https://deltamaniac.github.io/notes\\d5d42ce8-1731-47e9-9551-b2343ba7885d.html","relUrl":"notes\\d5d42ce8-1731-47e9-9551-b2343ba7885d.html"},{"doc":"Day 5","title":"Day 5","hpath":"aoc.2015.d5","content":"\n\r\n\r\n# Doesn't He Have Intern-Elves For This?\r\n\r\n## Part I\r\n\r\nSanta needs help figuring out which strings in his text file are naughty or nice.\r\n\r\nA nice string is one with all of the following properties:\r\n\r\n> It contains at least three vowels (`aeiou` only), like `aei`, `xazegov`, or `aeiouaeiouaeiou`.\r\n>\r\n>It contains at least one letter that appears twice in a row, like `xx`, `abcdde` (`dd`), or `aabbccdd` (`aa`, `bb`, `cc`, or `dd`).\r\n>\r\n>It does not contain the strings `ab`, `cd`, `pq`, or `xy`, even if they are part of one of the other requirements.\r\n\r\nFor example:\r\n\r\n> `ugknbfddgicrmopn` is nice because it has at least three vowels (`u...i...o...`), a double letter (`...dd...`), and none of the disallowed substrings.\r\n>\r\n>`aaa` is nice because it has at least three vowels and a double letter, even though the letters used by different rules overlap.\r\n>\r\n>`jchzalrnumimnmhp` is naughty because it has no double letter.\r\n>\r\n>`haegwjzuvuyypxyu` is naughty because it contains the string xy.\r\n>\r\n>`dvszwmarrgswjxmb` is naughty because it contains only one vowel.\r\n\r\nHow many strings are nice?\r\n\r\n## Solution\r\nIterating the input line by line we can pass it through filters which would apply the conditions so as to eliminate all strings that are not `nice`.\r\n\r\nThe answer is the count of all the remaining strings.\r\n\r\n```rust\r\n#[aoc(day5, part1)]\r\npub fn part1(input: &str) -> usize {\r\n    input\r\n        .lines()\r\n        .filter(|w| !(w.contains(\"ab\") || w.contains(\"cd\") || w.contains(\"pq\") || w.contains(\"xy\")))\r\n        .filter(|x| {\r\n            x.chars()\r\n                .filter(|c| *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u')\r\n                .count()\r\n                > 2\r\n        })\r\n        .filter(|y| {\r\n            let mut c = y.chars().collect::<Vec<char>>();\r\n            let l = c.len();\r\n            c.dedup();\r\n            l != c.len()\r\n        })\r\n        .count()\r\n}\r\n```\r\n\r\n## Part II\r\n\r\nRealizing the error of his ways, Santa has switched to a better model of determining whether a string is naughty or nice. None of the old rules apply, as they are all clearly ridiculous.\r\n\r\nNow, a nice string is one with all of the following properties:\r\n\r\n>It contains a pair of any two letters that appears at least twice in the string without overlapping, like `xyxy` (`xy`) or `aabcdefgaa` (`aa`), but not like `aaa` (`aa`, but it overlaps).\r\n>\r\n>It contains at least one letter which repeats with exactly one letter between them, like `xyx`, `abcdefeghi` (`efe`), or even `aaa`.\r\n\r\n\r\nFor example:\r\n> `qjhvhtzxzqqjkmpb` is nice because is has a pair that appears twice (`qj`) and a letter that repeats with exactly one letter between them (`zxz`).\r\n>\r\n> `xxyxx` is nice because it has a pair that appears twice and a letter that repeats with one between, even though the letters used by each rule overlap.\r\n>\r\n> `uurcxstgmygtbstg` is naughty because it has a pair (`tg`) but no repeat with a single letter between them.\r\n>\r\n> `ieodomkazucvgmuy` is naughty because it has a repeating letter with one between (`odo`), but no pair that appears twice.\r\n\r\nHow many strings are nice under these new rules?\r\n\r\n## Solution\r\nA recursive function `repeat_xx` provides the check for condition we then filter out on the strings that match.\r\n\r\nThe answer is the count of all the remaining strings after the filters have been applied.\r\n\r\n```rust\r\nfn repeat_xx(string: &str) -> bool {\r\n    if string.len() < 4 {\r\n        return false;\r\n    }\r\n\r\n    let pair = &string[0..2];\r\n    let remain = &string[2..];\r\n\r\n    remain.contains(pair) || repeat_xx(&string[1..])\r\n}\r\n\r\n#[aoc(day5, part2)]\r\npub fn part2(input: &str) -> usize {\r\n    input\r\n        .lines()\r\n        .filter(|y| repeat_xx(y))\r\n        .filter(|z| z.chars().zip(z.chars().skip(2)).any(|(a, b)| a == b))\r\n        .count()\r\n}\r\n```\r\n","url":"https://deltamaniac.github.io/notes\\80d4a8ee-94fa-4b37-aabd-eb6fcc053d21.html","relUrl":"notes\\80d4a8ee-94fa-4b37-aabd-eb6fcc053d21.html"},{"doc":"Day 4","title":"Day 4","hpath":"aoc.2015.d4","content":"\n# The Ideal Stocking Stuffer\n\n## Part I\n\nSanta needs help mining some AdventCoins (very similar to bitcoins) to use as gifts for all the economically forward-thinking little girls and boys.\n\nTo do this, he needs to find MD5 hashes which, in hexadecimal, start with at least five zeroes. The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal. To mine AdventCoins, you must find Santa the lowest positive number (no leading zeroes: `1`, `2`, `3`, ...) that produces such a hash.\n\nFor example:\n\n> If your secret key is `abcdef`, the answer is `609043`, because the MD5 hash of `abcdef609043` starts with five zeroes (`000001dbbfa...`), and it is the lowest such number to do so.\n>\n> If your secret key is `pqrstuv`, the lowest number it combines with to make an MD5 hash starting with five zeroes is `1048970`; that is, the MD5 hash of `pqrstuv1048970` looks like `000006136ef....`\n\n## Solution\n\nBrute forcing would be the easiest way to find the solution.\n\nTaking the input we iterate from 1 to the max u32 using `i` and append it to the input.\n\nThis would be the content for which we compute the`md5Sum` and check if it starts with five zeroes.\n```rust\nuse md5;\n\n#[aoc(day4, part1)]\npub fn solve_part1(input: &str) -> u32 {\n    (1..)\n        .filter(|i| format!(\"{:x}\", md5::compute(format!(\"{}{}\", input, i))).starts_with(\"00000\"))\n        .next()\n        .unwrap()\n}\n```\n\n## Part II\n\n\nNow find one that starts with six zeroes.\n\n## Solution\n\nA small change from `.starts_with(\"00000\")` to `.starts_with(\"000000\")` provides the answer.\n\n```rust\n#[aoc(day4, part2)]\npub fn solve_part2(input: &str) -> i32 {\n    (1..)\n        .filter(|i| format!(\"{:x}\", md5::compute(format!(\"{}{}\", input, i))).starts_with(\"000000\"))\n        .next()\n        .unwrap()\n}\n```\n","url":"https://deltamaniac.github.io/notes\\f6d391d5-db6b-46bb-a432-4a6592355b34.html","relUrl":"notes\\f6d391d5-db6b-46bb-a432-4a6592355b34.html"},{"doc":"Day 3","title":"Day 3","hpath":"aoc.2015.d3","content":"\n# Perfectly Spherical Houses in a Vacuum\n\n## Part I\n\nSanta is delivering presents to an infinite two-dimensional grid of houses.\n\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (`^`), south (`v`), east (`>`), or west (`<`). After each move, he delivers another present to the house at his new location.\n\nHowever, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive at least one present?\n\nFor example:\n\n> `>` delivers presents to 2 houses: one at the starting location, and one to the east.\n>\n> `^>v<` delivers presents to 4 houses in a square, including twice to the house at his starting/ending location.\n>\n> `^v^v^v^v^v` delivers a bunch of presents to some very lucky children at only 2 houses.\n\n## Solution\n\nA simple XY coordinate system would make this a simple pathing problem.\n\nThe `last_pos` variable would hold the (x,y) coordinates of Santa.\n\nA hashmap with the key as the (x,y) coordinate will be used to identify individual houses and store the number of presents delivered at that house.\n\n```rust\n#[aoc(day3, part1)]\npub fn part1(input: &str) -> usize {\n    let mut last_pos = (0, 0);\n    let mut map: HashMap<(i32, i32), u32> = HashMap::new();\n    map.insert(last_pos, 0);\n    input.chars().for_each(|d| {\n        last_pos = match d {\n            '^' => (last_pos.0 + 1, last_pos.1),\n            'v' => (last_pos.0 - 1, last_pos.1),\n            '>' => (last_pos.0, last_pos.1 + 1),\n            '<' => (last_pos.0, last_pos.1 - 1),\n            _ => unreachable!(),\n        };\n        map.entry(last_pos).and_modify(|x| *x += 1).or_insert(1);\n    });\n    map.len()\n}\n```\n\n## Part II\nThe next year, to speed up the process, Santa creates a robot version of himself, Robo-Santa, to deliver presents with him.\n\nSanta and Robo-Santa start at the same location (delivering two presents to the same starting house), then take turns moving based on instructions from the elf, who is eggnoggedly reading from the same script as the previous year.\n\nThis year, how many houses receive at least one present?\n\nFor example:\n\n> `^v` delivers presents to 3 houses, because Santa goes north, and then Robo-Santa goes south.\n>\n> `^>v<` now delivers presents to `3` houses, and Santa and Robo-Santa end up back where they started.\n>\n> `^v^v^v^v^v` now delivers presents to `11` houses, with Santa going one direction and Robo-Santa going the other.\n\n## Solution\n\nHere we would have to trace 2 paths, one for Santa and another for Robo-Santa.\n\nSince both of them take turns reading the instructions, Santa received all odd numbered instructions and the Robo-Santa receives all even numbered instructions.\n\n```rust\n#[aoc(day3, part2)]\npub fn part2(input: &str) -> usize {\n    let mut last_pos = (0, 0);\n    let mut last_pos_clone = (0, 0);\n    let mut map: HashMap<(i32, i32), u32> = HashMap::new();\n    map.insert(last_pos, 0);\n    input.chars().enumerate().for_each(|(i, d)| {\n        if i % 2 == 0 {\n            last_pos = match d {\n                '^' => (last_pos.0 + 1, last_pos.1),\n                'v' => (last_pos.0 - 1, last_pos.1),\n                '>' => (last_pos.0, last_pos.1 + 1),\n                '<' => (last_pos.0, last_pos.1 - 1),\n                _ => unreachable!(),\n            };\n            map.entry(last_pos).and_modify(|x| *x += 1).or_insert(1);\n        } else {\n            last_pos_clone = match d {\n                '^' => (last_pos_clone.0 + 1, last_pos_clone.1),\n                'v' => (last_pos_clone.0 - 1, last_pos_clone.1),\n                '>' => (last_pos_clone.0, last_pos_clone.1 + 1),\n                '<' => (last_pos_clone.0, last_pos_clone.1 - 1),\n                _ => unreachable!(),\n            };\n            map.entry(last_pos_clone)\n                .and_modify(|x| *x += 1)\n                .or_insert(1);\n        }\n    });\n    map.len()\n}\n```\n","url":"https://deltamaniac.github.io/notes\\17fb47c1-bbab-4343-bdb4-3e9910c24944.html","relUrl":"notes\\17fb47c1-bbab-4343-bdb4-3e9910c24944.html"},{"doc":"Day 2","title":"Day 2","hpath":"aoc.2015.d2","content":"\n#  I Was Told There Would Be No Math\n\n## Part I\n\nThe elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length `l`, width `w`, and height `h`) of each present, and only want to order exactly as much as they need.\n\nFortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is `2*l*w + 2*w*h + 2*h*l`. The elves also need a little extra paper for each present: the area of the smallest side.\n\nFor example:\n\n> A present with dimensions `2x3x4` requires `2*6 + 2*12 + 2*8 = 52` square feet of wrapping paper plus `6` square feet of slack, for a total of `58` square feet.\n>\n> A present with dimensions `1x1x10` requires `2*1 + 2*10 + 2*10 = 42` square feet of wrapping paper plus `1` square foot of slack, for a total of `43` square feet.\n\nAll numbers in the elves' list are in feet. How many total square feet of wrapping paper should they order?\n\n## Solution\n\nA simple structure that can hold the dimensions would be the starting point from which we can solve the problem.\n\nA method `get_area` that would return the area calculated as `2*l*w + 2*w*h + 2*h*l`.\n\nA method `get_smallest_side_area` would calculate all the side areas and return the minimum which would provide the `slack` to be added.\n\nA `text_to_struct` method that would convert the text input to a `Vector` of `Prism`, to enable easy iteration.\n\nTo find the answer iterate over the Vector<Prism> calculate the `area` + `smallest_side_area` and sum them all up.\n\n```rust\n// Holds the dimensions of the Gift\n#[derive(Copy, Clone)]\npub struct Prism {\n    x: u32,\n    y: u32,\n    z: u32,\n}\n\nimpl Prism {\n\n    pub fn get_smallest_side_area(self) -> u32 {\n        *[self.x * self.y, self.y * self.z, self.z * self.x]\n            .iter()\n            .min()\n            .unwrap_or(&0)\n    }\n\n    pub fn get_area(self) -> u32 {\n        [\n            2 * self.x * self.y,\n            2 * self.y * self.z,\n            2 * self.z * self.x,\n        ]\n        .iter()\n        .sum::<u32>()\n    }\n}\n\n#[aoc_generator(day2)]\npub fn text_to_struct(input: &str) -> Vec<Prism> {\n    input\n        .lines()\n        .map(|line| {\n            let mut chars = line.trim().split('x');\n            Prism {\n                x: chars.next().unwrap().parse().unwrap(),\n                y: chars.next().unwrap().parse().unwrap(),\n                z: chars.next().unwrap().parse().unwrap(),\n            }\n        })\n        .collect::<Vec<Prism>>()\n}\n\n#[aoc(day2, part1)]\npub fn part1(input: &[Prism]) -> u32 {\n    input\n        .iter()\n        .map(|x| x.get_smallest_side_area() + x.get_area())\n        .collect::<Vec<u32>>()\n        .iter()\n        .sum()\n}\n```\n\n## Part II\n\nThe elves are also running low on ribbon. Ribbon is all the same width, so they only have to worry about the length they need to order, which they would again like to be exact.\n\nThe ribbon required to wrap a present is the shortest distance around its sides, or the smallest perimeter of any one face. Each present also requires a bow made out of ribbon as well; the feet of ribbon required for the perfect bow is equal to the cubic feet of volume of the present. Don't ask how they tie the bow, though; they'll never tell.\n\nFor example:\n> A present with dimensions `2x3x4` requires `2+2+3+3 = 10` feet of ribbon to wrap the present plus `2*3*4 = 24` feet of ribbon for the bow, for a total of `34` feet.\n>\n> A present with dimensions `1x1x10` requires `1+1+1+1 = 4` feet of ribbon to wrap the present plus `1*1*10 = 10` feet of ribbon for the bow, for a total of `14` feet.\n\nHow many total feet of ribbon should they order?\n\n## Solution\n\nA method `get_smallest_perimeter` that would return the smallest perimeter of the prism.\n\nTo find the answer iterate over the Vector<Prism> calculate the `smallest_perimeter` + `sum of the sides of the smallest perimeter` and sum them all up.\n\n```rust\nimpl Prism {\n    pub fn get_smallest_side_area(self) -> u32 {\n        *[self.x * self.y, self.y * self.z, self.z * self.x]\n            .iter()\n            .min()\n            .unwrap_or(&0)\n    }\n\n    pub fn get_area(self) -> u32 {\n        [\n            2 * self.x * self.y,\n            2 * self.y * self.z,\n            2 * self.z * self.x,\n        ]\n        .iter()\n        .sum::<u32>()\n    }\n    // PART 2\n    pub fn get_smallest_perimeter(self) -> u32 {\n        *[\n            2 * (self.x + self.y),\n            2 * (self.y + self.z),\n            2 * (self.z + self.x),\n        ]\n        .iter()\n        .min()\n        .unwrap_or(&0)\n    }\n}\n\n#[aoc(day2, part2)]\npub fn part2(input: &[Prism]) -> u32 {\n    input\n        .iter()\n        .map(|x| x.get_smallest_perimeter() + (x.x * x.y * x.z))\n        .collect::<Vec<u32>>()\n        .iter()\n        .sum()\n}\n\n```\n","url":"https://deltamaniac.github.io/notes\\0359877a-1c2d-4363-aef5-41dcb3d086ca.html","relUrl":"notes\\0359877a-1c2d-4363-aef5-41dcb3d086ca.html"},{"doc":"Day 12","title":"Day 12","hpath":"aoc.2015.d12","content":"\n# Day 12: JSAbacusFramework.io\n\n# Part I\n\nSanta's Accounting-Elves need help balancing the books after a recent order. Unfortunately, their accounting software uses a peculiar storage format. That's where you come in.\n\nThey have a JSON document which contains a variety of things: arrays (`[1,2,3]`), objects (`{\"a\":1, \"b\":2}`), numbers, and strings.\n\n Your first job is to simply find all of the numbers throughout the document and add them together.\n\nFor example:\n\n>`[1,2,3]` and `{\"a\":2,\"b\":4}` both have a sum of `6`.\n>\n>`[[[3]]] and {\"a\":{\"b\":4},\"c\":-1}` both have a sum of `3`.\n>\n>`{\"a\":[-1,1]} and [-1,{\"a\":1}]` both have a sum of `0`.\n>\n>`[]` and `{}` both have a sum of `0`.\n\nYou will not encounter any strings containing numbers.\n\nWhat is the sum of all numbers in the document?\n\n## Solution\n\n## Without Serde\n\n```rust\npub fn part1(input: &str) -> i32 {\n    let mut value = 0i32;\n    let mut tmp_val = 0i32;\n    let mut last: char = '\\x00';\n    let mut multiplier = 1;\n    for ch in input.chars() {\n        value += match ch {\n            '0'...'9' => {\n                if last == '-' {\n                    multiplier = -1;\n                }\n                tmp_val = tmp_val * 10\n                    + match ch.to_string().parse::<i32>() {\n                        Ok(x) => x,\n                        Err(e) => panic!(\"Help! {}\", e),\n                    };\n\n                0\n            }\n            _ if last.is_digit(10) => {\n                let tmp = tmp_val * multiplier;\n                tmp_val = 0;\n                multiplier = 1;\n\n                tmp\n            }\n            _ => 0,\n        };\n        last = ch;\n    }\n    value\n}\n```\n\n### With Serde\n\n```rust\nfn sum(v: Value, use_red: bool) -> i64 {\n    match v {\n        Value::Null => 0,\n        Value::Bool(_) => 0,\n        Value::Number(n) => n.as_i64().unwrap(),\n        Value::String(_) => 0,\n        Value::Array(v) => v.into_iter().map(|e| sum(e, use_red)).sum(),\n        Value::Object(v) => {\n            let mut max = 0;\n            for v in v.values() {\n                if (v == \"red\") && !use_red {\n                    return 0;\n                }\n                max += sum(v.clone(), use_red);\n            }\n            return max;\n        }\n    }\n}\n\n#[aoc(day11, part1, Serde)]\npub fn part1_serde(input: &str) -> i64 {\n    let a = serde_json::from_str(&input).unwrap();\n    sum(a, true)\n}\n\n```\n\n## Part II\n\nUh oh - the Accounting-Elves have realized that they double-counted everything red.\n\nIgnore any object (and all of its children) which has any property with the value `\"red\"`. Do this only for objects (`{...}`), not arrays (`[...]`).\n\n> [1,2,3] still has a sum of 6.\n>\n> [1,{\"c\":\"red\",\"b\":2},3] now has a sum of 4, because the middle object is ignored.\n>\n> {\"d\":\"red\",\"e\":[1,2,3,4],\"f\":5} now has a sum of 0, because the entire structure is ignored.\n>\n> [1,\"red\",5] has a sum of 6, because \"red\" in an array has no effect.\n\n\n## Solution\n\n```rust\nfn sum(v: Value, use_red: bool) -> i64 {\n    match v {\n        Value::Null => 0,\n        Value::Bool(_) => 0,\n        Value::Number(n) => n.as_i64().unwrap(),\n        Value::String(_) => 0,\n        Value::Array(v) => v.into_iter().map(|e| sum(e, use_red)).sum(),\n        Value::Object(v) => {\n            let mut max = 0;\n            for v in v.values() {\n                if (v == \"red\") && !use_red {\n                    return 0;\n                }\n                max += sum(v.clone(), use_red);\n            }\n            return max;\n        }\n    }\n}\n\n#[aoc(day11, part2, Serde)]\npub fn part2_serde(input: &str) -> i64 {\n    let a = serde_json::from_str(&input).unwrap();\n    sum(a, false)\n}\n```\n","url":"https://deltamaniac.github.io/notes\\17b52896-7604-4e3d-b0b5-f8d18f3258d5.html","relUrl":"notes\\17b52896-7604-4e3d-b0b5-f8d18f3258d5.html"},{"doc":"Day 11","title":"Day 11","hpath":"aoc.2015.d11","content":"# Corporate Policy\n\n## Part I\nSanta's previous password expired, and he needs help choosing a new one.\n\nTo help him remember his new password after the old one expires, Santa has devised a method of coming up with a password based on the previous one. Corporate policy dictates that passwords must be exactly eight lowercase letters (for security reasons), so he finds his new password by incrementing his old password string repeatedly until it is valid.\n\nIncrementing is just like counting with numbers: `xx`, `xy`, `xz`, `ya`, `yb`, and so on. Increase the rightmost letter one step; if it was z, it wraps around to a, and repeat with the next letter to the left until one doesn't wrap around.\n\nUnfortunately for Santa, a new Security-Elf recently started, and he has imposed some additional password requirements:\n\n>Passwords must include one increasing straight of at least three letters, like `abc`, `bcd`, `cde`, and so on, up to `xyz`. They cannot skip letters; `abd` doesn't count.\n>\n>Passwords may not contain the letters `i`, `o`, or `l`, as these letters can be mistaken for other characters and are therefore confusing.\n>\n>Passwords must contain at least two different, non-overlapping pairs of letters, like `aa`, `bb`, or `zz`.\n\nFor example:\n\n>`hijklmmn` meets the first requirement (because it contains the straight `hij`) but fails the second requirement requirement (because it contains `i` and `l`).\n>\n>`abbceffg` meets the third requirement (because it repeats `bb` and `ff`) but fails the first requirement.\n>\n>`abbcegjk` fails the third requirement, because it only has one double letter (`bb`).\n>\n>The next password after `abcdefgh` is `abcdffaa`.\n>\n>The next password after `ghijklmn` is `ghjaabcc`, because you eventually skip all the passwords that start with `ghi...`, since `i` is not allowed.\n\nGiven Santa's current password (your puzzle input), what should his next password be?\n\n## Solution\n```rust\nfn condition_3(string: &str) -> bool {\n    !string.chars().any(|c| match c {\n        'i' | 'o' | 'l' => true,\n        _ => false,\n    })\n}\n\nfn condition_2(string: &str) -> bool {\n    string\n        .as_bytes()\n        .windows(3)\n        .any(|w| w[0] + 1 == w[1] && w[1] + 1 == w[2])\n}\n\nfn condition_1(string: &str) -> bool {\n    let a = string.as_bytes().iter();\n    let b = string.as_bytes()[1..].iter();\n    let mut i = a.zip(b);\n    let mut c = 0;\n    while c < 2 {\n        if let Some((x, y)) = i.next() {\n            if x == y {\n                c += 1;\n                i.next();\n                i.next();\n            }\n        } else {\n            break;\n        }\n    }\n    c >= 2\n}\n\nfn next(string: &str) -> String {\n    let mut result = String::new();\n    for (i, c) in string.chars().rev().enumerate() {\n        match c {\n            'z' => result.push('a'),\n            _ => {\n                result.push(((c as u8) + 1) as char);\n                result.extend(\n                    string\n                        .chars()\n                        .rev()\n                        .skip(i + 1)\n                        .take(string.len() - i)\n                        .collect::<Vec<_>>(),\n                );\n                break;\n            }\n        }\n    }\n    result.chars().rev().collect::<String>()\n}\n\n#[aoc(day11, part1)]\npub fn part1(input: &str) -> String {\n    let mut password = input.to_string();\n\n    while !(condition_1(&password) && condition_3(&password) && condition_2(&password)) {\n        password = next(&password);\n    }\n    password\n}\n```\n## Part II\n\nSanta's password expired again. What's the next one?\n\n```rust\n#[aoc(day11, part2)]\npub fn part2(input: &str) -> String {\n    let mut password = part1(input);\n    password = next(&password);\n    while !(condition_1(&password) && condition_3(&password) && condition_2(&password)) {\n        password = next(&password);\n    }\n    password\n}\n```\n","url":"https://deltamaniac.github.io/notes\\1bd833a4-2735-45bc-80b0-d7fe5e62c96c.html","relUrl":"notes\\1bd833a4-2735-45bc-80b0-d7fe5e62c96c.html"},{"doc":"Day 10","title":"Day 10","hpath":"aoc.2015.d10","content":"\n# Elves Look, Elves Say\n\n## Part I\n\nToday, the Elves are playing a game called look-and-say. They take turns making sequences by reading aloud the previous sequence and using that reading as the next sequence. For example, 211 is read as \"one two, two ones\", which becomes `1221` (`1` `2`, `2` `1`s).\n\nLook-and-say sequences are generated iteratively, using the previous value as input for the next step. For each step, take the previous value, and replace each run of digits (like `111`) with the number of digits (`3`) followed by the digit itself (`1`).\n\nFor example:\n\n>`1` becomes `11` (`1` copy of digit `1`).\n>\n>`11` becomes `21` (`2` copies of digit `1`).\n>\n>`21` becomes `1211` (one `2` followed by one `1`).\n>\n>`1211` becomes `111221` (one `1`, one `2`, and two `1`s).\n>\n>`111221` becomes `312211` (three `1`s, two `2`s, and one `1`).\n\nStarting with the digits in your puzzle input, apply this process 40 times.\n\n What is the length of the result?\n\n## Solution\n\n```rust\n#[aoc(day10, part1)]\npub fn part1(input: &str) -> usize {\n    let mut s = input.to_string();\n    for _ in 0..40 {\n        let mut v: Vec<(u16, char)> = Vec::new();\n        let mut iter = s.chars();\n        let mut curr = (1, iter.next().unwrap());\n        for i in iter {\n            if i != curr.1 {\n                v.push(curr);\n                curr = (1, i);\n            } else {\n                curr.0 += 1;\n            }\n        }\n        v.push(curr);\n        s.clear();\n        for i in v {\n            s.push_str(&i.0.to_string());\n            s.push(i.1)\n        }\n    }\n    s.chars().count()\n}\n```\n## Part II\n\nNeat, right? You might also enjoy hearing John Conway talking about this sequence (that's Conway of Conway's Game of Life fame).\n\nNow, starting again with the digits in your puzzle input, apply this process 50 times. What is the length of the new result?\n\n## Solution\n\n```rust\n#[aoc(day10, part2)]\npub fn part2(input: &str) -> usize {\n    let mut s = input.to_string();\n    for _ in 0..50 {\n        let mut v: Vec<(u16, char)> = Vec::new();\n        let mut iter = s.chars();\n        let mut curr = (1, iter.next().unwrap());\n        for i in iter {\n            if i != curr.1 {\n                v.push(curr);\n                curr = (1, i);\n            } else {\n                curr.0 += 1;\n            }\n        }\n        v.push(curr);\n        s.clear();\n        for i in v {\n            s.push_str(&i.0.to_string());\n            s.push(i.1)\n        }\n    }\n    s.chars().count()\n}\n```\n","url":"https://deltamaniac.github.io/notes\\c326423e-90f9-46ef-a806-85d050741da2.html","relUrl":"notes\\c326423e-90f9-46ef-a806-85d050741da2.html"},{"doc":"Day 1","title":"Day 1","hpath":"aoc.2015.d1","content":"\n# Not Quite Lisp\n\nSanta was hoping for a white Christmas, but his weather machine's \"snow\" function is powered by stars, and he's fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\n\n## Part I\nSanta is trying to deliver presents in a large apartment building, but he can't find the right floor - the directions he got are a little confusing.\n He starts on the ground floor (floor `0`) and then follows the instructions one character at a time.\n\nAn opening parenthesis, `(`, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\n\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\n\nFor example:\n> `(())` and `()()` both result in floor `0`.\n>\n>`(((` and `(()(()(` both result in floor `3`.\n>\n>`))(((((` also results in floor `3`.\n>\n>`())` and `))(` both result in floor `-1` (the first basement\nlevel).\n>\n>`)))` and `)())())` both result in floor `-3`.\n\n\nTo what floor do the instructions take Santa?\n\n## Solution\n\nThe easiest way to solve this problem would be to split the input string into chars and iterate over each character.\n\nAfter that we use the [iterator::fold](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.fold) method of the iterator over the characters.\n\nFor each `(` we increment a sum value by 1 and for ')' we decrement a sum value by 1.\n```rust\n#[aoc(day1, part1)]\npub fn part1(input: &str) -> i32 {\n    input.chars().fold(0, |sum, c| match c {\n        '(' => sum + 1,\n        ')' => sum - 1,\n        _ => unreachable!(),\n    })\n}\n```\n\n## Part II\n\nNow, given the same instructions, find the position of the first character that causes him to enter the basement (floor -1).\n\n The first character in the instructions has position 1, the second character has position 2, and so on.\n\nFor example:\n\n> `)` causes him to enter the basement at character position `1`.\n>\n> `()())` causes him to enter the basement at character position `5`.\n\nWhat is the position of the character that causes Santa to first enter the basement?\n\n## Solution\nThe easiest way to solve this would be be to keep a check if the sum value every becomes less than 0.\n\nThis condition can be easily identified by using the [checked_sub](https://doc.rust-lang.org/std/primitive.isize.html#method.checked_sub)\n```rust\n#[aoc(day1, part2)]\npub fn part2(input: &str) -> usize {\n    let mut sum: u32 = 0;\n    for (i, c) in input.chars().enumerate() {\n        match c {\n            '(' => sum += 1,\n            ')' => {\n                if let Some(s) = sum.checked_sub(1) {\n                    sum = s;\n                } else {\n                    return i + 1;\n                }\n            }\n            _ => unreachable!(),\n        }\n    }\n    unreachable!()\n}\n```\n","url":"https://deltamaniac.github.io/notes\\dcb2143d-1df6-4c9e-9289-cbc76082ace2.html","relUrl":"notes\\dcb2143d-1df6-4c9e-9289-cbc76082ace2.html"},{"doc":"Algos","title":"Algos","hpath":"algos","content":"\n","url":"https://deltamaniac.github.io/notes\\9nJ51NxmVYfRwgZ3.html","relUrl":"notes\\9nJ51NxmVYfRwgZ3.html"},{"doc":"Trees","title":"Trees","hpath":"algos.trees","content":"\n","url":"https://deltamaniac.github.io/notes\\JIWK0RHWBUWKJcKh.html","relUrl":"notes\\JIWK0RHWBUWKJcKh.html"},{"doc":"maxDepth","title":"maxDepth","hpath":"algos.trees.maxDepth","content":"\n# Maximum Depth of Binary Tree\n\nGiven the `root` of a binary tree, return its maximum depth\n\n\n## Binary Tree\n![](/assets/images/2021-07-17-12-08-23.png)\n\n## Solution\n\n### Python\n\n```python\ndef maxDepth(root:TreeNode)-> int:\n    if not root:\n        return 0\n    else:\n        max(self.maxDepth(root.left),self.maxDepth(root.right))+1\n```\n\n### Go\n\n```go\nimport(\n\"math\"\n)\nfunc maxDepth(root *TreeNode) int {\n    if root == nil{\n        return 0\n    }\n    return int(math.Max(float64(maxDepth(root.Left)),float64(maxDepth(root.Right)))) +1\n}\n```\n\n### Rust\n```rust\nfn maxDepth(root:Option<Rc<RefCell<TreeNode>>>>>)-> i32{\n match root {\n            Some(a) => {\n                let l = Solution::max_depth(a.borrow().left.clone());\n                let r = Solution::max_depth(a.borrow().right.clone());\n                return std::cmp::max(l, r) + 1;\n            }\n            None => return 0,\n        }\n}\n```","url":"https://deltamaniac.github.io/notes\\mOU2cIc7wX12zgdN.html","relUrl":"notes\\mOU2cIc7wX12zgdN.html"},{"doc":"Binary","title":"Binary","hpath":"algos.trees.binary","content":"\n","url":"https://deltamaniac.github.io/notes\\gVak3GTPSNXMwcCr.html","relUrl":"notes\\gVak3GTPSNXMwcCr.html"},{"doc":"Binary Tree Traversal","title":"Binary Tree Traversal","hpath":"algos.trees.binary.traversal","content":"# Graph\n![](/assets/images/2021-07-17-12-08-23.png)\n\n# PreOrder\n\n## Root --> Left --> Right\n\n## F B A D C E G I H\n\n## Code\n```python\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\n    if root == None :\n        return []\n    res= []\n    res.append(root.val)\n    if root.left!= None:\n        res = res + self.preorderTraversal(root.left)\n    if root.right!= None:\n        res = res + self.preorderTraversal(root.right)\n    return res\n```\n\n# InOrder\n\n## Left --> Root --> Right\n\n## A B C D E F G I J\n\n## Code\n```python\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\n    if root == None :\n        return []\n    res = []\n    if root.left!= None:\n        res = res + self.inorderTraversal(root.left)\n    res.append(root.val)\n    if root.right!= None:\n        res = res + self.inorderTraversal(root.right)\n    return res\n```\n\n\n# Post Order\n\n## Left --> Right --> Root\n\n## A C E D B H I G F\n\n## Code\n\n```python\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\n    if root == None :\n        return []\n    res= []\n    if root.left!= None:\n        res = res + self.postorderTraversal(root.left)\n    if root.right!= None:\n        res = res + self.postorderTraversal(root.right)\n    res.append(root.val)\n    return res\n```\n\n# Iterative Tree\n\n## Use Stack\n\n1. Push Root to stack\n2. Pop From Stack\n3. Push Popped Item left tree\n4. Push Popped Item right tree\n\n# Level Order\n\n## Use Queue\n\n1. Take Node\n2. Push Children into Queue\n3. Remove From Queue\n4. Go to Step 1\n\n## F, B G, A D I, C E H\n\n## Code\n```python\ndef levelOrder(self, root: TreeNode) -> List[List[int]]:\n    if not root:\n        return []\n    res, temp, queue, flag=[], [], [root], 1\n    while queue:\n        for i in iter(range(len(queue))):\n            ptr = queue.pop(0)\n            temp+=[ptr.val]\n            if ptr.left: queue+=[ptr.left]\n            if ptr.right: queue+=[ptr.right]\n        res+=[temp[::flag]]\n        temp=[]\n        flag = flag*-1\n    return res\n```\n","url":"https://deltamaniac.github.io/notes\\JsznN6pNm49uxnkO.html","relUrl":"notes\\JsznN6pNm49uxnkO.html"},{"doc":"Changelog","title":"Changelog","hpath":"root.changelog","content":"","url":"https://deltamaniac.github.io/notes\\changelog.html","relUrl":"notes\\changelog.html"}]
