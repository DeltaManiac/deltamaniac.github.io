{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"BrainMatter","n":1},"1":{"v":"\n\n![DeltaManiac](https://raw.githubusercontent.com/DeltaManiac/DeltaManiac/main/vault/assets/banner.svg)\n\n- üî≠ I‚Äôm currently playing Destiny 2\n- üå± I‚Äôm currently learning [Rust](https://www.rust-lang.org) at night and [Go](https://golang.org/) at work\n- üì´ How to reach me: [twitter](https://twitter.com/Delta_Maniac)\n- üòÑ Pronouns: He/Him\n<!-- - ‚ö° Fun fact: The banner was provided by [Pushkar Anand](https://github.com/pushkar8723) sourced from [Responsive Cow Jumps Over the Moooooon](https://codepen.io/sdras/pen/doZReX) -->\n<!-- // - üëØ I‚Äôm looking to collaborate on ...\n// - ü§î I‚Äôm looking for help with ...\n// - üí¨ Ask me about ... -->\n","n":0.119}}},{"i":2,"$":{"0":{"v":"Templates","n":1}}},{"i":3,"$":{"0":{"v":"Tis 100 Solution Template","n":0.5},"1":{"v":"## \n\n# Solution\n\n```\n@0\n\n@1\n\n@2\n\n@3\n\n@4\n\n@5\n\n@6\n\n@7\n\n@8\n\n@9\n\n@10\n\n@11\n\n```\n\n# Solution\n\n\n","n":0.5}}},{"i":4,"$":{"0":{"v":"Todo","n":1},"1":{"v":"## ToDo BucketList\n\n- [ ] Headcrab\n  - [ ] ELF\n    - [ ] Thread Local for x86-64\n      <https://akkadia.org/drepper/tls.pdf>\n  - [ ] Dwarf\n    <http://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf>\n  - [x] Cirrus Build Conf\n- [x] Kafka üìñ\n  <https://assets.confluent.io/m/1b509accf21490f0/original/20170707-EB-Confluent_Kafka_Definitive-Guide_Complete.pdf>\n- [x] Distributed Design\n  <https://azure.microsoft.com/mediahandler/files/resourcefiles/designing-distributed-systems/Designing_Distributed_Systems.pdf>\n- [x] Migrate from old blog to new blog\n- [x] Reddit Bot for Youtube PlayList\n- [x] Cloud Events\n- [ ] k8s + Nats.io\n- [ ] Little Man Computer\n  - [ ] WASM Support\n- [x] Advent of Code 2020\n\n","n":0.117}}},{"i":5,"$":{"0":{"v":"Rust","n":1},"1":{"v":"## Rust\n\n## Reddit Bot\n\n[[Vyom Bot|rust.bots.reddit]]\n\n## Kafka\n\n[[Producer|kafka.producer]]\n\n[[Consumer|kafka.consumer]]\n\n## LeetCode\n\n[[MaxDepth|algos.trees.maxDepth#rust]]\n\n# DailyByte\n\n[[algos.dailybyte.d1#rust]]\n\n[[algos.dailybyte.d2#rust]]\n\n[[algos.dailybyte.d3#rust]]\n\n[[algos.dailybyte.d4#rust]]\n\n[[algos.dailybyte.d5#rust]]\n\n[[algos.dailybyte.d6#rust]]\n\n[[algos.dailybyte.d7#rust]]\n\n[[algos.dailybyte.d8#rust]]\n\n[[algos.dailybyte.d9#rust]]\n\n[[algos.dailybyte.d10#rust]]\n\n[[algos.dailybyte.d11#rust]]\n\n[[algos.dailybyte.d12#rust]]\n\n[[algos.dailybyte.d13#rust]]\n\n[[algos.dailybyte.d14#rust]]\n\n[[algos.dailybyte.d15#rust]]\n\n[[algos.dailybyte.d16#rust]]\n\n[[algos.dailybyte.d17#rust]]\n\n[[algos.dailybyte.d18#rust]]\n\n[[algos.dailybyte.d19#rust]]\n\n[[algos.dailybyte.d20#rust]]\n\n[[algos.dailybyte.d21#rust]]\n\n[[algos.dailybyte.d22#rust]]\n\n[[algos.dailybyte.d23#rust]]\n\n[[algos.dailybyte.d24#rust]]\n\n[[algos.dailybyte.d25#rust]]\n\n[[algos.dailybyte.d26#rust]]\n\n[[algos.dailybyte.d27#rust]]\n\n","n":0.354}}},{"i":6,"$":{"0":{"v":"Bots","n":1}}},{"i":7,"$":{"0":{"v":"Reddit","n":1},"1":{"v":"## Vyom\n\nThe surmised version of how to write a Reddit Bot in [[rust]]\n\n# Part I\n\nRecently while browsing [reddit](https://old.reddit.com) I came up on a [post](https://www.reddit.com/r/rust/comments/i1satq/webference_rusty_days_2020_all_recorded_talks/g01rwq8/?context=3) in the [/r/rust](https://old.reddit.com) subreddit which was a link to a YouTube playlist for the Rusty-Days conference, however there was no way I could find the contents of the playlist without going to YouTube on my phone. This was a nuance so I went to YouTube and curated the list.\n\n![](/assets/images/2020-10-11-18-16-48.png)\n\nThis was going to be tiresome if I'd have to do it every time I see a post that links to a YouTube playlist. So here we are writing a bot do this task for everyone. This bot will run on a server somewhere (hopefully forever) and curate playlist info for all the people who avail its service.\n\n# Creating Credentials For Our Bot\n\nIn order to write our bot we first need to get some credentials from reddit so that we can access [reddit apis](https://old.reddit.com/dev/api) programmatically.\n\nFirst we need an application id and secret so that reddit can know our application. We can get this information by going to [preferences/app](https://www.reddit.com/prefs/apps) and clicking `are you a developer? create an app...` button cause **we definitely are.**\n\nReddit lets us choose the type of the app we want to build. The three types of app are :\n\n- Web app: Runs as part of a web service on a server you control. Can keep a secret.\n\n- Installed app: Runs on devices you don't control, such as the user's mobile phone. Cannot keep a secret, and therefore, does not receive one.\n\n- Script app: Runs on hardware you control, such as your own laptop or server. Can keep a secret. Only has access to your account.\n\nMore info about about the apps can be found [here](https://github.com/reddit-archive/reddit/wiki/oauth2-app-types).\n\nWe choose the `script` type, enter a name and description for our bot, and use the dummy url `http://www.example.com/unused/redirect/uri` for the redirect url.\n\n![](/assets/images/2020-10-11-18-17-29.png)\n\nWe have now created the credentials with Client Id : `TjC0s2uTaTHYCg` and Client Secret : `mrkAaWitnXLf_DiRagIRS_33cD8`.\n\n![](/assets/images/2020-10-11-18-18-29.png)\n\n# Using and Storing the credentials\n\nWe can now hard code the credentials in our source code and use like this.\n\n```rust\n# main.rs\n\nstatic  CLIENT_ID:&str=\"TjC0s2uTaTHYCg\";\nstatic  CLIENT_SECRET:&str=\"mrkAaWitnXLf_DiRagIRS_33cD8\";\n\nfn main(){\n    println!(\"Client ID: {}\",CLIENT_ID);\n    println!(\"Client Secret: {}\",CLIENT_SECRET);\n}\n```\n\n```shell\nDeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.08s\n     Running `target/debug/vyom`\nClient ID: SmQ7CzGkKA62yA\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g\n```\n\nThis is a very easy and clear way to handle credentials but it is flawed.\n\n- If we need to change the credentials then we would have to change the code, rebuild the app and restart the app.\n\n- If we decide to share the code with someone or push it github, it will expose our credentials, which can be used to hijack our account and do bad things.\n\nSo lets see if we can fix the first problem, by moving the credentials out of the source code. But where do we put it then ? If you're thinking about environment variables then you're absolutely right. Environment variables are a good place to store such values and they are fairly easy to change.\n\n```rust\n# main.rs\n\nfn main(){\n    match std::env::var(\"CLIENT_ID1\") {\n        Ok(client_id) => println!(\"Client ID: {}\", client_id),\n        Err(e) => panic!(\"Couldn't read CLIENT_ID ({})\", e),\n    };\n    match std::env::var(\"CLIENT_SECRET1\") {\n        Ok(client_secret) => println!(\"Client Secret: {}\", client_secret),\n        Err(e) => panic!(\"Couldn't read CLIENT_SECRET ({})\", e),\n    };\n}\n```\n\nSince our bot wont work without a `client_id` and a `client_secret` we call [panic!](https://doc.rust-lang.org/stable/std/macro.panic.html) so that the application exits with an error.\n\n```shell\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.41s\n     Running `target/debug/vyom`\nthread 'main' panicked at \\'Couldn\\'t read CLIENT_ID (environment variable not found),\nsrc/main.rs:9:19\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n# Set the environment variables\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ export CLIENT_SECRET=UItY35BYBEN_rFVnGVzud9Pig6g\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ export CLIENT_ID=SmQ7CzGkKA62yA\n\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.47s\n     Running `target/debug/vyom`\nClient ID: SmQ7CzGkKA62yA\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g\n```\n\nMost of the time we don't really want to export a lot of environment variables manually. It is exhausting. We could fix this problem by writing a shell script that has all our `export` statements... or we can use [dotenv](https://crates.io/crates/dotenv). Dotenv is a crate that provides us a way to put environment variables in a `.env` file and read them. Dotenv is smart to enough to only read from the file if the Environment Variable is **not set** on the system.\n\nWe first add the `dotenv` dependency to our `Cargo.toml` file.\n\n```toml\n# Cargo.toml\n[package]\nname = \"vyom\"\nversion = \"0.1.0\"\nauthors = [\"DeltaManiac <maxpaynered@gmail.com>\"]\nedition = \"2018\"\n\n[dependencies]\ndotenv_codegen=\"0.15.0\" # dotenv dependency\n```\n\nWe then setup the environment variables in the `.env` file.\n\n```shell\n# .env\nCLIENT_ID=test_123\nCLIENT_SECRET=test_321\nTest=DeezTests\n```\n\nWe finally modify our code to use the `dotenv` crate.\n\n```rust\n# main.rs\n\n#[macro_use]\nextern crate dotenv_codegen;\n\nfn main(){\n    println!(\"Env Not on Sys: {}\",dotenv!(\"Test\"));\n    println!(\"Client ID: {}\",dotenv!(\"CLIENT_ID\"));\n    println!(\"Client Secret: {}\",dotenv!(\"CLIENT_SECRET\"));\n}\n```\n\n```shell\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.08s\n     Running `target/debug/vyom`\nEnv Not on Sys: ss #Value from the .env file\nClient ID: SmQ7CzGkKA62yA #Value from the system\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g #Value from the system\n```\n\n# How will the bot work ?\n\nThe bot will listen to a mention like `/u/VyomBot` and would check if the post is a link to a YouTube playlist or at a later stage if the parent comment of the mention is a YouTube playlist.\n\n# Setting up Reddit\n\nWe can follow these steps to setup reddit for testing/developing this bot\n\n1. Created a new user called [VyomBot](https://old.reddit.com/user/VyomBot) so that the bot can be mentioned via `/u/VyomBot`\n\n2. Registered a new app of `script` type for `/u/VyomBot`\n\n3. Create a new [subreddit](https://old.reddit.com/ur/VyomBot) `/r/VyomBot` as a test play ground.\n\n![](/assets/images/2020-10-11-18-20-37.png)\n\n4. Create a new [post](https://www.reddit.com/r/VyomBot/comments/i6fk15/test_playlist/?) with the link to the playlist.\n\n5. Mention `/u/VyomBot` in the comments.\n\n![](/assets/images/2020-10-11-18-21-13.png)\n\n# Talking to Reddit\n\n## Getting Messages from Inbox\n\nLets start off by querying reddit to see if we have a new mention and printing the message. We will use the [roux](https://crates.io/crates/roux) crate for interacting with the reddit apis.\nDirect quote from the description of the crate\n\n> A simple, asynchronous Reddit API wrapper implemented in Rust.\n\nThis means that we have to use a framework like [tokio](https://crates.io/crates/tokio) to provide the async runtime for our bot.\nLets go about doing that.\n\nAdd the dependencies to our Cargo.toml file.\n\n```toml\n# Cargo.toml\n[package]\nname = \"vyom\"\nversion = \"0.1.0\"\nauthors = [\"DeltaManiac <maxpaynered@gmail.com>\"]\nedition = \"2018\"\n\n[dependencies]\ndotenv_codegen=\"0.15.0\" # dotenv dependency\nroux=\"1.0.0\" # roux dependency\ntokio = {version=\"0.2.22\",features=[\"macros\"]} # tokio dependency and only enable the macro feature\n```\n\nUpdate our code to use the library and call the reddit apis.\n\n```rust\n# main.rs\n\n#[macro_use]\nextern crate dotenv_codegen;\n#[macro_use]\nextern crate log; // Used for logging\nuse roux::Reddit;\n\n#[tokio::main]\nasync fn main() {\n    match Reddit::new(\n        dotenv!(\"VYOM_USERAGENT\"),\n        dotenv!(\"VYOM_CLIENT_ID\"),\n        dotenv!(\"VYOM_CLIENT_SECRET\"),\n    )\n    .username(dotenv!(\"VYOM_USERNAME\"))\n    .password(dotenv!(\"VYOM_PASSWORD\"))\n    .login()\n    .await\n    {   // Try to make a new client with the credentials\n        Ok(client) => match client.inbox().await {\n            // Fetch the inbox of the logged in user\n            Ok(listing) => {\n                println!(\"Message Count {}\", listing.data.children.len());\n                dbg!(listing.data.children.get(0).unwrap());\n            }\n            Err(_) => {\n                error!(\"Failed to fetch messages\");\n            }\n        },\n        Err(e) => panic!(e),\n    }\n}\n\n```\n\nWhen we run the program we get the number of messages we have and the `dbg!` macro shows what the passed in variable which in this case is a `InboxItem` struct, looks like.\n\n```shell\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 3.71s\n     Running `target/debug/vyom`\nMessage Count 5\n[src/main.rs:24] &listing.data.children.get(0).unwrap().data = InboxItem {\n    id: \"g0vfbra\",\n    subject: \"username mention\",\n    was_comment: true,\n    author: Some(\n        \"DeltaManiac\",\n    ),\n    parent_id: Some(\n        \"t3_i6fk15\",\n    ),\n    subreddit_name_prefixed: Some(\n        \"r/VyomBot\",\n    ),\n    new: true,\n    type: \"username_mention\",\n    body: \"/u/VyomBot\",\n    dest: \"VyomBot\",\n    body_html: \"&lt;!-- SC_OFF --&gt;&lt;div class=\\\"md\\\"&gt;&lt;p&gt;&lt;a href=\\\"/u/VyomBot\\\"&gt;/u/VyomBot&lt;/a&gt;&lt;/p&gt;\\n&lt;/div&gt;&lt;!-- SC_ON --&gt;\",\n    name: \"t1_g0vfbra\",\n    created: 1596987973.0,\n    created_utc: 1596959173.0,\n    context: \"/r/VyomBot/comments/i6fk15/test_playlist/g0vfbra/?context=3\",\n}\n```\n\nWe can use the `new` property to identify if this is a message that we had previously read.\nThe type property can be used to determine if the item is a comment or a username mention.\nWe can use this to iterate over the messages retrieved and and determine the messages that we have to reply to.\n\n# Replying to the message\n\nRoux provides us a convenient method aptly name `comment` to reply to the message. Let's go ahead and use this to reply to the message.\n\n```rust\n# main.rs\n\nasync fn main() {\n...\n...\n// Fetch the inbox of the logged in user\n    Ok(listing) => {\n        for message in listing.data.children.iter() {\n            is message unread and of type \"username_mention\"\n            if message.data.new && message.data.r#type == \"username_mention\" {\n                match client\n                    .comment(\n                        \"You have been Noted by Vyom. Please Stand By!\",\n                        &message.data.name.as_str(),\n                    )\n                    .await\n                {\n                    Ok(_) => info!(\"Replied to {}\", message.data.name),\n                    Err(_) => error!(\"Failed to reply to mention\"),\n                };\n            }\n        }\n    }\n...\n...\n```\n\n> Psst.., I'll let you in on something cool. In rust `type` is a reserved keyword. In most programming languages you can use a keyword only as keyword, e.g. you _cannot_ have a variable called `for`. In rust we can use `type` as an attribute of a struct and access it by specifying it as a raw string using the `r#` like `message.data.r#type`\n\nNow that we have written the code lets run it and see what happens..\n\n```shell\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 4.45s\n     Running `target/debug/vyom`\n```\n\nNice! It logged that we replied to the mention. Lets run it again, this time it should not reply to an already replied message as we have read it.\n\n```shell\n[2020-08-09T12:59:25Z INFO  vyom] Replied to t1_g0vfbra\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.10s\n     Running `target/debug/vyom`\n[2020-08-09T12:59:29Z INFO  vyom] Replied to t1_g0vfbra\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.09s\n     Running `target/debug/vyom`\n[2020-08-09T12:59:32Z INFO  vyom] Replied to t1_g0vfbra\n```\n\nDamn!\nIT REPLIED AGAIN!!!üòû\nAnd this is what the subreddit looks like now.\n\n![](/assets/images/2020-10-11-18-22-14.png)\n\nTime to find that pesky bug and get rid of it for good.\n\nLets go to reddit and see what the inbox looks like.\n\n![](/assets/images/2020-10-11-18-22-29.png)\n\nWell, its just as we suspected, when we reply to a mention with the `comment` function it does not change the status of the message. Sifting through the [documentation](https://docs.rs/roux/1.0.0/roux/?search=read) of `roux` we can find a method that marks a message as `read`.\n\nThe place we are at right now reminds of a the poem [The Road Not Taken](https://www.poetryfoundation.org/poems/44272/the-road-not-taken) by Robert Frost. It talks about how the author finds two roads diverging in the wood and he ponders which one to travel upon. I ask you to take a few minutes and read the poem, its beautiful.\n\nI'll be waiting!\n\nOh BTW the code can be found on the `part-I` branch [here](https://github.com/DeltaManiac/VyomBot)\n\n# Part II\n\nIf you had read the poem mentioned in the previous part, you can be pretty sure what we are going to do right now. You Betcha! We are going to go down the Rabbit Hole.\n\nJust as in the poem it would have been easy for us to change the library to something that already has a `mark as read` method like many do and continue on, but like Frost we will take the road not taken and that might make all the difference. üòâ\n\n## Down the Rabbit Hole\n\nWe actually got stumped on the last part because there was no method to mark a message as read in `roux`. This makes one wonder if there isn't such an api for reddit or that `roux` just didn't implement it.\n\nLets head to [reddit api docs](https://www.reddit.com/dev/api) and try our luck.\n\nYep, reddit does have a [`read_message`](https://www.reddit.com/dev/api#POST_api_read_message) api for us to use exactly for this purpose. The api accepts a list of [fullnames](https://www.reddit.com/dev/api#fullnames) with an HTTP POST method.\n\nWhat is the `fullname` for our message ? Its nothing but the `name` parameter of the struct.\n\nNow to fix `roux`, so that we can mark the message as read.\n\nLets clone the [roux source code](https://github.com/halcyonnouveau/roux.rs) into another directory.\n\nSince the `comment` method we used is an api which POSTS the comment data to reddit. Perhaps we can ~~reuse~~, who are we kidding ? We can definitely _copy-paste_ and modify the code to send some data to the `read_message` api.\n\n> While searching for a way to mark a message as read, we came up across another api [`message/unread`](https://www.reddit.com/dev/api#GET_message_unread) which returns only the unread messages from our inbox, so we don't have to filter out on the `new` flag of the response anymore. Yay!\n\n```rust\n# src/me/mod.rs\n...\n/// Get user's submitted posts.\n    pub async fn inbox(&self) -> Result<BasicListing<InboxItem>, RouxError> {\n        Ok(self\n            .get(\"message/inbox\")\n            .await?\n            .json::<BasicListing<InboxItem>>()\n            .await?)\n    }\n\n/** This is our addition **/\n///  Get users unread messages\n    pub async fn unread(&self) -> Result<BasicListing<InboxItem>, RouxError> {\n        Ok(self\n            .get(\"message/unread\")\n            .await?\n            .json::<BasicListing<InboxItem>>()\n            .await?)\n    }\n\n/** This is our addition **/\n/// Mark message as read\n    pub async fn mark_read(&self, ids: &str) -> Result<Response, RouxError> {\n        let form = [(\"id\", ids)];\n        self.post(\"api/read_message\", &form).await\n    }\n\n/** This is our addition **/\n/// Mark messages as unread\n    pub async fn mark_read(&self, ids: &str) -> Result<Response, RouxError> {\n        let form = [(\"id\", ids)];\n        self.post(\"api/unread_message\", &form).await\n    }\n\n    pub async fn comment(&self, text: &str, parent: &str) -> Result<Response, RouxError> {\n        let form = [(\"text\", text), (\"parent\", parent)];\n        self.post(\"api/comment\", &form).await\n    }\n...\n```\n\n> I've submitted a [PR](https://github.com/halcyonnouveau/roux.rs/pull/13) to roux with these changes.\n\nSo all is good and well with the change, but how do we use this changed version with our code ?\n\n`Cargo.toml` is the answer. We can tell `Cargo.toml` to use the code from a directory or from a url for a specified crate. Since we have a the modified source code in our system, we can point to that to get it working.\n\n```toml\n# Cargo.toml\n\n[package]\nname = \"vyom\"\nversion = \"0.1.0\"\nauthors = [\"Harikrishnan Menon <harikrishnan.menon@sap.com>\"]\nedition = \"2018\"\n\n[dependencies]\nroux={path=\"../roux.rs\"} #This points to our local modified copy\n# roux={git = \"https://github.com/DeltaManiac/roux.rs\"} #This points to the modified version on github\ndotenv_codegen=\"0.15.0\"\ntokio = {version=\"0.2.22\", features=[\"macros\"]}\nenv_logger =\"0.7.1\"\nlog = \"0.4.11\"\n```\n\nWhen we build our project now, we can see that it picks up the roux source code from the new path specified by us.\n\n```shell\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo build\n   Compiling roux v1.0.1-alpha.0 (/Users/DeltaManiac/git/rust/roux.rs)\n   Compiling vyom v0.1.0 (/Users/DeltaManiac/git/rust/vyom)\n   Finished dev [unoptimized + debuginfo] target(s) in 6.70s\n```\n\n> If we don't want go through the hassle of doing this, we can point cargo to my fork which has the necessary changes. This is how the code would be in the repository.\n\n## Actually Squashing the Bug\n\nNow that we are back from our exceedingly educating trip down the rabbit hole, lets see how we can finally mark a message as read after we reply to it.\n\n```rust\n# main.rs\n...\n...\n// Fetch only the unread messages form the inbox of the logged in user\nOk(client) => match client.unread().await {\n    Ok(listing) => {\n        for message in listing.data.children.iter() {\n            // We have removed the `new` check\n            if message.data.r#type == \"username_mention\" {\n                match client\n                    .comment(\n                        \"Thank you for standing by while we squished a bug. You shouldn't be seeing this message again!\",\n                        &message.data.name.as_str(),\n                    )\n                    .await\n                {\n                    Ok(_) => {\n                        info!(\"Replied to {}\", message.data.name);\n                        match client.mark_read(message.data.name.as_str()).await {\n                            Ok(_) => info!(\"Marked {} as read\", message.data.name),\n                            Err(_) => {\n                                error!(\"Failed to mark {} as read\", message.data.name)\n                            }\n                        }\n                    }\n                    Err(_) => error!(\"Failed to reply to mention {}\", message.data.name),\n                };\n            }\n        }\n    }\n...\n...\n```\n\nWe have changed the reply text so that we can identify from reddit that it is actually the new reply that is being sent, and we call the `mark_read` method form the modified crate to mark the message as read.\n\nLets run the code and see if it works. Fingers Crossed.\n\n```shell\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n   Compiling vyom v0.1.0\n    Finished dev [unoptimized + debuginfo] target(s) in 4.41s\n     Running `target/debug/vyom`\n[2020-08-09T16:38:11Z INFO  vyom] Replied to t1_g0vfbra\n[2020-08-09T16:38:11Z INFO  vyom] Marked t1_g0vfbra as read\n```\n\nCool, but does it actually mark the message as read? Lets run the program again a couple more times and figure it out.\n\n```shell\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.10s\n     Running `target/debug/vyom`\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.10s\n     Running `target/debug/vyom`\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $\n```\n\nSince there doesn't seem to to be any logs being printed we can confirm that we are not replying again to the message. But it programming and you never know if you're right until you completely verify from reddit side too. Let go take a look at the subreddit.\n\n![](/assets/images/2020-10-11-18-24-11.png)\n\nYep, it has only one comment.\n\n## Extracting the Intel\n\nNow that we have figured out how to respond to comments, lets get to the actual crux of the problem.\n\nWhen a VyomBot gets mentioned where should he look for the Youtube link? There can be many answers to this question like\n\n1. The immediate parent comment of the mention\n2. The title of the post\n3. It could be part of the message sent to VyomBot\n\nThese all seem relevant, but to keep it simple lets start with 2, i.e if the parent is a YouTube playlist link then we fetch the information and post it as a comment.\n\nIn order to get the link of the playlist we are not going to use the roux library but instead handwrite it ourselves. Why you ask ? CAUSE ITS GONNA BE FUN!!\n\n> Note to reader the next part of the code is kind of hacky code and do not follow idiomatic rust. Here be Dragons üêâüêâüêâ\n\n### Constructing the Reddit Post link\n\nWe can use the `context` field of the response which looks like\n\n```json\n{\n...\n...\n    name: \"t1_g0vfbra\",\n    created: 1596987973.0,\n    created_utc: 1596959173.0,\n    context: \"/r/VyomBot/comments/i6fk15/test_playlist/g0vfbra/?context=3\",\n}\n```\n\nto construct the url of the post.\n\nThe first 5 parts `r`, `VyomBot`, `comments`, `i6fk15`, `test_playlist` can be used to for the url to the post.\nLet's do this right now.\n\n```rust\n# main.rs\n...\n if message.data.r#type == \"username_mention\" {\nlet post_url = format!(\n    \"https://www.reddit.com/{}/.json\",\n    message\n        .data\n        .context // /r/VyomBot/comments/i6fk15/test_playlist/g0vfbra/?context=3\n        .trim() // remove any trailing and leading spaces\n        .split('/') // [ \"\", \"r\", \"VyomBot\", \"comments\", \"i6fk15\", \"test_playlist\", \"g0vfbra\", \"?context=3\" ]\n        .skip(1) // [ \"r\", \"VyomBot\", \"comments\", \"i6fk15\", \"test_playlist\", \"g0vfbra\", \"?context=3\" ]\n        .collect::<Vec<&str>>()[0..=4] // Take the first 5 [ \"r\", \"VyomBot\", \"comments\", \"i6fk15\", \"test_playlist\" ]\n        .join(\"/\") // /r/VyomBot/comments/i6fk15/test_playlist/\n    );\n...\n```\n\nWe now have constructed the url `https://www.reddit.com/{}/r/VyomBot/comments/i6fk15/test_playlist/.json`. The `.json` at the end tells reddit to return the JSON formatted and not the HTML page of the post id specified\n\n### Extracting the Playlist ID\n\nIn order to query the url that we crafted above we would be using the [`reqwest`](https://crates.io/crates/reqwest) crate and the [`url`](https://crates.io/crates/url) crate. We fire a GET request to reddit and extract the `url` parameter from the response body which would have our link.\n\nWe then would convert the response body to a dynamic json using the [`serde_json`](https://crates.io/crates/serde_json) crate and then extract the link from the `url` property of the response.\n\nThen the [`url`](https://crates.io/crates/url) crate to parse and extract the playlist id from the YouTube link. For our link\n`https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ` the playlist id is `PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ`.\n\n```toml\n# Cargo.toml\n\n[package]\nname = \"vyom\"\nversion = \"0.1.0\"\nauthors = [\"Harikrishnan Menon <harikrishnan.menon@sap.com>\"]\nedition = \"2018\"\n\n[dependencies]\nroux={path=\"../roux.rs\"} #This points to our local modified copy\n# roux={git = \"https://github.com/DeltaManiac/roux.rs\"} #This points to the modified version on github\ndotenv_codegen=\"0.15.0\"\ntokio = {version=\"0.2.22\", features=[\"macros\"]}\nenv_logger =\"0.7.1\"\nlog = \"0.4.11\"\nreqwest = {version=\"0.10.7\",features=[\"json\"]} // New\nserde_json = \"1.0.57\" // New\nurl = \"2.1.1\"  // New\n\n```\n\n```rust\n# main.rs\n...\n...\n// Make an http request to the post url\nlet playlist_id = match reqwest::get(&post_url).await {\n    // If the response is received convert it in to dynamic json\n    Ok(response) => match response.json::<serde_json::Value>().await {\n        Ok(json) => {\n            // Get json[0][\"data\"][\"children][0][\"url}\n            // NB: DO NOT USE THIS CODE IN PRODUCTION\n            let url = match json\n                .get(0)\n                .unwrap()\n                .get(\"data\")\n                .unwrap()\n                .get(\"children\")\n                .unwrap()\n                .get(0)\n                .unwrap()\n                .get(\"data\")\n                .unwrap()\n                .get(\"url\")\n            {\n                // Parse the youtube url from the string\n                // \"https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\"\n                // after trimming `\"`\n                Some(url) => match url::Url::parse(\n                    &url.to_string().trim_matches('\\\"'),\n                ) {\n                    Ok(url) => {\n                        match (\n                            // From the query parameters\n                            // find the parameter with key \"list\"\n                            url.query_pairs().find(|q| {\n                                q.0 == \"list\"\n                            }),\n                            // Also check if the host is youtube\n                            (url.host_str() == Some(\"youtube.com\")\n                                || url.host_str()\n                                    == Some(\"www.youtube.com\")),\n                        ) {\n                            (Some((_, val)), true) => {\n                                // Return the url\n                                Some(val.into_owned())\n                            }\n                            (_, _) => {\n                                error!(\n                                    \"Couldn't find `list` param in url {} for message : {}\",\n                                    &url.to_string(),\n                                    &message.data.name\n                                );\n                                None\n                            }\n                        }\n                    }\n                    // Error Handling\n...\n\ndbg!(playlist_id);\n...\n...\n```\n\n> A better way to handle the response is to create a struct that mimics the response and just let the `.json()` method of reqwest do the heavy lifting of converting it into rust types. This will help avoid all the calls to `unwrap`.\n\n> The nested matches statements should be replaced by `.and_then()` for a more cleaner and readable code.\n\n```shell\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\nCompiling vyom v0.1.0\nFinished dev [unoptimized + debuginfo] target(s) in 5.09s     Running `target/debug/vyom`\n[src/main.rs:200] \"playlist_id\" = \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\"\n[src/main.rs:200] \"playlist_id\" = \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\"\n```\n\nHooray! We've come a long way since we started, written some atrocious code, contributed to a library and even rolled out our own code instead of using library code to talk to talk to reddit.\n\nI know its getting boring now and we're gonna wrap it up in the next part.\n\nOh BTW the code can be found on the `part-II` branch [here](https://github.com/DeltaManiac/VyomBot)\n\n# Part III\n\nWe've reached the final chapter. The spoils are just ahead of us, lets go grab em.\n\n# Obtaining Credentials\n\nWe need to generate a different set of credentials to talk with YouTube. Lets go do that step by step..\n\n1. Logon to [Google Developer Console](https://console.developer.google.com)\n\n2. Click `Enable Apis and Service`\n   ![](/assets/images/2020-10-11-18-26-54.png)\n\n3. Search for `YouTube Data API v3`\n   ![](/assets/images/2020-10-11-18-27-09.png)\n\n4. Click the `Enable` button to enable the API for our account\n   ![](/assets/images/2020-10-11-18-27-17.png)\n\n5. Click the `Create Credentials` button to start creating credentials for us to use.\n   ![](/assets/images/2020-10-11-18-27-29.png)\n\n6. We need to first describe what kind of credentials have to be generated. Don't worry, just follow the screenshot.\n   ![](/assets/images/2020-10-11-18-27-39.png)\n\n7. We're Done!\n   ![](/assets/images/2020-10-11-18-27-51.png)\n\n# Handling JSON better\n\nIn the last part we used a dynamic JSON to to retrieve the playlist url from Reddit. This time to interact with the YouTube API we wont do that, instead we will one up ourselves and de-serialize the JSON into structs that we define in rust.\n\n> We use [`serde`](https://crates.io/crates/serde) to do handle the heavy lifting of JSON de-serialization\n\nThe response of the YouTube API is a bit more well defined than the Reddit API.\n\n```json\n{\n  \"kind\": \"youtube#playlistItemListResponse\",\n  \"etag\": \"Fij-lGuELswW5Y6HXEJsEVAZ6Xg\",\n  \"nextPageToken\": \"CAUQAA\",\n  \"items\": [\n    {\n      \"kind\": \"youtube#playlistItem\",\n      \"etag\": \"KC_3PIeEyspbfuA_AplI4dv2ITA\",\n      \"id\": \"UExmM3U4TmhvRWlraFRDNXJhZEdybW1xZGtPSy14TURvWi45ODRDNTg0QjA4NkFBNkQy\",\n      \"snippet\": {\n        \"publishedAt\": \"2020-08-05T19:31:06Z\",\n        \"channelId\": \"UC9X86dyEwpbCnpC18qjt33Q\",\n        \"title\": \"Rusty Days 2020 - Hackathon Submissions\",\n        \"description\": \"Rules ‚ñ∫ https://rusty-days.org/hackathon/\\n\\nTeams ‚ñ∫\\narrugginiti https://github.com/Rust-Wroclaw/rd-hack-arrugginiti\\nBox-Team https://github.com/Rust-Wroclaw/rd-hack-Box-Team\\nBrighter3D https://github.com/Rust-Wroclaw/rd-hack-Brighter3D\\nhexyoungs https://github.com/Rust-Wroclaw/rd-hack-hexyoungs\\nLastMinute https://github.com/Rust-Wroclaw/rd-hack-LastMinute\\nplanters https://github.com/Rust-Wroclaw/rd-hack-planters\\n\\nFollow ‚ñ∫\\nFacebook: https://rusty-days.org/facebook\\nTwitch: https://rusty-days.org/twitch\\nTwitter: https://rusty-days.org/twitter\",\n        \"thumbnails\": {\n          \"default\": {\n            \"url\": \"https://i.ytimg.com/vi/QaCvUKrxNLI/default.jpg\",\n            \"width\": 120,\n            \"height\": 90\n          },\n          \"medium\": {\n            \"url\": \"https://i.ytimg.com/vi/QaCvUKrxNLI/mqdefault.jpg\",\n            \"width\": 320,\n            \"height\": 180\n          },\n          \"high\": {\n            \"url\": \"https://i.ytimg.com/vi/QaCvUKrxNLI/hqdefault.jpg\",\n            \"width\": 480,\n            \"height\": 360\n          },\n          \"standard\": {\n            \"url\": \"https://i.ytimg.com/vi/QaCvUKrxNLI/sddefault.jpg\",\n            \"width\": 640,\n            \"height\": 480\n          }\n        },\n        \"channelTitle\": \"Rust Wroc≈Çaw\",\n        \"playlistId\": \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\",\n        \"position\": 0,\n        \"resourceId\": {\n          \"kind\": \"youtube#video\",\n          \"videoId\": \"QaCvUKrxNLI\"\n        }\n      }\n    },\n    {\n      \"kind\": \"youtube#playlistItem\",\n      \"etag\": \"EgGMmoAJ81l2BJFspcg1idaKy-8\",\n      \"id\": \"UExmM3U4TmhvRWlraFRDNXJhZEdybW1xZGtPSy14TURvWi5EMEEwRUY5M0RDRTU3NDJC\",\n      \"snippet\": {\n        \"publishedAt\": \"2020-08-01T12:17:09Z\",\n        \"channelId\": \"UC9X86dyEwpbCnpC18qjt33Q\",\n        \"title\": \"Rusty Days 2020 - Tim McNamara: How 10 open source projects manage unsafe code\",\n        \"description\": \"Agenda ‚ñ∫ https://rusty-days.org/agenda\\nSlides ‚ñ∫https://rusty-days.org/assets/slides/08-how-10-open-source-projects-manage-unsafe-code.pdf\\nPlaylist with all talks ‚ñ∫ https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\\n\\nFollow ‚ñ∫\\nFacebook: https://rusty-days.org/facebook\\nTwitch: https://rusty-days.org/twitch\\nTwitter: https://rusty-days.org/twitter\\n\\nThis video ‚ñ∫\\nIs it safe to use unsafe? Learn why some projects need unsafe code and how projects manage its risks.\\n\\nThis talk will briefly discuss what the unsafe keyword enables and what its risks are. The bulk of time will be spent discussing how projects manage those risks. It finishes by providing recommendations based on that analysis.\\n\\nProjects surveyed include:\\n* Servo (Mozilla)\\n* Fuchsia OS (Google)\\n* fast_rsync (Dropbox)\\n* winrt-rs (Microsoft)\\n* Firecracker (AWS)\\n* Linkerd2\",\n        \"thumbnails\": {\n          \"default\": {\n            \"url\": \"https://i.ytimg.com/vi/9M0NQI5Cp2c/default.jpg\",\n            \"width\": 120,\n            \"height\": 90\n          },\n          \"medium\": {\n            \"url\": \"https://i.ytimg.com/vi/9M0NQI5Cp2c/mqdefault.jpg\",\n            \"width\": 320,\n            \"height\": 180\n          },\n          \"high\": {\n            \"url\": \"https://i.ytimg.com/vi/9M0NQI5Cp2c/hqdefault.jpg\",\n            \"width\": 480,\n            \"height\": 360\n          },\n          \"standard\": {\n            \"url\": \"https://i.ytimg.com/vi/9M0NQI5Cp2c/sddefault.jpg\",\n            \"width\": 640,\n            \"height\": 480\n          },\n          \"maxres\": {\n            \"url\": \"https://i.ytimg.com/vi/9M0NQI5Cp2c/maxresdefault.jpg\",\n            \"width\": 1280,\n            \"height\": 720\n          }\n        },\n        \"channelTitle\": \"Rust Wroc≈Çaw\",\n        \"playlistId\": \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\",\n        \"position\": 1,\n        \"resourceId\": {\n          \"kind\": \"youtube#video\",\n          \"videoId\": \"9M0NQI5Cp2c\"\n        }\n      }\n    },\n    {\n      \"kind\": \"youtube#playlistItem\",\n      \"etag\": \"3gm-0cEUcjfm1v1vgh_3EjS6mJg\",\n      \"id\": \"UExmM3U4TmhvRWlraFRDNXJhZEdybW1xZGtPSy14TURvWi40NzZCMERDMjVEN0RFRThB\",\n      \"snippet\": {\n        \"publishedAt\": \"2020-08-01T12:16:07Z\",\n        \"channelId\": \"UC9X86dyEwpbCnpC18qjt33Q\",\n        \"title\": \"Rusty Days 2020 - Luca Palmieri: Are we observable yet?\",\n        \"description\": \"Agenda ‚ñ∫ https://rusty-days.org/agenda\\nSlides ‚ñ∫https://rusty-days.org/assets/slides/07-are-we-observable-yet.pdf\\nPlaylist with all talks ‚ñ∫ https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\\n\\nFollow ‚ñ∫\\nFacebook: https://rusty-days.org/facebook\\nTwitch: https://rusty-days.org/twitch\\nTwitter: https://rusty-days.org/twitter\\n\\nThis video ‚ñ∫\\nIs Rust ready for mainstream usage in backend development?\\n\\nThere is a lot of buzz around web frameworks while many other (critical!) Day 2 concerns do not get nearly as much attention.\\n\\nWe will discuss observability: do the tools currently available in the Rust ecosystem cover most of your telemetry needs?\\n\\nI will walk you through our journey here at TrueLayer when we built our first production backend system in Rust, Donate Direct.\\n\\nWe will be touching on the state of Rust tooling for logging, metrics and distributed tracing.\",\n        \"thumbnails\": {\n          \"default\": {\n            \"url\": \"https://i.ytimg.com/vi/HtKnLiFwHJM/default.jpg\",\n            \"width\": 120,\n            \"height\": 90\n          },\n          \"medium\": {\n            \"url\": \"https://i.ytimg.com/vi/HtKnLiFwHJM/mqdefault.jpg\",\n            \"width\": 320,\n            \"height\": 180\n          },\n          \"high\": {\n            \"url\": \"https://i.ytimg.com/vi/HtKnLiFwHJM/hqdefault.jpg\",\n            \"width\": 480,\n            \"height\": 360\n          },\n          \"standard\": {\n            \"url\": \"https://i.ytimg.com/vi/HtKnLiFwHJM/sddefault.jpg\",\n            \"width\": 640,\n            \"height\": 480\n          },\n          \"maxres\": {\n            \"url\": \"https://i.ytimg.com/vi/HtKnLiFwHJM/maxresdefault.jpg\",\n            \"width\": 1280,\n            \"height\": 720\n          }\n        },\n        \"channelTitle\": \"Rust Wroc≈Çaw\",\n        \"playlistId\": \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\",\n        \"position\": 2,\n        \"resourceId\": {\n          \"kind\": \"youtube#video\",\n          \"videoId\": \"HtKnLiFwHJM\"\n        }\n      }\n    },\n    {\n      \"kind\": \"youtube#playlistItem\",\n      \"etag\": \"2C9sX2xuTowOxjn0m95AH53JiA4\",\n      \"id\": \"UExmM3U4TmhvRWlraFRDNXJhZEdybW1xZGtPSy14TURvWi5GNjNDRDREMDQxOThCMDQ2\",\n      \"snippet\": {\n        \"publishedAt\": \"2020-07-31T11:28:34Z\",\n        \"channelId\": \"UC9X86dyEwpbCnpC18qjt33Q\",\n        \"title\": \"Rusty Days 2020 - Jan-Erik Rediger: Leveraging Rust to build cross-platform mobile libraries\",\n        \"description\": \"Agenda ‚ñ∫ https://rusty-days.org/agenda\\nSlides ‚ñ∫https://rusty-days.org/assets/slides/06-cross-platform-mobile-libraries.pdf\\nPlaylist with all talks ‚ñ∫ https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\\n\\nFollow ‚ñ∫\\nFacebook: https://rusty-days.org/facebook\\nTwitch: https://rusty-days.org/twitch\\nTwitter: https://rusty-days.org/twitter\\n\\n\\nThis video ‚ñ∫\\nAt Mozilla, Firefox is not the only product we ship. Many others ‚Äî including a variety of smartphone applications, and certainly not just web browsers ‚Äî are built by various teams across the organization. These applications are composed of a multitude of libraries which, when possible, are reused across platforms.\\n\\nIn the past year we used Rust to rebuild one of these libraries: the library powering the telemetry in our mobile applications is now integrated into Android and iOS applications and will soon be powering our Desktop platforms as well.\\n\\nThis talk will showcase how this small team managed to create a cross-platform Rust library, and ship it to a bunch of platforms all at once.\",\n        \"thumbnails\": {\n          \"default\": {\n            \"url\": \"https://i.ytimg.com/vi/j5rczOF7pzg/default.jpg\",\n            \"width\": 120,\n            \"height\": 90\n          },\n          \"medium\": {\n            \"url\": \"https://i.ytimg.com/vi/j5rczOF7pzg/mqdefault.jpg\",\n            \"width\": 320,\n            \"height\": 180\n          },\n          \"high\": {\n            \"url\": \"https://i.ytimg.com/vi/j5rczOF7pzg/hqdefault.jpg\",\n            \"width\": 480,\n            \"height\": 360\n          },\n          \"standard\": {\n            \"url\": \"https://i.ytimg.com/vi/j5rczOF7pzg/sddefault.jpg\",\n            \"width\": 640,\n            \"height\": 480\n          },\n          \"maxres\": {\n            \"url\": \"https://i.ytimg.com/vi/j5rczOF7pzg/maxresdefault.jpg\",\n            \"width\": 1280,\n            \"height\": 720\n          }\n        },\n        \"channelTitle\": \"Rust Wroc≈Çaw\",\n        \"playlistId\": \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\",\n        \"position\": 3,\n        \"resourceId\": {\n          \"kind\": \"youtube#video\",\n          \"videoId\": \"j5rczOF7pzg\"\n        }\n      }\n    },\n    {\n      \"kind\": \"youtube#playlistItem\",\n      \"etag\": \"pB_4gb7ai1HOgVLz8Jx9SJB1P_g\",\n      \"id\": \"UExmM3U4TmhvRWlraFRDNXJhZEdybW1xZGtPSy14TURvWi45NDk1REZENzhEMzU5MDQz\",\n      \"snippet\": {\n        \"publishedAt\": \"2020-07-31T09:06:09Z\",\n        \"channelId\": \"UC9X86dyEwpbCnpC18qjt33Q\",\n        \"title\": \"Rusty Days 2020 -  Nell Shamrell - Harrington: The Rust Borrow Checker - A Deep Dive\",\n        \"description\": \"Agenda ‚ñ∫ https://rusty-days.org/agenda\\nSlides ‚ñ∫https://rusty-days.org/assets/slides/05-the-rust-borrow-checker.pdf\\nPlaylist with all talks ‚ñ∫ https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\\n\\nFollow ‚ñ∫\\nFacebook: https://rusty-days.org/facebook\\nTwitch: https://rusty-days.org/twitch\\nTwitter: https://rusty-days.org/twitter\\n\\nThis video ‚ñ∫\\n\\nThe Rust compiler's borrow checker is critical for ensuring safe Rust code. Even more critical, however, is how the borrow checker provides useful, automated guidance on how to write safe code when the check fails. \\n\\nEarly in your Rust journey, it may feel like you are fighting the borrow checker. Come to this talk to learn how you can transition from fighting the borrow checker to using its guidance to write safer and more powerful code at any experience level. Walk away not only understanding the what and the how of the borrow checker - but why it works the way it does - and why it is so critical to both the technical functionality and philosophy of Rust.\",\n        \"thumbnails\": {\n          \"default\": {\n            \"url\": \"https://i.ytimg.com/vi/knhpe5IUnlE/default.jpg\",\n            \"width\": 120,\n            \"height\": 90\n          },\n          \"medium\": {\n            \"url\": \"https://i.ytimg.com/vi/knhpe5IUnlE/mqdefault.jpg\",\n            \"width\": 320,\n            \"height\": 180\n          },\n          \"high\": {\n            \"url\": \"https://i.ytimg.com/vi/knhpe5IUnlE/hqdefault.jpg\",\n            \"width\": 480,\n            \"height\": 360\n          },\n          \"standard\": {\n            \"url\": \"https://i.ytimg.com/vi/knhpe5IUnlE/sddefault.jpg\",\n            \"width\": 640,\n            \"height\": 480\n          },\n          \"maxres\": {\n            \"url\": \"https://i.ytimg.com/vi/knhpe5IUnlE/maxresdefault.jpg\",\n            \"width\": 1280,\n            \"height\": 720\n          }\n        },\n        \"channelTitle\": \"Rust Wroc≈Çaw\",\n        \"playlistId\": \"PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ\",\n        \"position\": 4,\n        \"resourceId\": {\n          \"kind\": \"youtube#video\",\n          \"videoId\": \"knhpe5IUnlE\"\n        }\n      }\n    }\n  ],\n  \"pageInfo\": {\n    \"totalResults\": 9,\n    \"resultsPerPage\": 5\n  }\n}\n```\n\nThis JSON response can be constructed from simple structs that we can define.\nThe `#[derive(Deserialize)]` helps `serde` understand that it can use this struct to deserialize json into by matching the fields of the struct to those of that in the JSON body.\n\n> `serde` is an amazing library and a bit too vast to explain in this post.\n\n```rust\n# main.rs\n\n#[derive(Debug, Deserialize)]\nstruct Snippet {\n    title: String,\n    position: i32,\n}\n#[derive(Debug, Deserialize)]\nstruct Item {\n    kind: String,\n    snippet: Snippet,\n}\n#[derive(Debug, Deserialize)]\nstruct YoutubeResponse {\n    items: Vec<Item>,\n}\n```\n\nNow that we have defined our struct lets go ahead and call the YouTube API.\n\n```rust\n# main.rs\n\nlet mut reply: String =\n    \"Sorry couldn't find the YouTube Link! :(\".to_string();\n\nif playlist_id.is_some() {\n    // Generate api url\n    let url = format!(\"https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId={}&key={}&maxResults={}\",playlist_id.unwrap(), YT_KEY, YT_MAX_RESULT);\n                        // Fire the API\n    let playlist_items = match reqwest::get(&url).await {\n                        // Try to convert the response to our struct\n        Ok(response) => match response.json::<YoutubeResponse>().await {\n            // Return the array of Item\n            Ok(yt_response) => Some(yt_response.items),\n            Err(e) => {\n                error!(\n                    \"Couldn't parse playlist response for comment {} reason : {}\",\n                        &message.data.name, e\n                            );\n                None\n            }\n        },\n        Err(e) => {\n            error!(\n                \"Couldn't fetch YouTube data for comment {} reason : {}\",\n                &message.data.name, e\n            );\n            None\n        }\n    };\n    //Loop over each item and then create the message.\n    if playlist_items.is_some() {\n        let items = playlist_items.unwrap();\n        if items.len() > 0 {\n            reply = \"Playlist Items: \\n\".to_string();\n            for item in items {\n                reply.push_str(\n                    format!(\"\\n {} \\n\", item.snippet.title).as_str(),\n                )\n            }\n        }\n    }\n}\n```\n\nWe first define `reply` with the string that we want to respond with if we fail to identify the playlist id.\nIf we have a playlistID we then call YouTube API with the key we generated earlier. We then extract the items of the playlist generated our reply text. The code that we have written in the previous part already handles replying to the message.\nLets try it out!\n\n```shell\n(base) DeltaManiac @ ~/git/rust/vyom\n‚îî‚îÄ $ cargo run\n   Compiling vyom v0.1.0\n    Finished dev [unoptimized + debuginfo] target(s) in 5.79s\n     Running `target/debug/vyom`\n[2020-08-11T18:46:46Z INFO  vyom] Replied to t1_g14nya9\n[2020-08-11T18:46:46Z INFO  vyom] Marked t1_g14nya9 as read\n```\n\nAnd on Reddit it looks just as beautiful!\n![](/assets/images/2020-10-11-18-30-04.png)\n\n# Fin\n\nThanks for joining along while we built our first bot :heart:.\nIf this journey has taught you something, feel free to give a shout out!\n\n","n":0.015}}},{"i":8,"$":{"0":{"v":"Python","n":1},"1":{"v":"## DailyByte\n\n[[algos.dailybyte.d1#python]]\n\n[[algos.dailybyte.d2#python]]\n\n[[algos.dailybyte.d3#python]]\n\n[[algos.dailybyte.d4#python]]\n\n[[algos.dailybyte.d5#python]]\n\n[[algos.dailybyte.d6#python]]\n\n[[algos.dailybyte.d7#python]]\n\n[[algos.dailybyte.d8#python]]\n\n[[algos.dailybyte.d9#python]]\n\n[[algos.dailybyte.d10#python]]\n\n[[algos.dailybyte.d11#python]]\n\n[[algos.dailybyte.d12#python]]\n\n[[algos.dailybyte.d13#python]]\n\n[[algos.dailybyte.d14#python]]\n\n[[algos.dailybyte.d15#python]]\n\n[[algos.dailybyte.d16#python]]\n\n[[algos.dailybyte.d17#python]]\n\n[[algos.dailybyte.d18#python]]\n\n[[algos.dailybyte.d19#python]]\n\n[[algos.dailybyte.d20#python]]\n\n[[algos.dailybyte.d21#python]]\n\n[[algos.dailybyte.d22#python]]\n\n[[algos.dailybyte.d23#python]]\n\n[[algos.dailybyte.d24#python]]\n\n[[algos.dailybyte.d25#python]]\n\n[[algos.dailybyte.d26#python]]\n\n[[algos.dailybyte.d27#python]]\n\n","n":0.707}}},{"i":9,"$":{"0":{"v":"Primer","n":1},"1":{"v":"\nInterpreted Language\n\nObject Oriented\n\n## Built Ins\n\n| Class     | Desc                                 | Immutable |\n|-----------|--------------------------------------|-----------|\n| bool      | boolean value                        | True      |\n| int       | integer (arbitrary magnitude)        | True      |\n| float     | floating-point number                | True      |\n| list      | mutable sequence of objects          | False     |\n| tuple     | immutable sequence of objects        | True      |\n| str       | character string                     | True      |\n| set       | unordered set of distinct objects    | False     |\n| frozenset | immutable form of set class          | True      |\n| dict      | associative mapping (aka dictionary) | False     |\n\n## Bool\n\nNumbers evaluate to False if 0\n\nSequences Strings Lists Dicts to False if empty\n\n## int\n\nThe `int()` constructor returns 0 by default\n\nint(3.14) -> 3\n\nint(-123.3) -> -123\n\nint('5442') -> 5442 : Automatic handling of `atoi`\n\nint('lol')  -> ValueError\n\nint('7f',16) -> 127 ->int(strval,base)\n\n## float\n\nfixed-precision representation\n\nSimilar to Double in cpp\n\nThe `float()` constructor returns 0 by default\n\nfloat(2) -> 2.0\n\nfloat('3.14') -> 3.14\n\nfloat('meh') -> ValueError\n\n## Sequence Types\n\n- **list** -> array\n- **tuple** -> immutable list\n- **str** -> immutable sequence of char\n\n### list\n\n- Stores sequence of objects\n- Referential Structure -> stores sequence of references to its elements\n- zero-indexed\n\nThe `list()` constructor produces empty list [ ] by default\n\nThe `list()` constructor will accept any parameter that is of **iterable** type\n\nlist('hello') -> [h,e,l,l,o]\n\n## set and frozenset\n\n- unordered collection of elements without duplicate\n- optimized to check existence of elements -> hashtable\n- accepts only immutable types\n\nThe `set()` constructor produces an empty set\n\nset('hello') -> { h,e,l,o}\n\n## dicts\n\nmapping of distinct keys to associated values\n\n## Operator precedence\n\n| Type                                                   | Symbol                                                                |\n|--------------------------------------------------------|-----------------------------------------------------------------------|\n| member access                                          | expr.member                                                           |\n| function/method calls <br> container subscripts/slices | expr(...) <br> expr[...]                                              |\n| exponentiation                                         | **                                                                    |\n| unary operators                                        | +expr, ‚àíexpr,  ~expr                                              |\n| multiplication, division                               | *, /, //, %                                                           |\n| addition, subtraction                                  | +, ‚àí                                                                  |\n| bitwise shifting                                       | <<, >>                                                                |\n| bitwise-and                                            | &                                                                     |\n| bitwise-xor                                            | ÀÜ                                                                     |\n| bitwise-or                                             | \\|                                                                    |\n| comparisons <br>  containment                          | **is**, **is** **not**, ==, !=, <, <=, >, >= <br> **in**,** not in ** |\n| logical-not                                            | **not** expr                                                          |\n| logical-and                                            | **and**                                                               |\n| logical-or                                             | **or**                                                                |\n| conditional                                            | val1 **if** cond **else** val2                                        |\n| assignments                                            | =, +=, ‚àí=, =, etc                                                     |\n\n## Built-In Functions\n\n| Call Syntax               | Description                                                                                                               |\n|---------------------------|---------------------------------------------------------------------------------------------------------------------------|\n| abs(x)                    | Return the absolute value of a number.                                                                                    |\n| all(iterable)             | Return True if bool(e) is True for each element e.                                                                        |\n| any(iterable)             | Return True if bool(e) is True for at least one element e.                                                                |\n| chr(integer)              | Return a one-character string with the given Unicode code point.                                                          |\n| divmod(x, y)              | Return (x // y, x % y) as tuple, if x and y are integers.                                                                 |\n| hash(obj)                 | Return an integer hash value for the object (see Chapter 10).                                                             |\n| id(obj)                   | Return the unique integer serving as an ‚Äúidentity‚Äù for the object.                                                        |\n| input(prompt)             | Return a string from standard input; the prompt is optional.                                                              |\n| isinstance(obj, cls)      | Determine if obj is an instance of the class (or a subclass).                                                             |\n| iter(iterable)            | Return a new iterator object for the parameter (see Section 1.8).                                                         |\n| len(iterable)             | Return the number of elements in the given iteration.                                                                     |\n| map(f, iter1, iter2, ...) | Return an iterator yielding the result of function calls f(e1, e2, ...) for respective elements e1 ‚ààiter1, e2 ‚ààiter2, ... |\n| max(iterable)             | Return the largest element of the given iteration.                                                                        |\n| max(a, b, c, ...)         | Return the largest of the arguments.                                                                                      |\n| min(iterable)             | Return the smallest element of the given iteration.                                                                       |\n| min(a, b, c, ...)         | Return the smallest of the arguments.                                                                                     |\n| next(iterator)            | Return the next element reported by the iterator (see Section 1.8).                                                       |\n| open(filename, mode)      | Open a file with the given name and access mode.                                                                          |\n| ord(char)                 | Return the Unicode code point of the given character.                                                                     |\n| pow(x, y)                 | Return the value xy (as an integer if x and y are integers);<br> equivalent to x**y.                                      |\n| pow(x, y, z)              | Return the value (xy mod z) as an integer.                                                                                |\n| print(obj1, obj2, ...)    | Print the arguments, with separating spaces and trailing newline.                                                         |\n| range(stop)               | Construct an iteration of values 0, 1, . . . ,  stop ‚àí1.                                                                  |\n| range(start, stop)        | Construct an iteration of values start, start + 1, . . . ,  stop ‚àí1.                                                      |\n| range(start, stop, step)  | Construct an iteration of values start, start + step, start + 2 step, . . .                                               |\n| reversed(sequence)        | Return an iteration of the sequence in reverse.                                                                           |\n| round(x)                  | Return the nearest int value (a tie is broken toward the even value).                                                     |\n| round(x, k)               | Return the value rounded to the nearest 10‚àík (return-type matches x).                                                     |\n| sorted(iterable)          | Return a list containing elements of the iterable in sorted order.                                                        |\n| sum(iterable)             | Return the sum of the elements in the iterable (must be numeric).                                                         |\n| type(obj)                 | Return the class to which the instance obj belongs.                                                                       |\n","n":0.035}}},{"i":10,"$":{"0":{"v":"Object Oriented Programming","n":0.577},"1":{"v":"## Classes\n\n## Sample\n\n```python\nclass CreditCard:\n \"\"\" A CC for consumer \"\"\"\n    def __init__(self,customer,bank,acn,limit):\n        self._customer = customer\n        self._bank = bank\n        self._account = acn\n        self._limit = limit\n\n    def get_customer(self):\n        return self._customer\n\n    def make_payment(self,amount):\n        self.account -= amount\n```\n\n## Special Methods\n\n| Syntax                                   | Special Method                                                          |\n| ---------------------------------------- | ----------------------------------------------------------------------- |\n| a + b                                    | a.\\_\\_add\\\\**(b) or b.\\_\\_radd\\\\**(a)                                   |\n| a - b                                    | a.\\_\\_sub\\\\\\_\\_(b) or b.\\_\\_rsub\\_\\_(a)                                 |\n| a \\* b                                   | a.\\_\\_mul\\_\\_(b) or b.\\_\\_rmul\\_\\_(a)                                   |\n| a / b                                    | a.\\_\\_truediv\\_\\_(b) or b.\\_\\_rtruediv\\_\\_(a)                           |\n| a // b                                   | a.\\_\\_floordiv\\_\\_(b) or b.\\_\\_rfloordiv\\_\\_(a)                         |\n| a % b                                    | a.\\_\\_mod\\_\\_(b) or b.\\_\\_rmod\\_\\_(a)                                   |\n| a \\*\\* b                                 | a.\\_\\_pow\\_\\_(b) or b.\\_\\_rpow\\_\\_(a)                                   |\n| a &lt;&lt; b                             | a.\\_\\_lshift\\_\\_(b) or b.\\_\\_rlshift\\_\\_(a)                             |\n| a >> b                                   | a.\\_\\_rshift\\_\\_(b) or b.\\_\\_rrshift\\_\\_(a)                             |\n| a & b                                    | a.\\_\\_and\\_\\_(b) or b.\\_\\_rand\\_\\_(a)                                   |\n| a ^ b                                    | a.\\_\\_xor\\_\\_(b) or b.\\_\\_rxor\\_\\_(a)                                   |\n| a \\| b                                   | a.\\_\\_or\\_\\_(b) or b.\\_\\_ror\\_\\_(a)                                     |\n| a += b <br> a -= b <br> a \\*= b <br> ... | a.\\_\\_iadd\\_\\_(b) <br> a.\\_\\_isub\\_\\_(b) <br> a.\\_\\_imul\\_\\_(b)<br> ... |\n| +a                                       | a.\\_\\_pos\\_\\_()                                                         |\n| -a                                       | a.\\_\\_neg\\_\\_()                                                         |\n| ~a                                       | a.\\_\\_invert\\_\\_()                                                      |\n| abs(a)                                   | a.\\_\\_abs\\_\\_()                                                         |\n| a &lt; b                                 | a.\\_\\_lt\\_\\_(b)                                                         |\n| a &lt;= b                                | a.\\_\\_le\\_\\_(b)                                                         |\n| a > b                                    | a.\\_\\_gt\\_\\_(b)                                                         |\n| a >= b                                   | a.\\_\\_ge\\_\\_(b)                                                         |\n| a == b                                   | a.\\_\\_eq\\_\\_(b)                                                         |\n| a != b                                   | a.\\_\\_ne\\_\\_(b)                                                         |\n| v in a                                   | a.\\_\\_contains\\_\\_(v)                                                   |\n| a[k]                                     | a.\\_\\_getitem\\_\\_(k)                                                    |\n| a[k]=v                                   | a.\\_\\_setitem\\_\\_(k,v)                                                  |\n| del a[k]                                 | a.\\_\\_delitem\\_\\_(k)                                                    |\n| a(arg1, arg2)                            | a.\\_\\_call\\_\\_(arg1,arg2)                                               |\n| len(a)                                   | a.\\_\\_len\\_\\_()                                                         |\n| hash(a)                                  | a.\\_\\_hash\\_\\_()                                                        |\n| iter(a)                                  | a.\\_\\_iter\\_\\_()                                                        |\n| next(a)                                  | a.\\_\\_next\\_\\_()                                                        |\n| bool(a)                                  | a.\\_\\_bool\\_\\_()                                                        |\n| float(a)                                 | a.\\_\\_float\\_\\_()                                                       |\n| int(a)                                   | a.\\_\\_int\\_\\_()                                                         |\n| repr(a)                                  | a.\\_\\_repr\\_\\_()                                                        |\n| reversed(a)                              | a.\\_\\_reversed\\_\\_()                                                    |\n| str(a)                                   | a.\\_\\_str\\_\\_()                                                         |\n\n## Operator Overloading\n\n```python\nclass Vector:\n\n    def __init__(self,d):\n        self._coords = [0] * d\n\n    def __len__(self):\n        return len(self._coords)\n\n    def __getitem__(self,j):\n        return self._coords[j]\n\n    def __setitem__(self,j,val):\n        self._coords[j] = val\n\n    def __add__(self,other):\n        if len(self) != len(other):\n            raise ValurError('Dimensions must agree')\n        result = Vector(len(self))\n        for j in range(len(self)):\n            result[j] = self[j] + other[j]\n        return result\n\n    def __eq__(self,other):\n        self._coords == other._coords\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __str__(self):\n        return '<' + str(self._coords)[1:-1] +'>'\n\n```\n\n## Iterators\n\n","n":0.054}}},{"i":11,"$":{"0":{"v":"Programming","n":1}}},{"i":12,"$":{"0":{"v":"Web Assembly","n":0.707},"1":{"v":"\n## WASM\n\n- Simple Machine Model \n- Executable Format\n\nTwo formats\n\n    - `.wat` -> [[programming.S-Expressions]] Text format\n\n    - `.wasm` -> Binary Format\n\n`.wat` representation of adding two numbers\n```scheme\n(module\n  (func (export \"addTwo\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    i32.add))\n```\n\n\n## Linear Memory Model Memory\n\nWebAssembly has a very simple memory model. A wasm module has access to a single \"linear memory\", which is essentially a flat array of bytes\n\nWasm cannot access the GC-ed heap memory of JS. However JS can access the Linear Memory of WASM modules as Scalar `ArrayBuffer` type.\n","n":0.107}}},{"i":13,"$":{"0":{"v":"Network","n":1}}},{"i":14,"$":{"0":{"v":"Reliable TCP Streams","n":0.577},"1":{"v":"\n# TCP\n\n**Packet Loss**: Occurs when data fails to reach its destination\n\n**Network Congestion**: Occurs when nodes attempt to send more data over a network connections than the connection can handle which causes nodes to discard the excess packets\n\n**Flow Control**: Adaptation of transfer rate to make sure it transmits data as fast as possible while keeping dropped packets to a minimum\n\n\n### TCP Session\n\nEstablished with a three-way handshake\n\n<pre>\n\n                   CLIENT                      SERVER\n               Dial  |                           | Listen\n                     |                           |\n                     | ----------SYN-----------> |\n                     |                           | Accept\n                     | <-------SYN/ACK---------- |\n        Established  |                           |\n                     | ----------ACK-----------> | Established\n\n</pre>\n\n### Handshake\n\n1. Client sends a packet with the synchronize(SYN) flag to the server which contains client's capabilities and preferred window settings\n\n2. Server responds with both the acknowledgement(ACK) and SYN flag set in the packet\n\n3. Client responds with ac ACK packet to acknowledge the server's SYN packet.\n\n\n#### Acknowledging Receipt of Packets by using Sequence Number\n<pre>\n\n                 CLIENT                             SERVER\n                    |        SYN (Seq = X)            |\n                    |-------------------------------->|\n                    |                                 | Received\n                    |        SYN (Seq = Y)            | Client Seq = X\n                    |<--------------------------------|\n           Received |        ACK (Seq = X+1)          |\n     Server Seq = Y |                                 |\n                    |-------------------------------->|\n                    |        ACK (Seq = Y+1)          |\n                    |                                 |\n</pre>\n\nSequence number is determined by the sender of the message\n\n#### Receive Buffers and Windows Sizes\n\nTCP allows a single ACK packet to acknowledge the receipt of more than one incoming packet.\n\nReceiver must advertise to the sender how much space it have available in its receive buffer before it sends an acknowledgment\n\n**Receive Buffer**: per connection block of memory reserved for incoming data on a network connection\n\n**Window Size**: Information in the ACK packet which is the number of bytes the sender can transmit to the receiver without requiring an acknowledgement\n\n<pre>\n              Client                         Server\n                |                               |\n                |   ACK (Window size = 3072)    |\nAcknowledging   |------------------------------>| Client can Receive 3072 bytes\ndata            |                               |\n                |                               |\n                |         (1024 bytes)          |\n                |<------------------------------|\n                |                               |\n                |         (1024 bytes)          |\n                |<------------------------------|\n                |                               |\n                |         (1024 bytes)          |\nBuffer full     |<------------------------------|\nwith 3072 bytes |                               |\n                |                               |\n                |   ACK (Window size = 2048)    |\nAcknowledging   |------------------------------>| Client can Receive 2048 bytes\ndata            |                               |\n                |         (1024 bytes)          |\n                |<------------------------------|\n                |                               |\n                |         (1024 bytes)          |\nBuffer full     |<------------------------------|\nwith 2048 bytes |                               |\n</pre>\n\n### Termination TCP Sessions\n\n1. Client connections changes from `ESTABLISHED` to `FIN_WAIT_1`\n\n2. Server acknowledges the client's `FIN` and changes its state from `ESTABLISHED` to `CLOSE_WAIT`\n\n3. Server sends it own `FIN` packet changing its state to `LAST_ACK` and waits for final acknowledgement from client\n\n4. The client acknowledges the server's `FIN` and enters `TIME_WAIT` state and sends the final`ACK`\n\n5. The client waits for the the *maximum segment life-time* then changes its connection state to `CLOSED`\n\n<pre>\n              Client                         Server\n                |                               |\n    Established |                               | Established\n                |                               |\n                |           FIN                 |\n    FIN_WAIT_1  |------------------------------>|\n                |           ACK                 | CLOSE_WAIT\n                |<------------------------------|\n    FIN_WAIT_2  |                               |\n                |                               |\n                |                               |\n                |           FIN                 |\n                |<------------------------------| LAST_ACK\n     TIME_WAIT  |           ACK                 |\n                |------------------------------>|\n                |                               | CLOSED\n        CLOSED  |                               |\n</pre>\n\n\n### Handling Less Graceful Terminations\n\nWhen connections are closed/terminated, any connection from the other side of the connection will prompt the closed side of the connection to return  `RST` packet(reset)\n","n":0.045}}},{"i":15,"$":{"0":{"v":"Resource Locating and Traffic Routing","n":0.447},"1":{"v":"\n# Internet Protocol\n\nSet of rules that dictate the format of the data send over a network\n\n## IPv4 Addressing\n\n32-bit numbers as 4 octets\n\n### Network and Host IDs\n\nIPv4 address represents two component : networkID and host ID\n\n**NetworkID**: informs the network devices(routers) responsible for shuttling packets toward their destination about the the next appropriate hop in the transmission\n\n**HostID**: router uses the hostID to deliver data to a specific recipient\n\nFor a 32-bit IPv4 address depending on the network size the networkID is computed and the remaining bits compute the hostID\n\ne.g. in a 16-bit Network the first two octets determine the networkID and the remaining two octets determine the hostID\n\nFor address 192.168.212.056 in a 16-bit network\n\n<pre>\n\n       IPv4 Address\n     ---------------\n     192.168.212.056\n            |\n            |\n192.168.0.0 | 0.0.212.056\n------------|------------\nNetworkID   | HostID\n</pre>\n\n### Subdividing IPv4 Addresses into Subnets\n\n**Subnets**: Nodes that have same NetworkID but unique HostID\n\n**CIDR**: Classless Inter-Domain Routing\n\nIndicate number of bits in the networkID by appending a network prefix for each IP address. It consists of a forward slash and an integer\n\nNetwork IP derived by applying a subnet mask\n\ne.g. 192.168.15.69/16 -> 16 bit network and the first 16 bits are the networkID\n\n\nCIDR Prefix length | Subnet Mask     | Available Networks | Hosts/Network\n-------------------|-----------------|--------------------|--------------\n8                  | 255.0.0.0       | 1                  | 16,777,214\n9                  | 255.128.0.0     | 2                  | 8,388,606\n10                 | 255.192.0.0     | 4                  | 4,194,302\n11                 | 255.224.0.0     | 8                  | 2,097,150\n12                 | 255.240.0.0     | 16                 | 1,048,574\n13                 | 255.248.0.0     | 32                 | 524,286\n14                 | 255.252.0.0     | 64                 | 262,142\n15                 | 255.254.0.0     | 128                | 131,070\n16                 | 255.255.0.0     | 256                | 65,534\n17                 | 255.255.128.0   | 512                | 32,766\n18                 | 255.255.192.0   | 1,024              | 16,382\n19                 | 255.255.224.0   | 2,048              | 8,190\n20                 | 255.255.240.0   | 4,096              | 4,094\n21                 | 255.255.248.0   | 8,192              | 2,046\n22                 | 255.255.252.0   | 16,384             | 1,022\n23                 | 255.255.254.0   | 32,768             | 510\n24                 | 255.255.255.0   | 65,536             | 254\n25                 | 255.255.255.128 | 131,072            | 126\n26                 | 255.255.255.192 | 262,144            | 62\n27                 | 255.255.255.224 | 524,288            | 30\n28                 | 255.255.255.240 | 1,048,576          | 14\n29                 | 255.255.255.248 | 2,097,152          | 6\n30                 | 255.255.255.252 | 4,194,304          | 2\n\n<pre>\ne.g. For address 192.168.1.1/9 the mask is the first 9 bits\n    192  |    168   |   1      |     1\n11000000 | 10101000 | 00000001 | 00000001\n\nMask the first 9 bits\n\n11111111 | 10000000 | 00000000 | 00000000\n 255     |    0     |     0    |     0\n\n Network IP -> Ip Address & Mask\n11000000 | 10101000 | 00000001 | 00000001\n                AND\n11111111 | 10000000 | 00000000 | 00000000\n-------------------------------------------\n11000000 | 10000000 | 00000000 | 00000000\n    192  |     1    |     0    |     0\n\nso the possible IP addresses could be 192.1.0.0 and 192.0.0.0\n</pre>\n\nEach network has 2 reserved host addresses.\n\nThe first Ip address in e.g. 192.168.0.0/16 is 192.168.0.0 is the network address and the last address 192.168.255.255 is the broadcast address\n\n### Allocating Networks that don't break at an Octet Boundary\n\nIpAddr: 192.168.156.97/19\n<pre>\n            192  |    168   |   156    |    97\n        11000000 | 10101000 | 10011100 | 01100001\n\nNetwork ID\n\n    |         19-Bits       |\n    -------------------------\n    11000000 | 10101000 | 10000000 | 00000000\n        192  |   168    |    128   |    0\n\n\nHost ID\n                                 |    13-Bits   |\n                                 ----------------\n        00000000 | 00000000 | 00011100 | 01100001\n           0     |     0    |  28      |   97\n</pre>\n\n### Network Address Translation\n\n**Network Address Translation**: Process that allows numerous nodes to share the same public address\n\nDevices: Firewall, Load Balancer, Router\n\n![](/assets/images/2021-12-23-17-53-46.png)\n\n##### Steps\n\n1. NAT Capable device receives a connection from the client socket 10.0.0.3:50926\n\n2. NAT requests the destination with its own IP 1.2.3.4:50926 and port being mapped to the internal client\n\n3. The response received is then sent to the client\n\n### Unicast, Multicast and Broadcast\n\n**Unicast**: Sending packets from one IP address to another IP address\n\n**Multicast**: Sending a singe message to a group of nodes\n\n**Broadcast**: Concurrently deliver a message to all IP addresses in a network (Achieved via sending messages to the broadcast address of its subnet)\n\n### Resolving MAC Address to a Physical Network Connection\n\nThe MAC address is relevant to only the local network.\n\n\n## IPv6 Addressing\n\n128-bit numbers arranged in colon-separated groups of 16bits(hextets)\n\ne.g. 4d61 : 6e64 : 792c : 2042 : 656e : 2c20 : 4c69 : 6c79\n\n#### Simplifying IPv6\n\nTo simplify an IPv6 address e.g. `fd00:4700:0010:0000:0000:0000:6814:d10`\n\n1. Safely remove all leading zeros in each hextet\n\n    `fd00:4700:10:0:0:0:6814:d103`\n\n2. Replace leftmost group of consecutive zero-valued hextets with double colons\n\n    `00:4700:10::6814:d103`\n\n#### IPv6 Network and Host Addresses\n\n**Network Address**: 0-64Bits\n\n**Global Routing Prefix**: 0-48 bits\n\n**Subnet Id**: 49-64 bits\n\n<pre>\n+------Network Address-----+\n|                          |\n|4d61 : 6e64 : 792c : 2042 : 656e : 2c20 : 4c69 : 6c79|\n|_________GRP_______|      | |                        |\n                    |______| |                        |\n                    SubnetID +-----Interface ID-------+\n</pre>\n\n#### IPv6 Address Categories\n\n##### Unicast\n\nUniquely identifies a node. Enables 1:1 communication\n\n##### Multicast\n\nMulticast addresses represents a group of nodes. Enables 1:n communication\n\n#### Anycast\n\nAnycast addresses represents a group of node listening to the same address.\n","n":0.037}}},{"i":16,"$":{"0":{"v":"Overview","n":1},"1":{"v":"# Intro\n\n**Computer Network** : Connection between two or more devices/nodes that allow each node to share data\n\n# Network Topologies\n\n**Topology** : Organization of nodes in a network\n\n### Point to Point\n\n![](/assets/images/2021-12-22-06-51-39.png)\n\n### Daisy Chain\n\n**Hop**: Intermediate Node between source and destination node\n\n![](/assets/images/2021-12-22-06-52-01.png)\n\n### Bus\n\n![](/assets/images/2021-12-22-06-55-34.png)\n\nMost common in wireless networks\n\n### Ring\n\n![](/assets/images/2021-12-22-06-58-10.png)\n\nTraffic travels in a single direction\n\nSpeed can be limited by slowest node in the network\n\n### Star\n\n![](/assets/images/2021-12-22-07-21-27.png)\n\nMost common in wireless networks\n\nCentral node is mostly a network switch\n\nData can traverse on a single hop\n\n### Mesh\n\n![](/assets/images/2021-12-22-07-27-34.png)\n\n### Hybrid\n\n![](/assets/images/2021-12-22-07-30-29.png)\n\n\n# Open Systems Interconnection Reference Model\n\nOSI Model standardizes networking\n\n**Protocols**: Rules and procedures that determine the format and order of data sent over a network\n\n![](/assets/images/2021-12-22-20-11-06.png)\n\n## Layer 7 - Application\n\nResponsible for identifying hosts and retrieving resources\n\ne.g. Browsers, Torrent Client\n\n## Layer 6 - Presentation\n\nPrepares data for the network layer when data moves down the stack and for application layer when data moves up the stack\n\nFunctions: Encryption/Decryption Encoding\n\n## Layer 5 - Session\n\nManages connection lifecycle between nodes on a network\n\nFunctions: Connection establishment, managing connection timeouts, coordinating the mode of operation and connection termination\n\n## Layer 4 - Transport\n\nControls and coordinates transfer of data between nodes while maintaining the reliability\n\nFunctions: Correcting errors, speed control, chunking data, ack-ing received data\n\n## Layer 3 - Network\n\nTransmits data between nodes without having a direct point to point connection to the remote node\n\nFunctions: Network management protocols for routing, addressing, multicasting and traffic control\n\n## Layer 2 - Data Link\n\nHandles data transfers between two directly connected nodes\n\nFunction: Error detection and Error Correction\n\n## Layer 1 - Physical\n\nConverts bits from the network stack to the physical medium\n\nControls bit rate\n\n# Sending Traffic by Using Data Encapsulation\n\n**Payload**: Data travelling down the stack\n\n**Horizontal Communication**: Communication between client and server on the same layer\n\n![](/assets/images/2021-12-22-21-08-28.png)\n\n![](/assets/images/2021-12-22-21-09-23.png)\n\n# TCP/IP Model\n\n**End-to-End Principle**: Each network segment includes only enough functionality to properly transmit and route bits; all other functionality belongs to the endpoints.\n\n![](/assets/images/2021-12-22-21-30-48.png)\n\n## Application Layer\n\nInteracts directly with software applications\n\nEncompasses three OSI layers\n\nProtocols: FTP, HTTP, SMTP\n\nFunction: DHCP, DNS\n\n## Transport Layer\n\nHandles transfer of data between two node\n\nEnsures data integrity\n\nProtocols: TCP, UDP\n\n## Internet Layer\n\nResponsible for routing packets of data\n\nProtocols: IPv4, IPv6, BGP, ICMP, IGMP, IPsec\n\nFunction: Data Delivery\n\n## Link Layer\n\nARP Translates nodes IP address to MAC address of network interface\n","n":0.054}}},{"i":17,"$":{"0":{"v":"JavaScript","n":1},"1":{"v":"\n# Array Buffer\n\nThe ArrayBuffer object is used to represent a generic, fixed-length raw binary data buffer.\nSynonymous to Byte Buffer\n\n```js\nconst buffer = new ArrayBuffer(8); // 8 Bytes = 8*8bits = 64bits\nconst view = new Int32Array(buffer); // can store 2 elements of 32bit in buffer\nconsole.log(view)\n>    int32Array [ 0, 0 ]\n>      0: 0\n>      1: 0\n>      buffer: ArrayBuffer { byteLength: 8 }\n>      byteLength: 8\n>      byteOffset: 0\n>      length: 2\n>      <prototype>: Int32Array.prototype { ‚Ä¶ }\n\nconst view2 = new Int16Array(buffer); // can store 4 elments of 16bit in buffer\nconsole.log(view2)\n>    int16Array [ 0, 0, 0, 0 ]\n>      0: 0\n>      1: 0\n>      2: 0\n>      3: 0\n>      buffer: ArrayBuffer { byteLength: 8 }\n>      byteLength: 8\n>      byteOffset: 0\n>      length: 4\n>      <prototype>: Int16Array.prototype { ‚Ä¶ }\n```\n\n# Shared Array Buffer\n\nThe SharedArrayBuffer object is used to represent a generic, fixed-length raw binary data buffer, similar to the ArrayBuffer object, but in a way that they can be used to create views on shared memory. A SharedArrayBuffer is not a Transferable Object, unlike an ArrayBuffer which is transferable.","n":0.078}}},{"i":18,"$":{"0":{"v":"S-expressions","n":1},"1":{"v":"\n\nSymbolic Expression\n\nDefined as \n\n1. an atom or\n2. an expression of the form `(x.y)` where `x` and `y` are S-expressions\n\nS-expressions can represent any [[algos.trees.binary]]\n\n\n`(x y z)` => `(x.(y.(z.NIL)))` where NIL is the special end-of-list object","n":0.171}}},{"i":19,"$":{"0":{"v":"Kafka","n":1},"1":{"v":"## Apache Kafka\n\n- pub-sub messaging system\n\n- basic unit --> message =>`{ Body :[u8], Key:[u8]}`\n\n- writes are mainly batch operations => `Vec<Messages>`\n\n- does not track acknowledgments from consumers but allows consumers to use Kafka to track their position (offset) in each partition.\n\n- Schema --> governs structure of message\n  - eg JSON/XML/[Apache Avro](https://avro.apache.org/docs/current/)\n\n- Topics --> collection of messages \"about something same\"\n\n- Topics made of n partitions => Append only queue-like\n    ![](/assets/images/2020-10-11-20-30-05.png)\n\n- Stream => Single topic of data irrespective of partitions\n\n- [[Producer|kafka.producer]]\n  - produce message for a topic, can sometimes specify which partition to store\n\n- [[Consumer|kafka.consumer]]\n  - Reads message\n  - Subscribes 1:n topics\n  - FIFO Read (Queue like)\n  - track of consumed messages via offset\n  - **Ownership** mapping of consumer to partitions\n\n- Consumer Group -> 1 or more consumers that work together to consumer a topic\n\n- Kafka Broker -> Single Kafka server\n  - Receives messages from Producers\n  - Assign offset\n  - Commit to disk\n\n- Kafka Cluster\n\n  - Collection of brokers\n  - **1** automatically elected broker will function as the cluster **controller**\n  - Controller responsibilities\n\n    - administrative operations\n    - assigning partitions to broker\n    - monitor for broker failures\n\n    ![](/assets/images/2020-10-11-20-31-20.png)\n\n- Retention -> Configurable for a period of time or size of topic (GB/MB)\n\n- Kafka : Pitch\n\n  - Multiple Producers x Multiple Topics\n  - Multiple Consumers\n  - Disk Based Retention --> No data loss\n  - Scalable\n  - High Performance\n\n## Starting Kafka on OSX\n\n```shell\n# Start ZooKeeper\n# `zkServer` DOESNT WORK IN TMUX!!!\nzookeeper-server-start /usr/local/etc/kafka/zookeeper.properties & kafka-server-start /usr/local/etc/kafka/server.properties\n\n# Start kafka server\nkafka-server-start.sh /usr/local/etc/kafka/server.properties\n\n# Create a topic\nkafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic temptopic\n\n# Start a producer to temptopic\nkafka-console-producer --broker-list localhost:9092 --topic temptopic\n\n# In another tab start a consumer to temptopic\nkafka-console-producer --broker-list localhost:9092 --topic temptopic --from-beginning\n```\n\n","n":0.06}}},{"i":20,"$":{"0":{"v":"Producer","n":1},"1":{"v":"## Producer\n\nKafka has a binary wire protocol.This means that it is possible for applications to read messages from Kafka or write messages to Kafka simply by sending the correct byte sequences to Kafka‚Äôs network port.\n\nKey Structure is `ProducerRecord`\n\n![](/assets/images/2020-10-11-20-37-00.png)\n\n# Serializer\n\nConverts between wire format and code\n\n[Apache Avro](https://https://avro.apache.org/docs/current)\nDefine a common schema for serialization and deserialization\nStore in schema Registry\nStore schema identifier in produced message\n![](/assets/images/2020-10-11-20-37-15.png)\n\n# Creating a Producer\n\n## In [[rust]]\n\nCrate : [kafka](https://crates.io/crates/kafka)\n\n```rust\n// Producer Code\nuse std::fmt::Write;\nuse std::time::Duration;\nuse kafka::producer::{Producer, Record, RequiredAcks};\n\nlet mut producer = Producer::from_hosts(vec!(\"localhost:9092\".to_owned()))\n.with_ack_timeout(Duration::from_secs(1))\n.with_required_acks(RequiredAcks::One)\n.create()\n.unwrap();\n\nlet mut buf = String::with*capacity(2);\nfor i in 0..10 {\nlet * = write!(&mut buf, \"{}\", i); // some computation of the message data to be sent\nproducer.send(&Record::from_value(\"my-topic\", buf.as_bytes())).unwrap();\nbuf.clear();\n}\n```\n\nCrate : [rdkafka](https://crates.io/crates/rdkafka)\n\n```rust\n sync fn produce(brokers: &str, topic_name: &str) {\n    let producer: &FutureProducer = &ClientConfig::new()\n        .set(\"bootstrap.servers\", brokers)\n        .set(\"message.timeout.ms\", \"5000\")\n        .create()\n        .expect(\"Producer creation error\");\n\n    // This loop is non blocking: all messages will be sent one after the other, without waiting\n    // for the results.\n    let futures = (0..5)\n        .map(|i| async move {\n            // The send operation on the topic returns a future, which will be\n            // completed once the result or failure from Kafka is received.\n            let delivery_status = producer\n                .send(\n                    FutureRecord::to(topic_name)\n                        .payload(&format!(\"Message {}\", i))\n                        .key(&format!(\"Key {}\", i))\n                        .headers(OwnedHeaders::new().add(\"header_key\", \"header_value\")),\n                    Duration::from_secs(0),\n                )\n                .await;\n\n            // This will be executed when the result is received.\n            info!(\"Delivery status for message {} received\", i);\n            delivery_status\n        })\n        .collect::<Vec<_>>();\n\n    // This loop will wait until all delivery statuses have been received.\n    for future in futures {\n        info!(\"Future completed. Result: {:?}\", future.await);\n    }\n}\n\n```\n\nSchema Registry for confluent : <https://github.com/gklijs/schema_registry_converter>\n\nConfluent Write up : <https://www.confluent.io/blog/getting-started-with-rust-and-kafka/>\n\n* * *\n\n## In [[go]]\n\nPackage : [Confluent Inc](https://github.com/confluentinc/confluent-kafka-go)\n\n```golang\nfunc main() {\n\n\tp, err := kafka.NewProducer(&kafka.ConfigMap{\"bootstrap.servers\": \"localhost\"})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdefer p.Close()\n\n\t// Delivery report handler for produced messages\n\tgo func() {\n\t\tfor e := range p.Events() {\n\t\t\tswitch ev := e.(type) {\n\t\t\tcase *kafka.Message:\n\t\t\t\tif ev.TopicPartition.Error != nil {\n\t\t\t\t\tfmt.Printf(\"Delivery failed: %v\\n\", ev.TopicPartition)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"Delivered message to %v\\n\", ev.TopicPartition)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Produce messages to topic (asynchronously)\n\ttopic := \"myTopic\"\n\tfor _, word := range []string{\"Welcome\", \"to\", \"the\", \"Confluent\", \"Kafka\", \"Golang\", \"client\"} {\n\t\tp.Produce(&kafka.Message{\n\t\t\tTopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},\n\t\t\tValue:          []byte(word),\n\t\t}, nil)\n\t}\n\n\t// Wait for message deliveries before shutting down\n\tp.Flush(15 * 1000)\n}\n```\n\nPackage : [SegmentIO](https://github.com/segmentio/kafka-go)\n\n```golang\nfunc producer() {\n\n    topic := \"my-topic\"\n    partition := 0\n\n    conn, _ := kafka.DialLeader(context.Background(), \"tcp\", \"localhost:9092\", topic, partition)\n\n    conn.SetWriteDeadline(time.Now().Add(10*time.Second))\n    conn.WriteMessages(\n    kafka.Message{Value: []byte(\"one!\")},\n    kafka.Message{Value: []byte(\"two!\")},\n    kafka.Message{Value: []byte(\"three!\")},\n    )\n\n    conn.Close()\n}\n```\n\nPackage : [Sarama](https://github.com/Shopify/sarama)\n\n```golang\n//Sync Producer\nfunc newDataCollector(brokerList []string) sarama.SyncProducer {\n\n\t// For the data collector, we are looking for strong consistency semantics.\n\t// Because we don't change the flush settings, sarama will try to produce messages\n\t// as fast as possible to keep latency low.\n\tconfig := sarama.NewConfig()\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll // Wait for all in-sync replicas to ack the message\n\tconfig.Producer.Retry.Max = 10                   // Retry up to 10 times to produce the message\n\tconfig.Producer.Return.Successes = true\n\ttlsConfig := createTlsConfiguration()\n\tif tlsConfig != nil {\n\t\tconfig.Net.TLS.Config = tlsConfig\n\t\tconfig.Net.TLS.Enable = true\n\t}\n\n\t// On the broker side, you may want to change the following settings to get\n\t// stronger consistency guarantees:\n\t// - For your broker, set `unclean.leader.election.enable` to false\n\t// - For the topic, you could increase `min.insync.replicas`.\n\n\tproducer, err := sarama.NewSyncProducer(brokerList, config)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to start Sarama producer:\", err)\n\t}\n\n\treturn producer\n}\n\n// Async Producer\nfunc newAccessLogProducer(brokerList []string) sarama.AsyncProducer {\n\n\t// For the access log, we are looking for AP semantics, with high throughput.\n\t// By creating batches of compressed messages, we reduce network I/O at a cost of more latency.\n\tconfig := sarama.NewConfig()\n\ttlsConfig := createTlsConfiguration()\n\tif tlsConfig != nil {\n\t\tconfig.Net.TLS.Enable = true\n\t\tconfig.Net.TLS.Config = tlsConfig\n\t}\n\tconfig.Producer.RequiredAcks = sarama.WaitForLocal       // Only wait for the leader to ack\n\tconfig.Producer.Compression = sarama.CompressionSnappy   // Compress messages\n\tconfig.Producer.Flush.Frequency = 500 * time.Millisecond // Flush batches every 500ms\n\n\tproducer, err := sarama.NewAsyncProducer(brokerList, config)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to start Sarama producer:\", err)\n\t}\n\n\t// We will just log to STDOUT if we're not able to produce messages.\n\t// Note: messages will only be returned here after all retry attempts are exhausted.\n\tgo func() {\n\t\tfor err := range producer.Errors() {\n\t\t\tlog.Println(\"Failed to write access log entry:\", err)\n\t\t}\n\t}()\n\n\treturn producer\n}\n\ngo func sendMessage(){\n        // Synch\n\t\tpartition, offset, err := s.DataCollector.SendMessage(&sarama.ProducerMessage{\n\t\t\tTopic: \"important\",\n\t\t\tValue: sarama.StringEncoder(r.URL.RawQuery),\n        })\n        // Async\n        s.AccessLogProducer.Input() <- &sarama.ProducerMessage{\n\t\t\tTopic: \"access_log\",\n\t\t\tKey:   sarama.StringEncoder(r.RemoteAddr),\n\t\t\tValue: entry,\n\t\t}\n}\n```\n\n","n":0.04}}},{"i":21,"$":{"0":{"v":"Consumer","n":1},"1":{"v":"## Consumer\n\n- Subscribes to topics and receives message\n\n- Consumer Group -> method of scaling consumption\n\n  - Membership triggered by a `JoinGroup` call\n  - First member is the de-facto group leader\n  - leader assigns partitions to consumers in the consumer group\n  - Membership is maintained by sending _heartbeats_ at intervals regularly to the _group coordinator_\n  - Sent during `poll` and `commit`\n  - missing heartbeats for a period will trigger rebalance as the consumer is thought to be dead\n\n- _Rebalance_ moving partition ownership from one consumer to another\n  - high scalability and availability\n  - creates a short unavailability window\n\n![](/assets/images/2020-10-11-20-47-04.png)\n\n# Creating a Consumer\n\n## In [[Rust|rust]]\n\nCrate : [kafka](https://crates.io/crates/kafka)\n\n```rust\nuse kafka::consumer::{Consumer, FetchOffset, GroupOffsetStorage};\nlet mut consumer =\n   Consumer::from_hosts(vec!(\"localhost:9092\".to_owned()))\n      .with_topic_partitions(\"my-topic\".to_owned(), &[0, 1])\n      .with_fallback_offset(FetchOffset::Earliest)\n      .with_group(\"my-group\".to_owned())\n      .with_offset_storage(GroupOffsetStorage::Kafka)\n      .create()\n      .unwrap();\nloop {\n  for ms in consumer.poll().unwrap().iter() {\n    for m in ms.messages() {\n      println!(\"{:?}\", m);\n    }\n    consumer.consume_messageset(ms);\n  }\n  consumer.commit_consumed().unwrap();\n}\n```\n\nCrate : [rdkafka](https://crates.io/crates/rdkafka)\n\n```rust\nasync fn consume(brokers: &str, group_id: &str, topics: &[&str]) {\n    let context = CustomContext;\n\n    let consumer: LoggingConsumer = ClientConfig::new()\n        .set(\"group.id\", group_id)\n        .set(\"bootstrap.servers\", brokers)\n        .set(\"enable.partition.eof\", \"false\")\n        .set(\"session.timeout.ms\", \"6000\")\n        .set(\"enable.auto.commit\", \"true\")\n        //.set(\"statistics.interval.ms\", \"30000\")\n        //.set(\"auto.offset.reset\", \"smallest\")\n        .set_log_level(RDKafkaLogLevel::Debug)\n        .create_with_context(context)\n        .expect(\"Consumer creation failed\");\n\n    consumer\n        .subscribe(&topics.to_vec())\n        .expect(\"Can't subscribe to specified topics\");\n\n    // consumer.start() returns a stream. The stream can be used ot chain together expensive steps,\n    // such as complex computations on a thread pool or asynchronous IO.\n    let mut message_stream = consumer.start();\n\n    while let Some(message) = message_stream.next().await {\n        match message {\n            Err(e) => warn!(\"Kafka error: {}\", e),\n            Ok(m) => {\n                let payload = match m.payload_view::<str>() {\n                    None => \"\",\n                    Some(Ok(s)) => s,\n                    Some(Err(e)) => {\n                        warn!(\"Error while deserializing message payload: {:?}\", e);\n                        \"\"\n                    }\n                };\n                info!(\"key: '{:?}', payload: '{}', topic: {}, partition: {}, offset: {}, timestamp: {:?}\",\n                      m.key(), payload, m.topic(), m.partition(), m.offset(), m.timestamp());\n                if let Some(headers) = m.headers() {\n                    for i in 0..headers.count() {\n                        let header = headers.get(i).unwrap();\n                        info!(\"  Header {:#?}: {:?}\", header.0, header.1);\n                    }\n                }\n                consumer.commit_message(&m, CommitMode::Async).unwrap();\n            }\n        };\n    }\n}\n```\n\n* * *\n\n## In [[go]]\n\nPackage : [Confluent Inc](https://github.com/confluentinc/confluent-kafka-go)\n\n```golang\nfunc main() {\n\n\tc, err := kafka.NewConsumer(&kafka.ConfigMap{\n\t\t\"bootstrap.servers\": \"localhost\",\n\t\t\"group.id\":          \"myGroup\",\n\t\t\"auto.offset.reset\": \"earliest\",\n\t})\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tc.SubscribeTopics([]string{\"myTopic\", \"^aRegex.*[Tt]opic\"}, nil)\n\n\tfor {\n\t\tmsg, err := c.ReadMessage(-1)\n\t\tif err == nil {\n\t\t\tfmt.Printf(\"Message on %s: %s\\n\", msg.TopicPartition, string(msg.Value))\n\t\t} else {\n\t\t\t// The client will automatically try to recover from all errors.\n\t\t\tfmt.Printf(\"Consumer error: %v (%v)\\n\", err, msg)\n\t\t}\n\t}\n\n\tc.Close()\n}\n```\n\n## Package : [SegmentIO](https://github.com/segmentio/kafka-go)\n\n```golang\nfunc consumer(){\n  r := kafka.NewReader(kafka.ReaderConfig{\n      Brokers:   []string{\"localhost:9092\"},\n      Topic:     \"topic-A\",\n      Partition: 0,\n      MinBytes:  10e3, // 10KB\n      MaxBytes:  10e6, // 10MB\n  })\n  r.SetOffset(42)\n\n  for {\n      m, err := r.ReadMessage(context.Background())\n      if err != nil {\n          break\n      }\n      fmt.Printf(\"message at offset %d: %s = %s\\n\", m.Offset, string(m.Key), string(m.Value))\n  }\n\n  r.Close()\n}\n```\n\nPackage : [Sarama](https://github.com/Shopify/sarama)\n\n```golang\n// ConsumeClaim must start a consumer loop of ConsumerGroupClaim's Messages().\nfunc (consumer *Consumer) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\n\n\t// NOTE:\n\t// Do not move the code below to a goroutine.\n\t// The `ConsumeClaim` itself is called within a goroutine, see:\n\t// https://github.com/Shopify/sarama/blob/master/consumer_group.go#L27-L29\n\tfor message := range claim.Messages() {\n\t\tlog.Printf(\"Message claimed: value = %s, timestamp = %v, topic = %s\", string(message.Value), message.Timestamp, message.Topic)\n\t\tsession.MarkMessage(message, \"\")\n\t}\n\n\treturn nil\n}\n\ngo func() comsumer{\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\t// `Consume` should be called inside an infinite loop, when a\n\t\t\t// server-side rebalance happens, the consumer session will need to be\n\t\t\t// recreated to get the new claims\n\t\t\tif err := client.Consume(ctx, strings.Split(topics, \",\"), &consumer); err != nil {\n\t\t\t\tlog.Panicf(\"Error from consumer: %v\", err)\n\t\t\t}\n\t\t\t// check if context was cancelled, signaling that the consumer should stop\n\t\t\tif ctx.Err() != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconsumer.ready = make(chan bool)\n\t\t}\n\t}()\n\n```\n\n# Commits\n\n- Consumers use kafka to track their position in each partition\n- `commit` act of updating current position in kafka\n- message `__consumer_offsets` topic with the offset for each partition\n- when rebalance each consumer receives a new partition and obtains the latest committed offset from where to start reading\n- Commit Strategy\n\n  - Automatic\n\n    - Done by consumer every 5 seconds configurable\n    - Commits largest offset from `poll`\n    - call to `poll` will always commit the last offset\n    - results in double processing if `rebalance` occurs in between a 5 sec window\n\n  - Commit Current Offset\n\n    - Gives control to the developer\n    - `commitSync` triggers commit of the last offset returned by `poll`\n    - must be called after processing all messages\n    - Synchronous call blocks the application\n    - Auto retry till success of non retry-able failure\n\n  - Asynchronous Commit\n\n    - Fire and forget till we get a callback\n    - Does not auto retry as a later commit request might have latest Offset\n\n  - Async + Sync Commit\n\n    - `CommitAsync` always\n    - Trigger a CommitSync just before exit\n\n","n":0.038}}},{"i":22,"$":{"0":{"v":"Go","n":1},"1":{"v":"## Go\n\n## Kafka\n\n[[Producer|kafka.producer]]\n\n[[Consumer|kafka.consumer]]\n\n# LetCode\n\n[[MaxDepth|algos.trees.maxDepth#go]]\n\n# DailyByte\n\n[[algos.dailybyte.d1#go]]\n\n[[algos.dailybyte.d2#go]]\n\n[[algos.dailybyte.d3#go]]\n\n[[algos.dailybyte.d4#go]]\n\n[[algos.dailybyte.d5#go]]\n\n[[algos.dailybyte.d6#go]]\n\n[[algos.dailybyte.d7#go]]\n\n[[algos.dailybyte.d8#go]]\n\n[[algos.dailybyte.d9#go]]\n\n[[algos.dailybyte.d10#go]]\n\n[[algos.dailybyte.d11#go]]\n\n[[algos.dailybyte.d12#go]]\n\n[[algos.dailybyte.d13#go]]\n\n[[algos.dailybyte.d14#go]]\n\n[[algos.dailybyte.d15#go]]\n\n[[algos.dailybyte.d16#go]]\n\n[[algos.dailybyte.d17#go]]\n\n[[algos.dailybyte.d18#go]]\n\n[[algos.dailybyte.d19#go]]\n\n[[algos.dailybyte.d20#go]]\n\n[[algos.dailybyte.d21#go]]\n\n[[algos.dailybyte.d22#go]]\n\n[[algos.dailybyte.d23#go]]\n\n[[algos.dailybyte.d24#go]]\n\n[[algos.dailybyte.d25#go]]\n\n[[algos.dailybyte.d26#go]]\n\n[[algos.dailybyte.d27#go]]\n\n","n":0.447}}},{"i":23,"$":{"0":{"v":"Framework","n":1}}},{"i":24,"$":{"0":{"v":"Gokit","n":1},"1":{"v":"## Gokit\n\nSpring boot like framework for [[go]]. It has 3 major Components\n\n## Service Layer\n\n- Innermost layer where business logic resides.\n- Modeled as services\n- Oblivious to Endpoint/Transport Layers\n- Can be used by multiple Transports (grpc/json/http)\n\n## Endpoint Layer\n\n- Represents a single RPC Method\n- Service exposed as an Endpoint\n- Endpoint can be exposed by multiple Transports\n\n## Transport Layer\n\n- Exposes various Transports\n  - grpc\n  - http\n\n# Building a `pastebin` clone\n\n## Define a service blueprint interface\n\n```go\n// PbService provides storage capabilities\ntype PbService interface {\n\tCreate(content string, ctx context.Context) (string, error)\n\tDelete(key string, ctx context.Context) (string, error)\n\tGet(key string, ctx context.Context) (string, error)\n}\n```\n\n## Make a new struct to define the PasteBin Service\n\nThis struct is used to group together the functionalities of pastebin service\n\n```go\ntype pbService struct {\n\tmemory map[uuid.UUID]string\n}\n\n// NewPbService make a new PbService\nfunc NewPbService() PbService {\n\treturn pbService{\n\t\tmemory: make(map[uuid.UUID]string),\n\t}\n}\n```\n\n## Implement the PbService Interface on the struct\n\nIn [[go]] we do not have a key word to define that this structs implements a specific interface like the `implements` in Java.\n\nThey way we enforce contracts is by implementing all the methods of the contract interface in our case here its the `PbService` interface.\n\nSince our `NewPbService` method returns the type of `PbService` the go compiler will ensure that `NewPbService` confirms to the `PbService` interface.\n\n```go\n//Create: Here we store the content and return a uuid\nfunc (s pbService) Create(ctx context.Context, content string) (string, error) {\n\tid := uuid.New()\n\ts.memory[id] = content\n\treturn id.String(), nil\n}\n\n//Delete: Here we use the key to find and delete the content stored\nfunc (s pbService) Delete(ctx context.Context, key string) (string, error) {\n\tid, err := uuid.Parse(key)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"Invalid Uuid Format\")\n\t}\n\tdelete(s.memory, id)\n\treturn \"ok\", nil\n}\n\n//Get: Here we use the key to find and return the content stored\nfunc (s pbService) Get(ctx context.Context, key string) (string, error) {\n\tid, err := uuid.Parse(key)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"Invalid Uuid Format\")\n\t}\n\tcontent, exists := s.memory[id]\n\tif exists {\n\t\treturn content, nil\n\t}\n\treturn \"\", errors.New(\"Invalid Uuid\")\n}\n```\n\n## Request and Response\n\nIn Go kit, the primary messaging pattern is RPC.\n\nSo, every method in our interface will be modeled as a remote procedure call. For each method, we define request and response structs, capturing all of the input and output parameters respectively.\n\n### Create Request Response\n\n```go\ntype createPbRequest struct {\n\tcontent string `json:\"content\"`\n}\n\ntype createPbResponse struct {\n\tkey string `json:\"key\"`\n\tErr string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\n}\n```\n\n### Delete Request Response\n\n```go\ntype deletePbRequest struct {\n\tkey string `json:\"key\"`\n}\n\ntype deletePbResponse struct {\n\tstatus string `json:\"status\"`\n\tErr    string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\n}\n```\n\n### Get Request Response\n\n```go\ntype getPbRequest struct {\n\tkey string `json:\"key\"`\n}\n\ntype getPbResponse struct {\n\tcontent string `json:\"content\"`\n\tErr     string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\n}\n```\n\n## Define Endpoints\n\nAn endpoint represents a single RPC, which is a single method in our service.\n\n### Create Endpoint\n\n```go\nfunc createPbEndpoint(svc PbService) endpoint.Endpoint {\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treq := request.(createPbRequest)\n\t\tkey, err := svc.Create(ctx, req.Content)\n\t\tif err != nil {\n\t\t\treturn createPbResponse{key, err.Error()}, nil\n\t\t}\n\t\treturn createPbResponse{key, \"\"}, nil\n\t}\n}\n```\n\n### Delete Endpoint\n\n```go\nfunc deletePbEndpoint(svc PbService) endpoint.Endpoint {\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treq := request.(deletePbRequest)\n\t\tstatus, err := svc.Delete(ctx, req.Key)\n\t\tif err != nil {\n\t\t\treturn deletePbResponse{status, err.Error()}, nil\n\t\t}\n\t\treturn deletePbResponse{status, \"\"}, nil\n\t}\n}\n```\n\n### Get Endpoint\n\n```go\nfunc getPbEndpoint(svc PbService) endpoint.Endpoint {\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treq := request.(getPbRequest)\n\t\tcontent, err := svc.Get(ctx, req.Key)\n\t\tif err != nil {\n\t\t\treturn getPbResponse{content, err.Error()}, nil\n\t\t}\n\t\treturn getPbResponse{content, \"\"}, nil\n\t}\n}\n```\n\n## Define Transport\n\nSince this trivial example used JSON over HTTP we would have to decode the JSON to structs that our service can understand\n\n### Create Requester Decoder\n\n```go\nfunc decodeCreatePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\n\tvar request createPbRequest\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\n\t\treturn nil, err\n\t}\n\treturn request, nil\n}\n```\n\n### Delete Request Decoder\n\n```go\nfunc decodeDeletePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\n\tvar request deletePbRequest\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\n\t\treturn nil, err\n\t}\n\treturn request, nil\n}\n```\n\n### Get Request Decoder\n\n```go\nfunc decodeGetPbRequest(_ context.Context, r *http.Request) (interface{}, error) {\n\tvar request getPbRequest\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\n\t\treturn nil, err\n\t}\n\treturn request, nil\n}\n```\n\n### Response Encoder\n\nThis method would accept an `interface` type and convert it JSON, this allows it to accept `createPbResponse`,`deletePbResponse`,`getPbResponse` as an `interface{}` and encode it as json using the annotations in the struct definition.\n\n```go\nfunc encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {\n\treturn json.NewEncoder(w).Encode(response)\n}\n```\n\n## Main\n\n```go\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/go-kit/kit/endpoint\"\n\t\"github.com/google/uuid\"\n\n\thttptransport \"github.com/go-kit/kit/transport/http\"\n)\n\nfunc main() {\n\tsvc := NewPbService()\n\tcreatePbHandler := httptransport.NewServer(\n\t\tcreatePbEndpoint(svc),\n\t\tdecodeCreatePbRequest,\n\t\tencodeResponse,\n\t)\n\n\tdeletePbHandler := httptransport.NewServer(\n\t\tdeletePbEndpoint(svc),\n\t\tdecodeDeletePbRequest,\n\t\tencodeResponse,\n\t)\n\n\tgetPbHandler := httptransport.NewServer(\n\t\tgetPbEndpoint(svc),\n\t\tdecodeGetPbRequest,\n\t\tencodeResponse,\n\t)\n\n\thttp.Handle(\"/create\", createPbHandler)\n\thttp.Handle(\"/delete\", deletePbHandler)\n\thttp.Handle(\"/get\", getPbHandler)\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```\n\n## Divide and Conquer\n\nAt this point the `main.go` has a lot of code so lets move to different files so that we have separation of concerns.\n\n### `service.go`\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"github.com/google/uuid\"\n)\n\n// PbService provides storage capabilities\ntype PbService interface {\n\tCreate(ctx context.Context, content string) (string, error)\n\tDelete(ctx context.Context, key string) (string, error)\n\tGet(ctx context.Context, key string) (string, error)\n}\n\ntype pbService struct {\n\tmemory map[uuid.UUID]string\n}\n\n// NewPbService make a new PbService\nfunc NewPbService() PbService {\n\treturn pbService{\n\t\tmemory: make(map[uuid.UUID]string),\n\t}\n}\n\n//Create: Here we store the content and return a uuid\nfunc (s pbService) Create(ctx context.Context, content string) (string, error) {\n\tid := uuid.New()\n\ts.memory[id] = content\n\treturn id.String(), nil\n}\n\n//Get: Here we use the key to find and return the content stored\nfunc (s pbService) Get(ctx context.Context, key string) (string, error) {\n\tid, err := uuid.Parse(key)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"Invalid Uuid Format\")\n\t}\n\tcontent, exists := s.memory[id]\n\tif exists {\n\t\treturn content, nil\n\t}\n\treturn \"\", errors.New(\"Invalid Uuid\")\n}\n\n//Delete: Here we use the key to find and delete the content stored\nfunc (s pbService) Delete(ctx context.Context, key string) (string, error) {\n\tid, err := uuid.Parse(key)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"Invalid Uuid Format\")\n\t}\n\tdelete(s.memory, id)\n\treturn \"ok\", nil\n}\n```\n\n### `transport.go`\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/go-kit/kit/endpoint\"\n)\n\ntype createPbRequest struct {\n\tContent string `json:\"content\"`\n}\n\ntype createPbResponse struct {\n\tKey string `json:\"key\"`\n\tErr string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\n}\n\ntype getPbRequest struct {\n\tKey string `json:\"key\"`\n}\n\ntype getPbResponse struct {\n\tContent string `json:\"content\"`\n\tErr     string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\n}\n\ntype deletePbRequest struct {\n\tKey string `json:\"key\"`\n}\n\ntype deletePbResponse struct {\n\tStatus string `json:\"status\"`\n\tErr    string `json:\"err,omitempty\"` // errors don't JSON-marshal, so we use a string\n}\n\nfunc createPbEndpoint(svc PbService) endpoint.Endpoint {\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treq := request.(createPbRequest)\n\t\tkey, err := svc.Create(ctx, req.Content)\n\t\tif err != nil {\n\t\t\treturn createPbResponse{key, err.Error()}, nil\n\t\t}\n\t\treturn createPbResponse{key, \"\"}, nil\n\t}\n}\n\nfunc deletePbEndpoint(svc PbService) endpoint.Endpoint {\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treq := request.(deletePbRequest)\n\t\tstatus, err := svc.Delete(ctx, req.Key)\n\t\tif err != nil {\n\t\t\treturn deletePbResponse{status, err.Error()}, nil\n\t\t}\n\t\treturn deletePbResponse{status, \"\"}, nil\n\t}\n}\n\nfunc getPbEndpoint(svc PbService) endpoint.Endpoint {\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treq := request.(getPbRequest)\n\t\tcontent, err := svc.Get(ctx, req.Key)\n\t\tif err != nil {\n\t\t\treturn getPbResponse{content, err.Error()}, nil\n\t\t}\n\t\treturn getPbResponse{content, \"\"}, nil\n\t}\n}\n\nfunc decodeCreatePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\n\tvar request createPbRequest\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\n\t\treturn nil, err\n\t}\n\treturn request, nil\n}\n\nfunc decodeGetPbRequest(_ context.Context, r *http.Request) (interface{}, error) {\n\tvar request getPbRequest\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\n\t\treturn nil, err\n\t}\n\treturn request, nil\n}\n\nfunc decodeDeletePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\n\tvar request deletePbRequest\n\tif err := json.NewDecoder(r.Body).Decode(&request); err != nil {\n\t\treturn nil, err\n\t}\n\treturn request, nil\n}\n```\n\n### `main.go`\n\n```go\nfunc main() {\n\tsvc := NewPbService()\n\tcreatePbHandler := httptransport.NewServer(\n\t\tcreatePbEndpoint(svc),\n\t\tdecodeCreatePbRequest,\n\t\tencodeResponse,\n\t)\n\n\tdeletePbHandler := httptransport.NewServer(\n\t\tdeletePbEndpoint(svc),\n\t\tdecodeDeletePbRequest,\n\t\tencodeResponse,\n\t)\n\tgetPbHandler := httptransport.NewServer(\n\t\tgetPbEndpoint(svc),\n\t\tdecodeGetPbRequest,\n\t\tencodeResponse,\n\t)\n\thttp.Handle(\"/create\", createPbHandler)\n\thttp.Handle(\"/delete\", deletePbHandler)\n\thttp.Handle(\"/get\", getPbHandler)\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```\n\n## Logging Middleware\n\nAll applications need to log information, this can be enabled by adding a logging middleware that we create in a file called `logging.go`\n\nMiddleware in go-kit work on `Endpoint`\n\nThe interface definition is `type Middleware func(Endpoint) Endpoint`, which means it is a function that takes in an endpoint and returns an endpoint\n\nWe can create the `loggingMiddleware` so that it adheres to the `PbService` by implementing the `Create` `Delete` `Get` methods.\n\n```go\ntype loggingMiddleware struct {\n\tlogger log.Logger\n\tnext   PbService\n}\n```\n\n### Create\n\n```go\nfunc (m loggingMiddleware) Create(ctx context.Context, content string) (output string, err error) {\n\t// This defered function would be invoked just before the retuen statement\n\tdefer func(begin time.Time) {\n\t\tm.logger.Log(\n\t\t\t\"method\", \"CreatePb\",\n\t\t\t\"input\", content,\n\t\t\t\"output\", output,\n\t\t\t\"err\", err,\n\t\t\t\"took\", time.Since(begin),\n\t\t)\n\t}(time.Now())\n\toutput, err = m.next.Create(ctx, content)\n\treturn\n}\n```\n\n### Delete\n\n```go\n func (m loggingMiddleware) Delete(ctx context.Context, key string) (output string, err error) {\n\tdefer func(begin time.Time) {\n\t\tm.logger.Log(\n\t\t\t\"method\", \"DeletePb\",\n\t\t\t\"input\", key,\n\t\t\t\"output\", output,\n\t\t\t\"err\", err,\n\t\t\t\"took\", time.Since(begin),\n\t\t)\n\t}(time.Now())\n\toutput, err = m.next.Delete(ctx, key)\n\treturn\n}\n```\n\n### Get\n\n```go\nfunc (m loggingMiddleware) Get(ctx context.Context, key string) (output string, err error) {\n\tdefer func(begin time.Time) {\n\t\tm.logger.Log(\n\t\t\t\"method\", \"GetPb\",\n\t\t\t\"input\", key,\n\t\t\t\"output\", output,\n\t\t\t\"err\", err,\n\t\t\t\"took\", time.Since(begin),\n\t\t)\n\t}(time.Now())\n\toutput, err = m.next.Get(ctx, key)\n\treturn\n}\n```\n\n## Wiring the Middleware\n\nIn order to wire the middleware in all we have to do is link it up with the service that we have defined\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/go-kit/kit/log\"\n\n\thttptransport \"github.com/go-kit/kit/transport/http\"\n)\n\nfunc main() {\n\t// Use the global logger\n\tlogger := log.NewLogfmtLogger(os.Stderr)\n\tvar svc PbService\n\tsvc = NewPbService()\n\t// Wire the middleware and thats it\n\tsvc = loggingMiddleware{logger, svc}\n\n\tcreatePbHandler := httptransport.NewServer(\n\t\tcreatePbEndpoint(svc),\n\t\tdecodeCreatePbRequest,\n\t\tencodeResponse,\n\t)\n\n\tdeletePbHandler := httptransport.NewServer(\n\t\tdeletePbEndpoint(svc),\n\t\tdecodeDeletePbRequest,\n\t\tencodeResponse,\n\t)\n\n\tgetPbHandler := httptransport.NewServer(\n\t\tgetPbEndpoint(svc),\n\t\tdecodeGetPbRequest,\n\t\tencodeResponse,\n\t)\n\thttp.Handle(\"/create\", createPbHandler)\n\thttp.Handle(\"/delete\", deletePbHandler)\n\thttp.Handle(\"/get\", getPbHandler)\n\tlogger.Log(\"msg\", \"HTTP\", \"addr\", \":8080\")\n\tlogger.Log(\"err\", http.ListenAndServe(\":8080\", nil))\n}\n\nfunc encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {\n\treturn json.NewEncoder(w).Encode(response)\n}\n```\n\n## PasteBin\n\n### Client\n\n```sh\n\n$ curl localhost:8080/create -XPOST -d '{\"content\":\"THIS IS SPARTA\"}'\n\n{\"key\":\"c449250a-d74c-4d23-acbb-6785b0bd822a\"}\n\n$ curl localhost:8080/get -XPOST -d '{\"key\":\"c449250a-d74c-4d23-acbb-6785b0bd822a\"}'\n\n{\"content\":\"THIS IS SPARTA\"}\n\n$ curl localhost:8I00/delete -XPOST -d '{\"key\":\"c449250a-d74c-4d23-acbb-6785b0bd822a\"}'\n\n{\"status\":\"ok\"}\n\n$ curl localhost:8080/get -XPOST -d '{\"key\":\"c449250a-d74c-4d23-acbb-6785b0bd822a\"}'\n\n{\"content\":\"\",\"err\":\"Invalid Uuid\"}\n\n```\n\n### Server\n\n```sh\n$ ./pastebin-II\n\nmsg=HTTP addr=:8080\n\nmethod=CreatePb input=\"THIS IS SPARTA\" output=c449250a-d74c-4d23-acbb-6785b0bd822a err=null took=67.92¬µs\n\nmethod=GetPb input=c449250a-d74c-4d23-acbb-6785b0bd822a output=\"THIS IS SPARTA\" err=null took=1.675¬µs\n\nmethod=DeletePb input=c449250a-d74c-4d23-acbb-6785b0bd822a output=ok err=null took=1.45¬µs\n\nmethod=GetPb input=c449250a-d74c-4d23-acbb-6785b0bd822a output= err=\"Invalid Uuid\" took=803ns\n```\n\n","n":0.027}}},{"i":25,"$":{"0":{"v":"Games","n":1}}},{"i":26,"$":{"0":{"v":"Tis-100","n":1}}},{"i":27,"$":{"0":{"v":"Segment","n":1}}},{"i":28,"$":{"0":{"v":"UNKNOWN","n":1},"1":{"v":"## UNKNOWN\n\n# Solution\n\n```\n@0\n\n@1\n MOV -1  ACC\n SAV\n MOV UP  ACC\nDIV: JLZ OUT\n SUB 27\n SWP\n ADD 1\n SWP\n JMP DIV\nOUT: SWP\n MOV ACC DOWN\n\n@2\n\n@3\n\n@4\n\n@5\n MOV UP  ACC\n MOV ACC DOWN\n MOV ACC RIGHT\n \n@6\nMOV LEFT DOWN\n\n@7\n\n@8\n\n@9\nMOV UP  ACC\nMOV ACC DOWN\nMOV ACC RIGHT\n\n@10\nRST: MOV UP ACC\n SAV\nCMP: SWP\n SAV\n SUB LEFT\n JNZ OUT\n MOV UP    NIL\n MOV RIGHT NIL\n MOV 1     RIGHT\n JMP CMP\nOUT: SWP\n MOV RIGHT DOWN\n MOV -999  RIGHT\n MOV ACC  DOWN\n \n@11\nRUN: MOV ACC LEFT\n ADD LEFT\n JLZ CLR\n JMP RUN\nCLR: MOV 1   ACC\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-13-10-46-05.png)\n\n","n":0.107}}},{"i":29,"$":{"0":{"v":"70601","n":1},"1":{"v":"## Stored Image Decoder\n\n# Solution\n\n```\n@0\n\n@1\n MOV UP ACC\n SWP # COLOR\n MOV UP ACC\n SWP # LENGTH\nLOOP: SWP # COLOR\n MOV ACC DOWN\n SWP # LENGTH\n SUB 1\n JGZ LOOP\n \n@2\n\n@3\n\n@4\n\n@5\n MOV 0 DOWN\n  MOV ACC DOWN\n   SWP\n    MOV 30 ACC\nLOOP: MOV UP DOWN\n SUB 1\n JGZ LOOP\n MOV -1 DOWN\n SWP # ROW\n ADD 1\n \n@6\n\n@7\n\n@8\n\n@9\n MOV UP RIGHT\n \n@10\n MOV LEFT DOWN\n \n@11\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-13-10-43-52.png)\n\n","n":0.123}}},{"i":30,"$":{"0":{"v":"63534","n":1},"1":{"v":"## Segment Sorter\n\n# Solution\n\n```\n@0\n\n@1\nMOV UP DOWN\n\n@2\n\n@3\nREV: MOV DOWN ACC\n MOV ACC LEFT\n JGZ REV\n MOV LEFT NIL\nOUT: MOV LEFT ACC\n MOV ACC DOWN\n JGZ OUT\n \n@4\nGET: MOV RIGHT ACC\nMOV NIL DOWN\n SAV\n SUB DOWN\n JGZ INS\n MOV DOWN RIGHT\n JMP GET\n INS: SWP\n MOV ACC RIGHT\n MOV RIGHT NIL\n MOV DOWN ACC\n MOV ACC RIGHT\n JEZ GET\n MOV RIGHT NIL\n MOV 0 RIGHT\n \n@5\nIN: MOV UP ACC\n JEZ OUT\n SAV\nFWD: SWP\n MOV ACC LEFT\n SAV\n MOV LEFT ACC\n MOV ACC RIGHT\n JGZ FWD\nREV: MOV RIGHT ACC\nJEZ IN\n MOV ACC DOWN\n JMP REV\nOUT: MOV -1 RIGHT\n MOV RIGHT NIL\n \n@6\nRST: MOV 0 UP\nIN: MOV LEFT ACC\n JGZ FWD\n JLZ OUT\nREV: MOV UP ACC\n MOV ACC LEFT\n JGZ REV\n JMP RST\nFWD: MOV ACC UP\n JMP IN\nOUT: MOV ACC DOWN\n MOV DOWN LEFT\n \n@7\nREV: MOV DOWN ACC\n MOV ACC UP\n JGZ REV\nOUT: MOV UP ACC\n MOV ACC DOWN\n JGZ OUT\n \n@8\nRST: MOV 0 RIGHT\nLOOP: MOV UP NIL\n MOV RIGHT ACC\n MOV ACC UP\n MOV ACC UP\n JGZ LOOP\n \n@9\n\n@10\n MOV UP NIL\nREV: MOV LEFT ACC\n MOV ACC RIGHT\n JGZ REV\nOUT: MOV RIGHT ACC\n MOV ACC DOWN\n JGZ OUT\n MOV 0 LEFT\n MOV NIL UP\n \n@11\nREV: MOV LEFT ACC\n MOV ACC UP\n JGZ REV\nOUT: MOV UP ACC\n MOV ACC LEFT\n JGZ OUT\n \n```\n\n# Solution\n\n![](/assets/images/2022-11-13-10-41-33.png)","n":0.069}}},{"i":31,"$":{"0":{"v":"62711","n":1},"1":{"v":"## Sequence Indexer\n\n# Solution\n\n```\n@0\nMOV UP    ACC\nJGZ B\nSWP\nMOV 0     RIGHT\nADD 1\nMOV ACC   DOWN\nA: JMP A\nB: MOV ACC   RIGHT\nSWP\nADD 1\nSAV\n\n@1\n\n@2\nMOV UP    DOWN\n\n@3\n\n@4\nMOV UP    RIGHT\n\n@5\n   MOV LEFT  ACC\n   SAV\nB: MOV UP    DOWN\n   SUB 1\n   JGZ B\nC: MOV DOWN  ACC\nMOV ACC   RIGHT\n   MOV ACC   UP\n   JGZ C\n   SWP\n   SAV\n   JMP B\n   \n@6\n  MOV UP    ACC\n   JEZ B\nA: MOV LEFT  NIL\n   SUB 1\n   JGZ A\nB: MOV LEFT  DOWN\nC: MOV LEFT  ACC\n   JGZ C\n   \n@7\n\n@8\n\n@9\nMOV UP    DOWN\n\n@10\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-13-10-38-24.png)","n":0.118}}},{"i":32,"$":{"0":{"v":"61212","n":1},"1":{"v":"## Signal Divider\n\n# Solution\n\n```\n@0\n_: JRO RIGHT\nADD 8\nJMP _\nADD 4\nMOV ACC DOWN\nMOV NIL ACC\n\n@1\nMOV UP ACC\n_: SAV\nMOV 1 RIGHT\nSUB RIGHT\nJLZ DIV8\nMOV 1 LEFT\nJMP _\nDIV8: MOV 3 RIGHT\nADD RIGHT\nJLZ ENDSQ\nMOV 3 LEFT\nJMP E\nENDSQ:SWP\nMOV 4 LEFT\nE:MOV ACC DOWN\n\n@2\nMOV UP ACC\nMOV ACC RIGHT\nADD ACC\nADD ACC\nSAV\nADD ACC\n_: JRO LEFT\nMOV ACC LEFT\nJMP _\nSWP\nMOV ACC LEFT\n\n@3\nMOV LEFT ACC\nMOV DOWN NIL\nMOV ACC DOWN\n\n@4\n\n@5\nMOV UP ACC\n_: SAV\nMOV 1 RIGHT\nSUB RIGHT\nJLZ DIV8\nMOV 1 DOWN\nJMP _\nDIV8: MOV 3 RIGHT\nADD RIGHT\nJLZ ENDSQ\nMOV 3 DOWN\nJMP E\nENDSQ:SWP\nMOV 4 DOWN\nE:MOV ACC DOWN\n\n@6\nMOV -1 RIGHT\nNOP\nNOP\nMOV RIGHT ACC\nSAV\nADD ACC\n_: JRO LEFT\nMOV ACC LEFT\nJMP _\nSWP\nMOV ACC LEFT\n\n@7\n\n@8\nMOV UP RIGHT\n\n@9\nMOV LEFT ACC\n_: JRO UP\nADD 2\nJMP _\nADD 1\nMOV ACC DOWN\nMOV UP RIGHT\n\n@10\nMOV LEFT DOWN\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-13-10-35-03.png)","n":0.098}}},{"i":33,"$":{"0":{"v":"6009","n":1},"1":{"v":"## Signal Window Filter\n\n# Solution\n\n```\n@0\n\n@1\nMOV UP DOWN\n\n@2\nMOV 0 RIGHT\nMOV 0 RIGHT\nMOV 0 RIGHT\nMOV 0 RIGHT\nMOV 0 RIGHT\nHLT: JMP HLT\n\n@3\n\n@4\n\n@5\nMOV RIGHT DOWN\nMOV UP ACC\nMOV ACC RIGHT\nMOV ACC DOWN\n\n@6\nMOV RIGHT DOWN\nMOV RIGHT LEFT\nMOV LEFT  ACC\nMOV ACC   RIGHT\nMOV ACC   DOWN\n\n@7\nMOV UP   LEFT #-5\nMOV UP   DOWN #-4\nMOV UP   ACC  #-3\nMOV ACC  LEFT\nMOV ACC  DOWN\nMOV UP   DOWN #-2\nMOV UP   DOWN #-1\nMOV LEFT UP # 0\nMOV DOWN UP\nMOV DOWN UP\nMOV DOWN UP\nMOV DOWN UP\n\n@8\n\n@9\nSUB UP\nADD UP\nMOV ACC DOWN\n\n@10\nSUB UP\nADD UP\nMOV ACC DOWN\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-13-10-32-25.png)\n","n":0.114}}},{"i":34,"$":{"0":{"v":"53897","n":1},"1":{"v":"## Histogram Viewer\n\n# Solution\n\n```\n@0\n\n@1\nMOV UP DOWN\n\n@2\n\n@3\n\n@4\n\n@5\nMOV UP DOWN\n\n@6\n\n@7\n\n@8\n\n@9\nMOV UP RIGHT\n\n@10\nDY: MOV LEFT ACC\nX: SWP\n MOV ACC DOWN\n SWP\n NEG\n ADD 18\nY: MOV ACC DOWN\n MOV 3 DOWN\n MOV -1 DOWN\n NEG\n ADD 17\n JGZ X\n SWP\n ADD 1\n SAV\n \n@11\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-13-10-28-29.png)","n":0.156}}},{"i":35,"$":{"0":{"v":"52544","n":1},"1":{"v":"## Exposure Mask Viewer\n\n# Solution\n\n```\n@0\n\n@1\n MOV UP RIGHT\n\n@2\nX0: MOV LEFT DOWN\nY0: MOV LEFT ACC\n SAV\nDX: MOV LEFT DOWN\nDY: MOV LEFT ACC\nLOOP: SWP\nY: MOV ACC DOWN\n ADD 1\n SWP\n MOV ACC DOWN\n SUB 1\n JGZ LOOP\n \n@3\n\n@4\n\n@5\n\n@6\nINIT: MOV UP ACC\n SAV\n MOV UP ACC\n SUB 6\n NEG\n SWP\nX0: MOV ACC DOWN\nY:  MOV UP DOWN\n SWP\nDX: MOV ACC DOWN\n SWP\n JRO UP\n JMP INIT\n JMP X0\n \n@7\n\n@8\n\n@9\n\n@10\nX0: MOV UP DOWN\nY:  MOV UP DOWN\nMOV 3 DOWN\nDX: JRO UP\n5:  MOV 3 DOWN\n4:  MOV 3 DOWN\n3:  MOV 3 DOWN\n2:  MOV 3 DOWN\n1:  MOV -1 DOWN\n\n@11\n\n```\n\n# Solution\n![](/assets/images/2022-11-13-08-12-42.png)\n\n","n":0.105}}},{"i":36,"$":{"0":{"v":"51781","n":1},"1":{"v":"## Image Test Pattern 2\n\n# Solution\n\n```\n@0\n\n@1\n\n@2\n\n@3\n\n@4\n\n@5\n\n@6\n\n@7\n\n@8\n\n@9\n\n@10\nST: MOV ACC,DOWN\nSWP\nMOV ACC DOWN\nMOV 3,DOWN\nMOV -1,DOWN\nSWP\nSUB 27\nJGZ NX\nADD 29\nJMP ST\n\nNX: SUB,2\nSWP\nADD 1\nSWP\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-12-22-48-44.png)","n":0.229}}},{"i":37,"$":{"0":{"v":"50370","n":1},"1":{"v":"## Image Test Pattern 1\n\n# Solution\n\n```\n@0\n\n@1\n\n@2\n\n@3\n\n@4\n\n@5\n\n@6\n\n@7\n\n@8\n\n@9\n\n@10\nCOL: \nMOV 0,DOWN\nROW: \nMOV ACC,DOWN\nMOV 30,ACC\nPXL: \nMOV 3,DOWN\nSUB 1\nJNZ PXL\nEND: \nMOV -1,DOWN\nSWP\nADD 1\nSAV\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-12-22-45-20.png)","n":0.229}}},{"i":38,"$":{"0":{"v":"43786","n":1},"1":{"v":"## Signal Multiplier\n\n# Solution\n\n```\n@0\n\n@1\nMOV UP,ACC\nMOV ACC,RIGHT\nMOV ACC,RIGHT\n\n@2\nIN: \nMOV UP,ACC\nSAV\nSUB LEFT\nJGZ A>B\nB>A:\nSWP\nMOV LEFT,DOWN\nMOV ACC,DOWN\nJMP IN\nA>B:\nSWP\nMOV ACC,DOWN\nMOV LEFT,DOWN\n\n@3\n\n@4\n\n@5\n\n@6\nIN:\nMOV UP,ACC\nSAV\nMOV UP,ACC\nJEZ END\n\nLOOP:\nSWP\nMOV ACC,DOWN\nSWP\nSUB 1\nJGZ LOOP\n\nEND: \nMOV 0,DOWN\n\n@7\n\n@8\n\n@9\nMOV RIGHT,RIGHT\n@10\nLOOP:\nMOV ACC,LEFT\nMOV UP,ACC\nJEZ END\nADD LEFT\nJMP LOOP\n\nEND: \nMOV LEFT,DOWN\nMOV 0 ACC\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-12-22-30-17.png)\n","n":0.169}}},{"i":39,"$":{"0":{"v":"42656","n":1},"1":{"v":"## Sequence Reverser\n\n# Solution\n\n```\n@0\n\n@1\nMOV UP,DOWN\n\n@2\n\n@3\n\n@4\n\n@5\nMOV UP,RIGHT\n\n@6\nMOV 0,UP\n\nFORWARD: \nMOV LEFT,ACC\nMOV ACC,UP\nJGZ FORWARD\nMOV UP,NIL\n\nREVERSE: \nMOV UP,ACC\nMOV ACC,DOWN\nJGZ REVERSE\n\n@7\n\n@8\n\n@9\n\n@10\nMOV UP,DOWN\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-12-22-21-37.png)\n","n":0.236}}},{"i":40,"$":{"0":{"v":"41427","n":1},"1":{"v":"## Sequence Peak Detector\n\n# Solution\n\n```\n@0\n\n@1\nMOV UP,ACC\nMOV ACC,RIGHT\nMOV ACC,DOWN\n\n@2\nMOV LEFT,DOWN\n\n@3\n\n@4\n\n@5\nMOV UP ,ACC\nMOV ACC,DOWN\nMOV ACC,DOWN\n\n@6\nMOV UP,ACC\nMOV ACC,DOWN\nMOV ACC,DOWN\n\n@7\n\n@8\n\n@9\nMOV 999,ACC\nIN:\nSAV\nSUB UP\nJGZ NEW\nADD UP\nJMP IN\n\nNEW:\nMOV UP,ACC\nJGZ IN\n\nOUT:\nSWP\nMOV ACC,DOWN\n\n@10\nIN:\nSAV\nSUB UP\nJLZ NEW\nMOV UP,ACC\nJEZ OUT\nSWP\nJMP IN\nNEW: \nMOV UP,ACC\nJGZ IN\n\nOUT: SWP\nMOV ACC,DOWN\nMOV 0,ACC\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-12-22-14-43.png)","n":0.167}}},{"i":41,"$":{"0":{"v":"40196","n":1},"1":{"v":"## \n\n# Solution\n\n```\n@0\n\n@1\n0:\nMOV ANY,ACC\nMOV 0 ANY\nJNZ 0\n1:\nMOV ANY,ACC\nMOV 0,ANY\nJNZ 0\n2:\nMOV ANY,ACC\nJNZ RESET\nMOV 1,ANY\nJMP 2\nRESET:\nMOV 0,ANY\n\n@2\nMOV LEFT,DOWN\n\n@3\n\n@4\n\n@5\n\n@6\nMOV UP,DOWN\n\n@7\n\n@8\n\n@9\n\n@10\nMOV UP,DOWN\n\n@11\n\n```\n\n# Solution\n![](/assets/images/2022-11-12-21-58-30.png)","n":0.229}}},{"i":42,"$":{"0":{"v":"33762","n":1},"1":{"v":"## Interrupt Handler\n\n# Solution\n\n```\n@0\nSTART:\nMOV UP,ACC\nJGZ CHECK\nSWP\nJMP NEXT\n\nCHECK:\nSWP\nJGZ NEXT\nMOV 1,DOWN\nJMP START\n\nNEXT:\nMOV 0,DOWN\n\n@1\nSTART:\nMOV UP,ACC\nJGZ CHECK\nSWP\nJMP NEXT\n\nCHECK:\nSWP\nJGZ NEXT\nMOV 2,DOWN\nJMP START\n\nNEXT:\nMOV 0,DOWN\n\n@2\nSTART:\nMOV UP,ACC\nJGZ CHECK\nSWP\nJMP NEXT\n\nCHECK:\nSWP\nJGZ NEXT\nMOV 3,DOWN\nJMP START\n\nNEXT:\nMOV 0,DOWN\n\n@3\nSTART:\nMOV UP,ACC\nJGZ CHECK\nSWP\nJMP NEXT\n\nCHECK:\nSWP\nJGZ NEXT\nMOV 4,DOWN\nJMP START\n\nNEXT:\nMOV 0,DOWN\n\n@4\nMOV UP,RIGHT\n\n@5\nMOV UP,RIGHT\nMOV LEFT,RIGHT\n\n@6\nADD UP\nADD RIGHT\nADD LEFT\nADD LEFT\nMOV ACC,DOWN\nMOV 0,ACC\n\n@7\nMOV UP,LEFT\n\n@8\n\n@9\nMOV UP,DOWN\n\n@10\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2022-11-12-21-46-16.png)\n","n":0.151}}},{"i":43,"$":{"0":{"v":"32050","n":1},"1":{"v":"## Signal Edge Detector\n\n# Solution \n```\n@0\n\n@1\nMOV UP ACC\nMOV ACC RIGHT\nMOV ACC RIGHT\n\n@2\nSUB LEFT\nJLZ NEG\nJMP SIG\nNEG:\nNEG\nSIG:\nMOV ACC,DOWN\nMOV LEFT, ACC\n\n@3\n\n@4\n\n@5\n\n@6\nSTART:\nMOV UP,ACC\nSUB 10\nJLZ SIG0\nSIG1:\nMOV 1,DOWN\nJMP START\n\nSIG0:\nMOV 0,DOWN\n\n@7\n\n@8\n\n@9 \n\n@10\nMOV UP, DOWN\n\n@11\n\n```\n\n# Solution\n![](/assets/images/2022-11-22-17-33-16.png)","n":0.189}}},{"i":44,"$":{"0":{"v":"31904","n":1},"1":{"v":"## Sequence Counter\n\n# Solution\n\n```\n@0\n\n\n@1\nMOV UP ACC\nMOV ACC RIGHT\nMOV ACC DOWN\n\n@2\nSTART:\nMOV LEFT ACC\nJNZ ADD\nJMP TERMINATE\nADD:\nSWP\nADD 1\nSAV\nJMP START\nTERMINATE:\nSWP\nMOV ACC DOWN\nMOV 0 ACC\n\n@3\n\n@4\nMOV RIGHT ACC\nMOV ACC RIGHT\n\n@5\nSTART:\nMOV UP ACC\nJNZ ADD\nJMP TERMINATE\nADD:\nMOV ACC LEFT\nSWP\nADD LEFT\nSAV\nJMP START\nTERMINATE:\nSWP\nMOV ACC DOWN\nMOV 0 ACC\n\n@6\nMOV UP DOWN\n\n@7\n\n\n@8\nMOV UP DOWN\n\n@9\nMOV UP DOWN\n\n@10\n\n```\n\n# Solution\n\n![](/assets/images/2020-12-26-13-50-24.png)\n\n","n":0.152}}},{"i":45,"$":{"0":{"v":"30647","n":1},"1":{"v":"## Sequence Generator\n\n# Solution\n\n```\n@0\n\n\n@1\nMOV UP, ACC\nMOV ACC,RIGHT\nMOV ACC,DOWN\n\n@2\nMOV UP,ACC\nSAV\nSUB LEFT\nMOV ACC,DOWN\nSWP\nMOV ACC DOWN\n\n@3\n\n\n@4\n\n\n@5\nMOV UP,RIGHT\n\n@6\nSTART:\nMOV UP,ACC\nJLZ ACCEPT_TOP\n\nACCEPT_LEFT:\nMOV LEFT,DOWN\nMOV UP,DOWN\nJMP START\n\nACCEPT_TOP:\nMOV UP,DOWN\nMOV LEFT,DOWN\nJMP START\n\n@7\n\n\n@8\n\n\n@9\nMOV -2,ACC\nSTART:\nJEZ RESET\nMOV UP,DOWN\nADD 1\nJMP START\n\nRESET:\nMOV 0,DOWN\nMOV -2,ACC\nJMP START\n\n@10\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2020-11-05-21-29-23.png)\n\n","n":0.18}}},{"i":46,"$":{"0":{"v":"22280","n":1},"1":{"v":"## Signal Multiplexer\n\n# Solution\n\n```\n@0\n\n\n@1\nMOV UP,DOWN\n\n@2\nMOV UP,DOWN\n\n@3\nMOV UP,DOWN\n\n@4\n\n\n@5\nMOV UP,RIGHT\n\n@6\nSTART:\nMOV UP,ACC\nJEZ READ_BOTH\nJGZ READ_RIGHT\nMOV RIGHT,ACC\nMOV LEFT,DOWN\nJMP START\nREAD_RIGHT:\nMOV LEFT,ACC\nMOV RIGHT,DOWN\nJMP START\nREAD_BOTH:\nMOV RIGHT,ACC\nADD LEFT\nMOV ACC,DOWN\n\n@7\nMOV UP,LEFT\n\n@8\n\n\n@9\nMOV UP,DOWN\n\n@10\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2020-11-05-21-27-40.png)\n\n","n":0.209}}},{"i":47,"$":{"0":{"v":"21340","n":1},"1":{"v":"## Signal Comparator\n\n# Solution\n\n```\n@0\nMOV UP,DOWN\n\n@1\n\n\n@2\n\n\n@3\n\n\n@4\nMOV UP,DOWN\n\n@5\nMOV UP,RIGHT\n\n@6\nSTART:\nMOV LEFT,ACC\nJGZ WRITE1\nMOV ACC,RIGHT\nMOV 0,DOWN\nJMP START\n\n\nWRITE1:\nMOV ACC,RIGHT\nMOV 1,DOWN\nJMP START\n\n@7\nSTART:\nMOV LEFT,ACC\nJEZ WRITE1\nMOV ACC,RIGHT\nMOV 0,DOWN\nJMP START\n\n\nWRITE1:\nMOV ACC,RIGHT\nMOV 1,DOWN\nJMP START\n\n@8\nSTART:\nMOV LEFT,ACC\nJLZ WRITE1\nMOV 0,DOWN\nJMP START\n\n\nWRITE1:\nMOV 1,DOWN\nJMP START\n\n\n@9\n\n@10\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2020-11-05-21-23-20.png)\n\n","n":0.183}}},{"i":48,"$":{"0":{"v":"20176","n":1},"1":{"v":"## Differential Converter\n\n# Solution\n\n```\n@0\n\n\n@1\nMOV UP,ACC\nMOV ACC,RIGHT\nSUB RIGHT\nMOV ACC,DOWN\n\n@2\nMOV UP,ACC\nSAV\nSUB LEFT\nMOV ACC,DOWN\nSWP\nMOV ACC,LEFT\n\n@3\n\n\n@4\n\n\n@5\nMOV UP,DOWN\n\n@6\nMOV UP,DOWN\n\n@7\n\n\n@8\nMOV UP,DOWN\n\n@9\nMOV UP,DOWN\n\n@10\n\ny\n\n```\n\n# Solution\n\n![](/assets/images/2020-10-25-21-46-37.png)\n\n","n":0.243}}},{"i":49,"$":{"0":{"v":"10981","n":1},"1":{"v":"## Signal Amplifier\n\n# Solution\n\n```\n@0\n\n\n@1\nMOV UP,DOWN\n\n@2\n\n\n@3\n\n\n@4\nMOV UP,DOWN\n\n@5\n\n\n@6\n\n\n@7\nMOV UP,RIGHT\n\n@8\nMOV LEFT,ACC\nADD ACC\nMOV ACC,DOWN\n\n@9\n```\n\n# Solution\n\n![](/assets/images/2020-10-25-21-46-17.png)\n\n","n":0.302}}},{"i":50,"$":{"0":{"v":"00150","n":1},"1":{"v":"## Self-Test Diagnostic\n\n# Solution\n\n```\n@0\nMOV UP,DOWN\n\n@1\nMOV RIGHT, DOWN\n\n@2\nMOV UP,LEFT\n\n@3\nMOV UP, DOWN\n\n@4\nMOV UP,DOWN\n\n@5\nMOV UP, DOWN\n\n@6\nMOV UP,RIGHT\n\n@7\nMOV LEFT,DOWN\n\n@8\n\n@9\n\n@10\n\n@11\n\n```\n\n# Solution\n\n![](/assets/images/2020-10-25-21-45-52.png)\n\n","n":0.25}}},{"i":51,"$":{"0":{"v":"Destiny","n":1}}},{"i":52,"$":{"0":{"v":"Project","n":1}}},{"i":53,"$":{"0":{"v":"Striker","n":1},"1":{"v":"\nSide Scroller\n\nNO backtracking\n\nPlayable Character\n","n":0.5}}},{"i":54,"$":{"0":{"v":"Gamerdungeon","n":1}}},{"i":55,"$":{"0":{"v":"Lore","n":1}}},{"i":56,"$":{"0":{"v":"Zek","n":1},"1":{"v":"\n\n++ The Archives of T√ù-√π√º√± ++\nCodex Entry : ¬ß585--1874¬ß\nTitle : [ERR-7634]...Zek Tras Resnaz\nContent:\n\n    Knowledge, absolutely sure of its infallibility, is faith\n\nWarlocks are the scholars of our world. They spend great many ages pursuing the knowledge that makes them whole. Zek Tras Resnaz was one such warlock, and her poison was the infamous black armoury papers. To Zek they meant more than just knowledge, she thought it was meant to lead the way to the most powerful weapons in the universe.. to protect humanity. To her this meant the tireless pursuit of using the great forges of old to forge weapon after weapon in order to find the perfect weapon with which she could protect herself. Just like any other warlock, she was had contempt for the titans and the hunters around her. Titans those buffoons who only care about punching things and those hunters who just didn't care about any higher purpose other than themselves. She always wondered why did Ikora even listen to Zavala, he was not fit to be the leader of the vanguard, the man didn't even know anything about the history of the golden age or even talked to Ada-1.\n...\n[ERR-7634]\n...\nSiviks was her nemesis as he was the one who used the great forge of Gofannon and tainted it. This was heresy and Siviks and his Kell's Scourge would have to pay the price. She knew that he was here on earth, and had defiled the greatest vault of the black armory and stole its content. She quickly guided here fireteam of lesser gaurdians to the vault, but she was too late. Sivik's had mocked her again and fled.. however this made her resolve absolute, **Siviks Must Die, I shall be the bane of Kells Scourge**\n...\n[ERR-7634]\n[ERR-9532]\n[ERR-0001]\n.... Aborting archive reconstruction.. too many errors to continue grammar reconstruction.\n","n":0.058}}},{"i":57,"$":{"0":{"v":"Swift","n":1}}},{"i":58,"$":{"0":{"v":"Lucan","n":1}}},{"i":59,"$":{"0":{"v":"Chimi","n":1},"1":{"v":"\n\n++ The Archives of T√ù-√π√º√± ++\nCodex Entry : ¬ß145--124¬ß\nTitle : [ERR-7634]...Chimichanga\nContent:\n\nWhat connects 20000 years of Genocide? Too much power in a single hand\n\n[ERR-7634]\nThere use be an all powerful \"Chimichanga\", powerful enough that the rivers flowed as his will decided. The flora and fauna were overwhelmed by his willpower that they could feel their very essence of soul being burnt up, their physical form fades to dust. He attained the power of such magnitude not by chance, but pure will and a cold and unwavering heart.\n...\n[ERR-7634]\n...\nIn his duel with the great protector of ≈†z≈∏-√êN√íX Saint Lucan1x he had become too overconfident in his power that he thought the Saint wouldn't be able to shoot let alone kill him if he couldn't be seen. He could just disappear from the visual spectrum of Saint and simple Solar Infused knife thrown from the back would be the first and last blow for this so called \"saint among peasants\". He infused the blade in his hand with his will and it shone red with heat and hatred, threw it at the saints back. As the knife was flying through the air the Saint started shimmering with a purple glow, the air around him rippling with energy. As the knife moved closer its pace increased and so did its weight, as was the will of it creator. Just before it could hit saints neck a purple disc appeared in its path. The knife disintegrated upon hitting it and before the knife thrower could blink he heard the shot of a long lost weapon of legend, the weapon that wielded the power of a small star, Izanagi's Burden. The next thing he felt was his soul, his will and his body splitting apart from each other. \"How had he lost ?\" was the last thought that crossed his mind before darkness enveloped him.\n...\n[ERR-7634]\n[ERR-9532]\n[ERR-0001]\n\n.... Aborting archive reconstruction.. too many errors to continue grammar reconstruction.\n","n":0.056}}},{"i":60,"$":{"0":{"v":"Advent of Code","n":0.577},"1":{"v":"\nAdvent of Code is an Advent calendar of small programming puzzles for a variety of skill sets and skill levels that can be solved in any programming language you like. People use them as a speed contest, interview prep, company training, university coursework, practice problems, or to challenge each other.\n","n":0.141}}},{"i":61,"$":{"0":{"v":"2015","n":1}}},{"i":62,"$":{"0":{"v":"Day 9","n":0.707},"1":{"v":"## All in a Single Night\n\n## Part I\n\nEvery year, Santa manages to deliver all of his presents in a single night.\n\nThis year, however, he has some new locations to visit; his elves have provided him the distances between every pair of locations. He can start and end at any two (different) locations he wants, but he must visit each location exactly once. What is the shortest distance he can travel to achieve this?\n\nFor example, given the following distances:\n\n```\nLondon to Dublin = 464\nLondon to Belfast = 518\nDublin to Belfast = 141\n```\n\nThe possible routes are therefore:\n\n```\nDublin -> London -> Belfast = 982\nLondon -> Dublin -> Belfast = 605\nLondon -> Belfast -> Dublin = 659\nDublin -> Belfast -> London = 659\nBelfast -> Dublin -> London = 605\nBelfast -> London -> Dublin = 982\n```\n\nThe shortest of these is `London -> Dublin -> Belfast = 605`, and so the answer is `605` in this example.\n\nWhat is the distance of the shortest route?\n\n## Solution\n\n```rust\nuse std::collections::HashMap;\n\nstruct Graph<'a> {\n    nodes: Vec<&'a str>,\n    edges: HashMap<(&'a str, &'a str), u16>,\n}\n\nimpl<'a> Graph<'a> {\n    fn new() -> Graph<'a> {\n        Graph {\n            nodes: Vec::new(),\n            edges: HashMap::new(),\n        }\n    }\n\n    fn permutations<'b>(collection: &[&'b str]) -> Vec<Vec<&'b str>> {\n        if collection.len() == 1 {\n            return vec![vec![collection[0]]];\n        }\n        let mut result = vec![];\n        for el in collection {\n            for tail in Self::permutations(\n                &collection\n                    .iter()\n                    .filter(|x| *x != el)\n                    .copied()\n                    .collect::<Vec<&'b str>>(),\n            ) {\n                let mut whole = vec![*el];\n                whole.extend(tail);\n                result.push(whole.clone())\n            }\n        }\n        result\n    }\n\n    fn cheapest(&self) -> u16 {\n        Graph::permutations(self.nodes.clone().as_ref())\n            .iter()\n            .map(|x| {\n                let mut last = \"\";\n                x.iter().fold(0, |tot, node| {\n                    if last != \"\" && last != *node {\n                        let price = &self.edges[&(last, *node)];\n                        last = node;\n                        tot + price\n                    } else {\n                        last = node;\n                        tot\n                    }\n                })\n            })\n            .min()\n            .unwrap()\n    }\n}\n\nfn input_to_graph(input: &str) -> Graph {\n    let mut graph = Graph::new();\n    input.lines().for_each(|line| {\n        let mut w = line.split_whitespace();\n        let s = w.next().unwrap();\n        w.next();\n        let d = w.next().unwrap();\n        w.next();\n        let l = w.next().unwrap().to_string().parse::<u16>().unwrap();\n        if !graph.nodes.contains(&s) {\n            graph.nodes.push(s);\n        }\n        if !graph.nodes.contains(&d) {\n            graph.nodes.push(d);\n        }\n        graph.edges.insert((s, d), l);\n        graph.edges.insert((d, s), l);\n    });\n    graph\n}\n\n#[aoc(day9, part1)]\npub fn part1(input: &str) -> u16 {\n    input_to_graph(input).cheapest()\n}\n```\n\n## Part II\n\nThe next year, just to show off, Santa decides to take the route with the longest distance instead.\n\nHe can still start and end at any two (different) locations he wants, and he still must visit each location exactly once.\n\nFor example, given the distances above, the longest route would be `982` via (for example) `Dublin -> London -> Belfast`.\n\nWhat is the distance of the longest route?\n\n## Solution\n\n```rust\nimpl<'a> Graph<'a> {\n    //New Method\n    fn costliest(&self) -> u16 {\n        Graph::permutations(self.nodes.clone().as_ref())\n            .iter()\n            .map(|x| {\n                let mut last = \"\";\n                x.iter().fold(0, |tot, node| {\n                    if last != \"\" && last != *node {\n                        let price = &self.edges[&(last, *node)];\n                        last = node;\n                        tot + price\n                    } else {\n                        last = node;\n                        tot\n                    }\n                })\n            })\n            .max()\n            .unwrap()\n    }\n}\n#[aoc(day9, part2)]\npub fn part2(input: &str) -> u16 {\n    input_to_graph(input).costliest()\n}\n```\n\n","n":0.046}}},{"i":63,"$":{"0":{"v":"Day 8","n":0.707},"1":{"v":"## Matchsticks\n\nSpace on the sleigh is limited this year, and so Santa will be bringing his list as a digital copy. He needs to know how much space it will take up when stored.\n\nIt is common in many programming languages to provide a way to escape special characters in strings. For example, C, JavaScript, Perl, Python, and even PHP handle special characters in very similar ways.\n\nHowever, it is important to realize the difference between the number of characters in the code representation of the string literal and the number of characters in the in-memory string itself.\n\nFor example:\n\n> `\"\"` is `2` characters of code (the two double quotes), but the string contains zero characters.\n>\n> `\"abc\"` is `5` characters of code, but 3 characters in the string data.\n> `\"aaa\\\"aaa\"` is `10` characters of code, but the string itself contains six \"a\" characters and a single, escaped quote character, for a total of `7` characters in the string data.\n>\n> `\"\\x27\"` is `6` characters of code, but the string itself contains just one - an apostrophe (`'`), escaped using hexadecimal notation.\n\nSanta's list is a file that contains many double-quoted string literals, one on each line. The only escape sequences used are `\\\\` (which represents a single backslash), `\\\"` (which represents a lone double-quote character), and `\\x` plus two hexadecimal characters (which represents a single character with that ASCII code).\n\nDisregarding the whitespace in the file, what is the number of characters of code for string literals minus the number of characters in memory for the values of the strings in total for the entire file?\n\nFor example, given the four strings above, the total number of characters of string code (`2 + 5 + 10 + 6 = 23`) minus the total number of characters in memory for string values (`0 + 3 + 7 + 1 = 11`) is `23 - 11 = 12`.\n\n## Solution\n\n```rust\n#[aoc(day8, part1)]\npub fn part1(input: &str) -> u16 {\n    let mut mem_count: Vec<u16> = Vec::new();\n    let mut char_count: Vec<u16> = Vec::new();\n    input.lines().for_each(|line| {\n        char_count.push(line.chars().count() as u16);\n        let mut chars = line.chars();\n        let mut count: u16 = 0;\n        chars.next();\n        loop {\n            match chars.next() {\n                Some(c) => match c {\n                    '\\\"' => {}\n                    '\\\\' => match chars.next() {\n                        Some(c) => {\n                            if c == 'x' {\n                                chars.next();\n                                chars.next();\n                                count += 1;\n                            } else if c == '\"' || c == '\\\\' {\n                                count += 1;\n                            }\n                        }\n                        None => (),\n                    },\n                    _ => {\n                        count += 1;\n                    }\n                },\n                None => break,\n            }\n        }\n        mem_count.push(count);\n    });\n    char_count.iter().sum::<u16>() - mem_count.iter().sum::<u16>()\n}\n```\n\n## Part II\n\nNow, let's go the other way. In addition to finding the number of characters of code, you should now encode each code representation as a new string and find the number of characters of the new encoded representation, including the surrounding double quotes.\n\nFor example:\n\n> `\"\"` encodes to `\"\\\"\\\"\"`, an increase from `2` characters to `6`.\n>\n> `\"abc\"` encodes to `\"\\\"abc\\\"\"`, an increase from `5` characters to `9`.\n>\n> `\"aaa\\\"aaa\"` encodes to `\"\\\"aaa\\\\\\\"aaa\\\"\"`, an increase from `10` characters to `16`.\n>\n> `\"\\x27`\" encodes to `\"\\\"\\\\x27\\\"\"`, an increase from `6` characters to `11`.\n\nYour task is to find the total number of characters to represent the newly encoded strings minus the number of characters of code in each original string literal. For example, for the strings above, the total encoded length (`16 + 9 + 16 + 11 = 42`) minus the characters in the original code representation (`23`, just like in the first part of this puzzle) is `42 - 23 = 19`.\n\n# Solution\n\n```rust\n#[aoc(day8, part2)]\npub fn part2(input: &str) -> u16 {\n    let mut mem_count: Vec<u16> = Vec::new();\n    let mut char_count: Vec<u16> = Vec::new();\n    input.lines().for_each(|line| {\n        char_count.push(line.chars().count() as u16);\n        let mut chars = line.chars();\n        let mut esc_count: u16 = 2;\n        loop {\n            match chars.next() {\n                Some(c) => match c {\n                    '\\\"' => {\n                        esc_count += 1;\n                    }\n                    '\\\\' => match chars.next() {\n                        Some(c) => {\n                            if c == 'x' {\n                                chars.next();\n                                chars.next();\n                                esc_count += 1;\n                            } else if c == '\"' || c == '\\\\' {\n                                esc_count += 2;\n                            }\n                        }\n                        None => (),\n                    },\n                    _ => {}\n                },\n                None => break,\n            }\n        }\n        mem_count.push(line.chars().count() as u16 + esc_count);\n    });\n    mem_count.iter().sum::<u16>() - char_count.iter().sum::<u16>()\n}\n```\n\n","n":0.038}}},{"i":64,"$":{"0":{"v":"Day 7","n":0.707},"1":{"v":"## Some Assembly Required\n\n## Part I\n\nThis year, Santa brought little Bobby Tables a set of wires and bitwise logic gates! Unfortunately, little Bobby is a little under the recommended age range, and he needs help assembling the circuit.\n\nEach wire has an identifier (some lowercase letters) and can carry a 16-bit signal (a number from `0` to `65535`). A signal is provided to each wire by a gate, another wire, or some specific value. Each wire can only get a signal from one source, but can provide its signal to multiple destinations. A gate provides no signal until all of its inputs have a signal.\n\nThe included instructions booklet describes how to connect the parts together: `x AND y -> z` means to connect wires `x` and `y` to an AND gate, and then connect its output to wire `z`.\n\nFor example:\n\n> `123 -> x` means that the signal 123 is provided to wire `x`.\n>\n> `x AND y -> z` means that the bitwise AND of wire `x` and wire `y` is provided to wire `z`.\n>\n> `p LSHIFT 2 -> q` means that the value from wire `p` is left-shifted by `2` and then provided to wire `q`.\n>\n> `NOT e -> f` means that the bitwise complement of the value from wire `e` is provided to wire `f`.\n\nOther possible gates include `OR` (bitwise OR) and `RSHIFT` (right-shift). If, for some reason, you'd like to emulate the circuit instead, almost all programming languages (for example, C, JavaScript, or Python) provide operators for these gates.\n\nFor example, here is a simple circuit:\n\n```\n123 -> x\n456 -> y\nx AND y -> d\nx OR y -> e\nx LSHIFT 2 -> f\ny RSHIFT 2 -> g\nNOT x -> h\nNOT y -> i\n```\n\nAfter it is run, these are the signals on the wires:\n\n```\nd: 72\ne: 507\nf: 492\ng: 114\nh: 65412\ni: 65079\nx: 123\ny: 456\n```\n\nIn little Bobby's kit's instructions booklet (provided as your puzzle input), what signal is ultimately provided to wire `a`?\n\n## Solution\n\n```rust\nuse std::collections::HashMap;\n#[derive(Debug)]\npub enum Gate {\n    Value(u16, String),\n    Source(String, String),\n    And(String, String, String),\n    AndValue(u16, String, String),\n    Or(String, String, String),\n    LShift(String, u16, String),\n    RShift(String, u16, String),\n    Not(String, String),\n}\n\n#[aoc_generator(day7)]\npub fn input_to_struct(input: &str) -> Vec<Gate> {\n    input\n        .lines()\n        .map(|line| {\n            let words = line.split_whitespace().collect::<Vec<_>>();\n            if words[0] == \"NOT\" {\n                Gate::Not(words[1].to_string(), words[3].to_string())\n            } else if words[1] == \"LSHIFT\" {\n                Gate::LShift(\n                    words[0].to_string(),\n                    words[2].to_string().trim().parse::<u16>().unwrap(),\n                    words[4].to_string(),\n                )\n            } else if words[1] == \"RSHIFT\" {\n                Gate::RShift(\n                    words[0].to_string(),\n                    words[2].to_string().trim().parse::<u16>().unwrap(),\n                    words[4].to_string(),\n                )\n            } else if words[0].to_string().trim().parse::<i64>().is_ok() && words[1] == \"AND\" {\n                Gate::AndValue(\n                    words[0].to_string().trim().parse::<u16>().unwrap(),\n                    words[2].to_string(),\n                    words[4].to_string(),\n                )\n            } else if words[1] == \"AND\" {\n                Gate::And(\n                    words[0].to_string(),\n                    words[2].to_string(),\n                    words[4].to_string(),\n                )\n            } else if words[1] == \"OR\" {\n                Gate::Or(\n                    words[0].to_string(),\n                    words[2].to_string(),\n                    words[4].to_string(),\n                )\n            } else if words[0].to_string().trim().parse::<i64>().is_ok() && words[1] == \"->\" {\n                Gate::Value(\n                    words[0].to_string().trim().parse::<u16>().unwrap(),\n                    words[2].to_string(),\n                )\n            } else if words[1] == \"->\" {\n                Gate::Source(words[0].to_string(), words[2].to_string())\n            } else {\n                unreachable!()\n            }\n        })\n        .collect::<Vec<Gate>>()\n}\n\nfn solve_circuit(gates: &[Gate], values: &mut HashMap<String, u16>) -> HashMap<String, u16> {\n    let mut unresolved = true;\n    let constants = values.clone();\n    while unresolved {\n        let values_prev = values.clone();\n        gates.iter().for_each(|item| {\n            for (k, v) in &constants {\n                values.insert(k.clone(), *v);\n            }\n            match item {\n                Gate::Value(ref num, ref dst) => {\n                    values.insert(dst.to_string(), *num);\n                }\n                Gate::Source(ref src0, ref dst) => {\n                    if values.contains_key(src0) {\n                        let v0 = *values.get(src0).unwrap();\n                        values.insert(dst.to_string(), v0);\n                    }\n                }\n                Gate::And(ref src0, ref src1, ref dst) => {\n                    if values.contains_key(src0) && values.contains_key(src1) {\n                        let v0 = *values.get(src0).unwrap();\n                        let v1 = *values.get(src1).unwrap();\n                        values.insert(dst.to_string(), v0 & v1);\n                    }\n                }\n                Gate::AndValue(ref v0, ref src1, ref dst) => {\n                    if values.contains_key(src1) {\n                        let v1 = *values.get(src1).unwrap();\n                        values.insert(dst.to_string(), *v0 & v1);\n                    }\n                }\n                Gate::Or(ref src0, ref src1, ref dst) => {\n                    if values.contains_key(src0) && values.contains_key(src1) {\n                        let v0 = *values.get(src0).unwrap();\n                        let v1 = *values.get(src1).unwrap();\n                        values.insert(dst.to_string(), v0 | v1);\n                    }\n                }\n                Gate::LShift(ref src0, ref num, ref dst) => {\n                    if values.contains_key(src0) {\n                        let v0 = *values.get(src0).unwrap();\n                        values.insert(dst.to_string(), v0 << *num);\n                    }\n                }\n                Gate::RShift(ref src0, ref num, ref dst) => {\n                    if values.contains_key(src0) {\n                        let v0 = *values.get(src0).unwrap();\n                        values.insert(dst.to_string(), v0 >> *num);\n                    }\n                }\n                Gate::Not(ref src0, ref dst) => {\n                    if values.contains_key(src0) {\n                        let v0 = *values.get(src0).unwrap();\n                        values.insert(dst.to_string(), !v0);\n                    }\n                }\n            }\n            unresolved = values_prev != *values;\n        });\n    }\n    values.clone()\n}\n\n#[aoc(day7, part1)]\npub fn part1(input: &[Gate]) -> u16 {\n    *solve_circuit(input, &mut HashMap::new()).get(\"a\").unwrap()\n}\n```\n\n## Part II\n\nNow, take the signal you got on wire a, override wire b to that signal, and reset the other wires (including wire a).\n\nWhat new signal is ultimately provided to wire `a`?\n\n## Solution\n\n```rust\n#[aoc(day7, part2)]\npub fn part2(input: &[Gate]) -> u16 {\n    let mut map = HashMap::new();\n    map.insert(\n        \"b\".to_string(),\n        *solve_circuit(&input, &mut HashMap::new()).get(\"a\").unwrap(),\n    );\n    *solve_circuit(&input, &mut map).get(\"a\").unwrap()\n}\n```\n\n","n":0.037}}},{"i":65,"$":{"0":{"v":"Day 6","n":0.707},"1":{"v":"## Probably a Fire Hazard\n\n## Part I\n\nBecause your neighbors keep defeating you in the holiday house decorating contest year after year, you've decided to deploy one million lights in a 1000x1000 grid.\n\nFurthermore, because you've been especially nice this year, Santa has mailed you instructions on how to display the ideal lighting configuration.\n\nLights in your grid are numbered from 0 to 999 in each direction; the lights at each corner are at `0,0`, `0,999`, `999,999`, and `999,0`. The instructions include whether to `turn on`, `turn off`, or `toggle` various inclusive ranges given as coordinate pairs. Each coordinate pair represents opposite corners of a rectangle, inclusive; a coordinate pair like `0,0 through 2,2` therefore refers to 9 lights in a 3x3 square. The lights all start turned off.\n\nTo defeat your neighbors this year, all you have to do is set up your lights by doing the instructions Santa sent you in order.\n\nFor example:\n\n> `turn on 0,0 through 999,999` would turn on (or leave on) every light.\n>\n> `toggle 0,0 through 999,0` would toggle the first line of 1000 lights, turning off the ones that were on, and turning on the ones that were off.\n>\n> `turn off 499,499 through 500,500` would turn off (or leave off) the middle four lights.\n\nAfter following the instructions, how many lights are lit?\n\n## Solution\n\n```rust\nenum Action {\n    On,\n    Off,\n    Toggle,\n}\n\npub struct Instruction {\n    start: (usize, usize),\n    end: (usize, usize),\n    action: Action,\n}\n\n#[aoc_generator(day6)]\npub fn input_to_struct(input: &str) -> Vec<Instruction> {\n    input\n        .lines()\n        .map(|line| {\n            let mut c = line.split_whitespace().rev();\n            let mut d = c.next().unwrap().split(',');\n            let end = (\n                d.next().unwrap().parse::<usize>().unwrap(),\n                d.next().unwrap().parse::<usize>().unwrap(),\n            );\n            c.next();\n            let mut d = c.next().unwrap().split(',');\n            let start = (\n                d.next().unwrap().parse::<usize>().unwrap(),\n                d.next().unwrap().parse::<usize>().unwrap(),\n            );\n            let action = match c.next().unwrap() {\n                \"on\" => Action::On,\n                \"off\" => Action::Off,\n                \"toggle\" => Action::Toggle,\n                _ => unreachable!(),\n            };\n\n            Instruction {\n                start: start,\n                end: end,\n                action: action,\n            }\n        })\n        .collect::<Vec<Instruction>>()\n}\n\n#[aoc(day6, part1)]\npub fn part1(input: &Vec<Instruction>) -> i64 {\n    let mut switch: [[u8; 1000]; 1000] = [[0; 1000]; 1000];\n    let mut count: i64 = 0;\n    for x in input {\n        for i in x.start.0..=x.end.0 {\n            for j in x.start.1..=x.end.1 {\n                match x.action {\n                    Action::Off => {\n                        if switch[i][j] == 1 {\n                            count -= 1;\n                            switch[i][j] = 0;\n                        }\n                    }\n                    Action::On => {\n                        if switch[i][j] == 0 {\n                            count += 1;\n                            switch[i][j] = 1;\n                        }\n                    }\n                    Action::Toggle => {\n                        if switch[i][j] == 0 {\n                            count += 1;\n                            switch[i][j] = 1;\n                        } else {\n                            count += -1;\n                            switch[i][j] = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    count\n}\n```\n\n## Part II\n\nYou just finish implementing your winning light pattern when you realize you mistranslated Santa's message from Ancient Nordic Elvish.\n\nThe light grid you bought actually has individual brightness controls; each light can have a brightness of zero or more. The lights all start at zero.\n\nThe phrase `turn on` actually means that you should increase the brightness of those lights by `1`.\n\nThe phrase `turn off` actually means that you should decrease the brightness of those lights by `1`, to a minimum of zero.\n\nThe phrase toggle actually means that you should increase the brightness of those lights by `2`.\n\nWhat is the total brightness of all lights combined after following Santa's instructions?\n\nFor example:\n\n> `turn on 0,0 through 0,0` would increase the total brightness by `1`.\n>\n> `toggle 0,0 through 999,999` would increase the total brightness by `2000000`.\n\n## Solution\n\n```rust\n#[aoc(day6, part2)]\npub fn part2(input: &Vec<Instruction>) -> i64 {\n    let mut switch: [[i16; 1000]; 1000] = [[0; 1000]; 1000];\n    let mut bright: i64 = 0;\n    for x in input {\n        for i in x.start.0..=x.end.0 {\n            for j in x.start.1..=x.end.1 {\n                match x.action {\n                    Action::Off => {\n                        if switch[i][j] > 0 {\n                            bright -= 1;\n                            switch[i][j] -= 1;\n                        }\n                    }\n                    Action::On => {\n                        bright += 1;\n                        switch[i][j] += 1;\n                    }\n                    Action::Toggle => {\n                        bright += 2;\n                        switch[i][j] += 2;\n                    }\n                }\n            }\n        }\n    }\n    bright\n}\n```\n\n","n":0.04}}},{"i":66,"$":{"0":{"v":"Day 5","n":0.707},"1":{"v":"## Doesn't He Have Intern-Elves For This?\n\n## Part I\n\nSanta needs help figuring out which strings in his text file are naughty or nice.\n\nA nice string is one with all of the following properties:\n\n> It contains at least three vowels (`aeiou` only), like `aei`, `xazegov`, or `aeiouaeiouaeiou`.\n>\n> It contains at least one letter that appears twice in a row, like `xx`, `abcdde` (`dd`), or `aabbccdd` (`aa`, `bb`, `cc`, or `dd`).\n>\n> It does not contain the strings `ab`, `cd`, `pq`, or `xy`, even if they are part of one of the other requirements.\n\nFor example:\n\n> `ugknbfddgicrmopn` is nice because it has at least three vowels (`u...i...o...`), a double letter (`...dd...`), and none of the disallowed substrings.\n>\n> `aaa` is nice because it has at least three vowels and a double letter, even though the letters used by different rules overlap.\n>\n> `jchzalrnumimnmhp` is naughty because it has no double letter.\n>\n> `haegwjzuvuyypxyu` is naughty because it contains the string xy.\n>\n> `dvszwmarrgswjxmb` is naughty because it contains only one vowel.\n\nHow many strings are nice?\n\n## Solution\n\nIterating the input line by line we can pass it through filters which would apply the conditions so as to eliminate all strings that are not `nice`.\n\nThe answer is the count of all the remaining strings.\n\n```rust\n#[aoc(day5, part1)]\npub fn part1(input: &str) -> usize {\n    input\n        .lines()\n        .filter(|w| !(w.contains(\"ab\") || w.contains(\"cd\") || w.contains(\"pq\") || w.contains(\"xy\")))\n        .filter(|x| {\n            x.chars()\n                .filter(|c| *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u')\n                .count()\n                > 2\n        })\n        .filter(|y| {\n            let mut c = y.chars().collect::<Vec<char>>();\n            let l = c.len();\n            c.dedup();\n            l != c.len()\n        })\n        .count()\n}\n```\n\n## Part II\n\nRealizing the error of his ways, Santa has switched to a better model of determining whether a string is naughty or nice. None of the old rules apply, as they are all clearly ridiculous.\n\nNow, a nice string is one with all of the following properties:\n\n> It contains a pair of any two letters that appears at least twice in the string without overlapping, like `xyxy` (`xy`) or `aabcdefgaa` (`aa`), but not like `aaa` (`aa`, but it overlaps).\n>\n> It contains at least one letter which repeats with exactly one letter between them, like `xyx`, `abcdefeghi` (`efe`), or even `aaa`.\n\nFor example:\n\n> `qjhvhtzxzqqjkmpb` is nice because is has a pair that appears twice (`qj`) and a letter that repeats with exactly one letter between them (`zxz`).\n>\n> `xxyxx` is nice because it has a pair that appears twice and a letter that repeats with one between, even though the letters used by each rule overlap.\n>\n> `uurcxstgmygtbstg` is naughty because it has a pair (`tg`) but no repeat with a single letter between them.\n>\n> `ieodomkazucvgmuy` is naughty because it has a repeating letter with one between (`odo`), but no pair that appears twice.\n\nHow many strings are nice under these new rules?\n\n## Solution\n\nA recursive function `repeat_xx` provides the check for condition we then filter out on the strings that match.\n\nThe answer is the count of all the remaining strings after the filters have been applied.\n\n```rust\nfn repeat_xx(string: &str) -> bool {\n    if string.len() < 4 {\n        return false;\n    }\n\n    let pair = &string[0..2];\n    let remain = &string[2..];\n\n    remain.contains(pair) || repeat_xx(&string[1..])\n}\n\n#[aoc(day5, part2)]\npub fn part2(input: &str) -> usize {\n    input\n        .lines()\n        .filter(|y| repeat_xx(y))\n        .filter(|z| z.chars().zip(z.chars().skip(2)).any(|(a, b)| a == b))\n        .count()\n}\n```\n\n","n":0.043}}},{"i":67,"$":{"0":{"v":"Day 4","n":0.707},"1":{"v":"## The Ideal Stocking Stuffer\n\n## Part I\n\nSanta needs help mining some AdventCoins (very similar to bitcoins) to use as gifts for all the economically forward-thinking little girls and boys.\n\nTo do this, he needs to find MD5 hashes which, in hexadecimal, start with at least five zeroes. The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal. To mine AdventCoins, you must find Santa the lowest positive number (no leading zeroes: `1`, `2`, `3`, ...) that produces such a hash.\n\nFor example:\n\n> If your secret key is `abcdef`, the answer is `609043`, because the MD5 hash of `abcdef609043` starts with five zeroes (`000001dbbfa...`), and it is the lowest such number to do so.\n>\n> If your secret key is `pqrstuv`, the lowest number it combines with to make an MD5 hash starting with five zeroes is `1048970`; that is, the MD5 hash of `pqrstuv1048970` looks like `000006136ef....`\n\n## Solution\n\nBrute forcing would be the easiest way to find the solution.\n\nTaking the input we iterate from 1 to the max u32 using `i` and append it to the input.\n\nThis would be the content for which we compute the`md5Sum` and check if it starts with five zeroes.\n\n```rust\nuse md5;\n\n#[aoc(day4, part1)]\npub fn solve_part1(input: &str) -> u32 {\n    (1..)\n        .filter(|i| format!(\"{:x}\", md5::compute(format!(\"{}{}\", input, i))).starts_with(\"00000\"))\n        .next()\n        .unwrap()\n}\n```\n\n## Part II\n\nNow find one that starts with six zeroes.\n\n## Solution\n\nA small change from `.starts_with(\"00000\")` to `.starts_with(\"000000\")` provides the answer.\n\n```rust\n#[aoc(day4, part2)]\npub fn solve_part2(input: &str) -> i32 {\n    (1..)\n        .filter(|i| format!(\"{:x}\", md5::compute(format!(\"{}{}\", input, i))).starts_with(\"000000\"))\n        .next()\n        .unwrap()\n}\n```\n\n","n":0.063}}},{"i":68,"$":{"0":{"v":"Day 3","n":0.707},"1":{"v":"## Perfectly Spherical Houses in a Vacuum\n\n## Part I\n\nSanta is delivering presents to an infinite two-dimensional grid of houses.\n\nHe begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (`^`), south (`v`), east (`>`), or west (`<`). After each move, he delivers another present to the house at his new location.\n\nHowever, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive at least one present?\n\nFor example:\n\n> `>` delivers presents to 2 houses: one at the starting location, and one to the east.\n>\n> `^>v<` delivers presents to 4 houses in a square, including twice to the house at his starting/ending location.\n>\n> `^v^v^v^v^v` delivers a bunch of presents to some very lucky children at only 2 houses.\n\n## Solution\n\nA simple XY coordinate system would make this a simple pathing problem.\n\nThe `last_pos` variable would hold the (x,y) coordinates of Santa.\n\nA hashmap with the key as the (x,y) coordinate will be used to identify individual houses and store the number of presents delivered at that house.\n\n```rust\n#[aoc(day3, part1)]\npub fn part1(input: &str) -> usize {\n    let mut last_pos = (0, 0);\n    let mut map: HashMap<(i32, i32), u32> = HashMap::new();\n    map.insert(last_pos, 0);\n    input.chars().for_each(|d| {\n        last_pos = match d {\n            '^' => (last_pos.0 + 1, last_pos.1),\n            'v' => (last_pos.0 - 1, last_pos.1),\n            '>' => (last_pos.0, last_pos.1 + 1),\n            '<' => (last_pos.0, last_pos.1 - 1),\n            _ => unreachable!(),\n        };\n        map.entry(last_pos).and_modify(|x| *x += 1).or_insert(1);\n    });\n    map.len()\n}\n```\n\n## Part II\n\nThe next year, to speed up the process, Santa creates a robot version of himself, Robo-Santa, to deliver presents with him.\n\nSanta and Robo-Santa start at the same location (delivering two presents to the same starting house), then take turns moving based on instructions from the elf, who is eggnoggedly reading from the same script as the previous year.\n\nThis year, how many houses receive at least one present?\n\nFor example:\n\n> `^v` delivers presents to 3 houses, because Santa goes north, and then Robo-Santa goes south.\n>\n> `^>v<` now delivers presents to `3` houses, and Santa and Robo-Santa end up back where they started.\n>\n> `^v^v^v^v^v` now delivers presents to `11` houses, with Santa going one direction and Robo-Santa going the other.\n\n## Solution\n\nHere we would have to trace 2 paths, one for Santa and another for Robo-Santa.\n\nSince both of them take turns reading the instructions, Santa received all odd numbered instructions and the Robo-Santa receives all even numbered instructions.\n\n```rust\n#[aoc(day3, part2)]\npub fn part2(input: &str) -> usize {\n    let mut last_pos = (0, 0);\n    let mut last_pos_clone = (0, 0);\n    let mut map: HashMap<(i32, i32), u32> = HashMap::new();\n    map.insert(last_pos, 0);\n    input.chars().enumerate().for_each(|(i, d)| {\n        if i % 2 == 0 {\n            last_pos = match d {\n                '^' => (last_pos.0 + 1, last_pos.1),\n                'v' => (last_pos.0 - 1, last_pos.1),\n                '>' => (last_pos.0, last_pos.1 + 1),\n                '<' => (last_pos.0, last_pos.1 - 1),\n                _ => unreachable!(),\n            };\n            map.entry(last_pos).and_modify(|x| *x += 1).or_insert(1);\n        } else {\n            last_pos_clone = match d {\n                '^' => (last_pos_clone.0 + 1, last_pos_clone.1),\n                'v' => (last_pos_clone.0 - 1, last_pos_clone.1),\n                '>' => (last_pos_clone.0, last_pos_clone.1 + 1),\n                '<' => (last_pos_clone.0, last_pos_clone.1 - 1),\n                _ => unreachable!(),\n            };\n            map.entry(last_pos_clone)\n                .and_modify(|x| *x += 1)\n                .or_insert(1);\n        }\n    });\n    map.len()\n}\n```\n\n","n":0.042}}},{"i":69,"$":{"0":{"v":"Day 2","n":0.707},"1":{"v":"## I Was Told There Would Be No Math\n\n## Part I\n\nThe elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length `l`, width `w`, and height `h`) of each present, and only want to order exactly as much as they need.\n\nFortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is `2*l*w + 2*w*h + 2*h*l`. The elves also need a little extra paper for each present: the area of the smallest side.\n\nFor example:\n\n> A present with dimensions `2x3x4` requires `2*6 + 2*12 + 2*8 = 52` square feet of wrapping paper plus `6` square feet of slack, for a total of `58` square feet.\n>\n> A present with dimensions `1x1x10` requires `2*1 + 2*10 + 2*10 = 42` square feet of wrapping paper plus `1` square foot of slack, for a total of `43` square feet.\n\nAll numbers in the elves' list are in feet. How many total square feet of wrapping paper should they order?\n\n## Solution\n\nA simple structure that can hold the dimensions would be the starting point from which we can solve the problem.\n\nA method `get_area` that would return the area calculated as `2*l*w + 2*w*h + 2*h*l`.\n\nA method `get_smallest_side_area` would calculate all the side areas and return the minimum which would provide the `slack` to be added.\n\nA `text_to_struct` method that would convert the text input to a `Vector` of `Prism`, to enable easy iteration.\n\nTo find the answer iterate over the Vector<Prism> calculate the `area` + `smallest_side_area` and sum them all up.\n\n```rust\n// Holds the dimensions of the Gift\n#[derive(Copy, Clone)]\npub struct Prism {\n    x: u32,\n    y: u32,\n    z: u32,\n}\n\nimpl Prism {\n\n    pub fn get_smallest_side_area(self) -> u32 {\n        *[self.x * self.y, self.y * self.z, self.z * self.x]\n            .iter()\n            .min()\n            .unwrap_or(&0)\n    }\n\n    pub fn get_area(self) -> u32 {\n        [\n            2 * self.x * self.y,\n            2 * self.y * self.z,\n            2 * self.z * self.x,\n        ]\n        .iter()\n        .sum::<u32>()\n    }\n}\n\n#[aoc_generator(day2)]\npub fn text_to_struct(input: &str) -> Vec<Prism> {\n    input\n        .lines()\n        .map(|line| {\n            let mut chars = line.trim().split('x');\n            Prism {\n                x: chars.next().unwrap().parse().unwrap(),\n                y: chars.next().unwrap().parse().unwrap(),\n                z: chars.next().unwrap().parse().unwrap(),\n            }\n        })\n        .collect::<Vec<Prism>>()\n}\n\n#[aoc(day2, part1)]\npub fn part1(input: &[Prism]) -> u32 {\n    input\n        .iter()\n        .map(|x| x.get_smallest_side_area() + x.get_area())\n        .collect::<Vec<u32>>()\n        .iter()\n        .sum()\n}\n```\n\n## Part II\n\nThe elves are also running low on ribbon. Ribbon is all the same width, so they only have to worry about the length they need to order, which they would again like to be exact.\n\nThe ribbon required to wrap a present is the shortest distance around its sides, or the smallest perimeter of any one face. Each present also requires a bow made out of ribbon as well; the feet of ribbon required for the perfect bow is equal to the cubic feet of volume of the present. Don't ask how they tie the bow, though; they'll never tell.\n\nFor example:\n\n> A present with dimensions `2x3x4` requires `2+2+3+3 = 10` feet of ribbon to wrap the present plus `2*3*4 = 24` feet of ribbon for the bow, for a total of `34` feet.\n>\n> A present with dimensions `1x1x10` requires `1+1+1+1 = 4` feet of ribbon to wrap the present plus `1*1*10 = 10` feet of ribbon for the bow, for a total of `14` feet.\n\nHow many total feet of ribbon should they order?\n\n## Solution\n\nA method `get_smallest_perimeter` that would return the smallest perimeter of the prism.\n\nTo find the answer iterate over the Vector<Prism> calculate the `smallest_perimeter` + `sum of the sides of the smallest perimeter` and sum them all up.\n\n```rust\nimpl Prism {\n    pub fn get_smallest_side_area(self) -> u32 {\n        *[self.x * self.y, self.y * self.z, self.z * self.x]\n            .iter()\n            .min()\n            .unwrap_or(&0)\n    }\n\n    pub fn get_area(self) -> u32 {\n        [\n            2 * self.x * self.y,\n            2 * self.y * self.z,\n            2 * self.z * self.x,\n        ]\n        .iter()\n        .sum::<u32>()\n    }\n    // PART 2\n    pub fn get_smallest_perimeter(self) -> u32 {\n        *[\n            2 * (self.x + self.y),\n            2 * (self.y + self.z),\n            2 * (self.z + self.x),\n        ]\n        .iter()\n        .min()\n        .unwrap_or(&0)\n    }\n}\n\n#[aoc(day2, part2)]\npub fn part2(input: &[Prism]) -> u32 {\n    input\n        .iter()\n        .map(|x| x.get_smallest_perimeter() + (x.x * x.y * x.z))\n        .collect::<Vec<u32>>()\n        .iter()\n        .sum()\n}\n\n```\n\n","n":0.038}}},{"i":70,"$":{"0":{"v":"Day 12","n":0.707},"1":{"v":"## Day 12: JSAbacusFramework.io\n\n# Part I\n\nSanta's Accounting-Elves need help balancing the books after a recent order. Unfortunately, their accounting software uses a peculiar storage format. That's where you come in.\n\nThey have a JSON document which contains a variety of things: arrays (`[1,2,3]`), objects (`{\"a\":1, \"b\":2}`), numbers, and strings.\n\n Your first job is to simply find all of the numbers throughout the document and add them together.\n\nFor example:\n\n> `[1,2,3]` and `{\"a\":2,\"b\":4}` both have a sum of `6`.\n>\n> `[[[3]]] and {\"a\":{\"b\":4},\"c\":-1}` both have a sum of `3`.\n>\n> `{\"a\":[-1,1]} and [-1,{\"a\":1}]` both have a sum of `0`.\n>\n> `[]` and `{}` both have a sum of `0`.\n\nYou will not encounter any strings containing numbers.\n\nWhat is the sum of all numbers in the document?\n\n## Solution\n\n## Without Serde\n\n```rust\npub fn part1(input: &str) -> i32 {\n    let mut value = 0i32;\n    let mut tmp_val = 0i32;\n    let mut last: char = '\\x00';\n    let mut multiplier = 1;\n    for ch in input.chars() {\n        value += match ch {\n            '0'...'9' => {\n                if last == '-' {\n                    multiplier = -1;\n                }\n                tmp_val = tmp_val * 10\n                    + match ch.to_string().parse::<i32>() {\n                        Ok(x) => x,\n                        Err(e) => panic!(\"Help! {}\", e),\n                    };\n\n                0\n            }\n            _ if last.is_digit(10) => {\n                let tmp = tmp_val * multiplier;\n                tmp_val = 0;\n                multiplier = 1;\n\n                tmp\n            }\n            _ => 0,\n        };\n        last = ch;\n    }\n    value\n}\n```\n\n### With Serde\n\n```rust\nfn sum(v: Value, use_red: bool) -> i64 {\n    match v {\n        Value::Null => 0,\n        Value::Bool(_) => 0,\n        Value::Number(n) => n.as_i64().unwrap(),\n        Value::String(_) => 0,\n        Value::Array(v) => v.into_iter().map(|e| sum(e, use_red)).sum(),\n        Value::Object(v) => {\n            let mut max = 0;\n            for v in v.values() {\n                if (v == \"red\") && !use_red {\n                    return 0;\n                }\n                max += sum(v.clone(), use_red);\n            }\n            return max;\n        }\n    }\n}\n\n#[aoc(day11, part1, Serde)]\npub fn part1_serde(input: &str) -> i64 {\n    let a = serde_json::from_str(&input).unwrap();\n    sum(a, true)\n}\n\n```\n\n## Part II\n\nUh oh - the Accounting-Elves have realized that they double-counted everything red.\n\nIgnore any object (and all of its children) which has any property with the value `\"red\"`. Do this only for objects (`{...}`), not arrays (`[...]`).\n\n> [1,2,3] still has a sum of 6.\n>\n> [1,{\"c\":\"red\",\"b\":2},3] now has a sum of 4, because the middle object is ignored.\n>\n> {\"d\":\"red\",\"e\":[1,2,3,4],\"f\":5} now has a sum of 0, because the entire structure is ignored.\n>\n> [1,\"red\",5] has a sum of 6, because \"red\" in an array has no effect.\n\n## Solution\n\n```rust\nfn sum(v: Value, use_red: bool) -> i64 {\n    match v {\n        Value::Null => 0,\n        Value::Bool(_) => 0,\n        Value::Number(n) => n.as_i64().unwrap(),\n        Value::String(_) => 0,\n        Value::Array(v) => v.into_iter().map(|e| sum(e, use_red)).sum(),\n        Value::Object(v) => {\n            let mut max = 0;\n            for v in v.values() {\n                if (v == \"red\") && !use_red {\n                    return 0;\n                }\n                max += sum(v.clone(), use_red);\n            }\n            return max;\n        }\n    }\n}\n\n#[aoc(day11, part2, Serde)]\npub fn part2_serde(input: &str) -> i64 {\n    let a = serde_json::from_str(&input).unwrap();\n    sum(a, false)\n}\n```\n\n","n":0.047}}},{"i":71,"$":{"0":{"v":"Day 11","n":0.707},"1":{"v":"## Corporate Policy\n\n## Part I\n\nSanta's previous password expired, and he needs help choosing a new one.\n\nTo help him remember his new password after the old one expires, Santa has devised a method of coming up with a password based on the previous one. Corporate policy dictates that passwords must be exactly eight lowercase letters (for security reasons), so he finds his new password by incrementing his old password string repeatedly until it is valid.\n\nIncrementing is just like counting with numbers: `xx`, `xy`, `xz`, `ya`, `yb`, and so on. Increase the rightmost letter one step; if it was z, it wraps around to a, and repeat with the next letter to the left until one doesn't wrap around.\n\nUnfortunately for Santa, a new Security-Elf recently started, and he has imposed some additional password requirements:\n\n> Passwords must include one increasing straight of at least three letters, like `abc`, `bcd`, `cde`, and so on, up to `xyz`. They cannot skip letters; `abd` doesn't count.\n>\n> Passwords may not contain the letters `i`, `o`, or `l`, as these letters can be mistaken for other characters and are therefore confusing.\n>\n> Passwords must contain at least two different, non-overlapping pairs of letters, like `aa`, `bb`, or `zz`.\n\nFor example:\n\n> `hijklmmn` meets the first requirement (because it contains the straight `hij`) but fails the second requirement requirement (because it contains `i` and `l`).\n>\n> `abbceffg` meets the third requirement (because it repeats `bb` and `ff`) but fails the first requirement.\n>\n> `abbcegjk` fails the third requirement, because it only has one double letter (`bb`).\n>\n> The next password after `abcdefgh` is `abcdffaa`.\n>\n> The next password after `ghijklmn` is `ghjaabcc`, because you eventually skip all the passwords that start with `ghi...`, since `i` is not allowed.\n\nGiven Santa's current password (your puzzle input), what should his next password be?\n\n## Solution\n\n```rust\nfn condition_3(string: &str) -> bool {\n    !string.chars().any(|c| match c {\n        'i' | 'o' | 'l' => true,\n        _ => false,\n    })\n}\n\nfn condition_2(string: &str) -> bool {\n    string\n        .as_bytes()\n        .windows(3)\n        .any(|w| w[0] + 1 == w[1] && w[1] + 1 == w[2])\n}\n\nfn condition_1(string: &str) -> bool {\n    let a = string.as_bytes().iter();\n    let b = string.as_bytes()[1..].iter();\n    let mut i = a.zip(b);\n    let mut c = 0;\n    while c < 2 {\n        if let Some((x, y)) = i.next() {\n            if x == y {\n                c += 1;\n                i.next();\n                i.next();\n            }\n        } else {\n            break;\n        }\n    }\n    c >= 2\n}\n\nfn next(string: &str) -> String {\n    let mut result = String::new();\n    for (i, c) in string.chars().rev().enumerate() {\n        match c {\n            'z' => result.push('a'),\n            _ => {\n                result.push(((c as u8) + 1) as char);\n                result.extend(\n                    string\n                        .chars()\n                        .rev()\n                        .skip(i + 1)\n                        .take(string.len() - i)\n                        .collect::<Vec<_>>(),\n                );\n                break;\n            }\n        }\n    }\n    result.chars().rev().collect::<String>()\n}\n\n#[aoc(day11, part1)]\npub fn part1(input: &str) -> String {\n    let mut password = input.to_string();\n\n    while !(condition_1(&password) && condition_3(&password) && condition_2(&password)) {\n        password = next(&password);\n    }\n    password\n}\n```\n\n## Part II\n\nSanta's password expired again. What's the next one?\n\n```rust\n#[aoc(day11, part2)]\npub fn part2(input: &str) -> String {\n    let mut password = part1(input);\n    password = next(&password);\n    while !(condition_1(&password) && condition_3(&password) && condition_2(&password)) {\n        password = next(&password);\n    }\n    password\n}\n```\n\n","n":0.045}}},{"i":72,"$":{"0":{"v":"Day 10","n":0.707},"1":{"v":"## Elves Look, Elves Say\n\n## Part I\n\nToday, the Elves are playing a game called look-and-say. They take turns making sequences by reading aloud the previous sequence and using that reading as the next sequence. For example, 211 is read as \"one two, two ones\", which becomes `1221` (`1` `2`, `2` `1`s).\n\nLook-and-say sequences are generated iteratively, using the previous value as input for the next step. For each step, take the previous value, and replace each run of digits (like `111`) with the number of digits (`3`) followed by the digit itself (`1`).\n\nFor example:\n\n> `1` becomes `11` (`1` copy of digit `1`).\n>\n> `11` becomes `21` (`2` copies of digit `1`).\n>\n> `21` becomes `1211` (one `2` followed by one `1`).\n>\n> `1211` becomes `111221` (one `1`, one `2`, and two `1`s).\n>\n> `111221` becomes `312211` (three `1`s, two `2`s, and one `1`).\n\nStarting with the digits in your puzzle input, apply this process 40 times.\n\n What is the length of the result?\n\n## Solution\n\n```rust\n#[aoc(day10, part1)]\npub fn part1(input: &str) -> usize {\n    let mut s = input.to_string();\n    for _ in 0..40 {\n        let mut v: Vec<(u16, char)> = Vec::new();\n        let mut iter = s.chars();\n        let mut curr = (1, iter.next().unwrap());\n        for i in iter {\n            if i != curr.1 {\n                v.push(curr);\n                curr = (1, i);\n            } else {\n                curr.0 += 1;\n            }\n        }\n        v.push(curr);\n        s.clear();\n        for i in v {\n            s.push_str(&i.0.to_string());\n            s.push(i.1)\n        }\n    }\n    s.chars().count()\n}\n```\n\n## Part II\n\nNeat, right? You might also enjoy hearing John Conway talking about this sequence (that's Conway of Conway's Game of Life fame).\n\nNow, starting again with the digits in your puzzle input, apply this process 50 times. What is the length of the new result?\n\n## Solution\n\n```rust\n#[aoc(day10, part2)]\npub fn part2(input: &str) -> usize {\n    let mut s = input.to_string();\n    for _ in 0..50 {\n        let mut v: Vec<(u16, char)> = Vec::new();\n        let mut iter = s.chars();\n        let mut curr = (1, iter.next().unwrap());\n        for i in iter {\n            if i != curr.1 {\n                v.push(curr);\n                curr = (1, i);\n            } else {\n                curr.0 += 1;\n            }\n        }\n        v.push(curr);\n        s.clear();\n        for i in v {\n            s.push_str(&i.0.to_string());\n            s.push(i.1)\n        }\n    }\n    s.chars().count()\n}\n```\n\n","n":0.054}}},{"i":73,"$":{"0":{"v":"Day 1","n":0.707},"1":{"v":"## Not Quite Lisp\n\nSanta was hoping for a white Christmas, but his weather machine's \"snow\" function is powered by stars, and he's fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\n\n## Part I\n\nSanta is trying to deliver presents in a large apartment building, but he can't find the right floor - the directions he got are a little confusing.\n He starts on the ground floor (floor `0`) and then follows the instructions one character at a time.\n\nAn opening parenthesis, `(`, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\n\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\n\nFor example:\n\n> `(())` and `()()` both result in floor `0`.\n>\n> `(((` and `(()(()(` both result in floor `3`.\n>\n> `))(((((` also results in floor `3`.\n>\n> `())` and `))(` both result in floor `-1` (the first basement\n> level).\n>\n> `)))` and `)())())` both result in floor `-3`.\n\nTo what floor do the instructions take Santa?\n\n## Solution\n\nThe easiest way to solve this problem would be to split the input string into chars and iterate over each character.\n\nAfter that we use the [iterator::fold](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.fold) method of the iterator over the characters.\n\nFor each `(` we increment a sum value by 1 and for ')' we decrement a sum value by 1.\n\n```rust\n#[aoc(day1, part1)]\npub fn part1(input: &str) -> i32 {\n    input.chars().fold(0, |sum, c| match c {\n        '(' => sum + 1,\n        ')' => sum - 1,\n        _ => unreachable!(),\n    })\n}\n```\n\n## Part II\n\nNow, given the same instructions, find the position of the first character that causes him to enter the basement (floor -1).\n\n The first character in the instructions has position 1, the second character has position 2, and so on.\n\nFor example:\n\n> `)` causes him to enter the basement at character position `1`.\n>\n> `()())` causes him to enter the basement at character position `5`.\n\nWhat is the position of the character that causes Santa to first enter the basement?\n\n## Solution\n\nThe easiest way to solve this would be be to keep a check if the sum value every becomes less than 0.\n\nThis condition can be easily identified by using the [checked_sub](https://doc.rust-lang.org/std/primitive.isize.html#method.checked_sub)\n\n```rust\n#[aoc(day1, part2)]\npub fn part2(input: &str) -> usize {\n    let mut sum: u32 = 0;\n    for (i, c) in input.chars().enumerate() {\n        match c {\n            '(' => sum += 1,\n            ')' => {\n                if let Some(s) = sum.checked_sub(1) {\n                    sum = s;\n                } else {\n                    return i + 1;\n                }\n            }\n            _ => unreachable!(),\n        }\n    }\n    unreachable!()\n}\n```\n\n","n":0.049}}},{"i":74,"$":{"0":{"v":"Algos","n":1}}},{"i":75,"$":{"0":{"v":"Trees","n":1}}},{"i":76,"$":{"0":{"v":"maxDepth","n":1},"1":{"v":"## Maximum Depth of Binary Tree\n\nGiven the `root` of a binary tree, return its maximum depth\n\n## Binary Tree\n\n![](/assets/images/2021-07-17-12-08-23.png)\n\n## Solution\n\n### Python\n\n```python\ndef maxDepth(root:TreeNode)-> int:\n    if not root:\n        return 0\n    else:\n        max(self.maxDepth(root.left),self.maxDepth(root.right))+1\n```\n\n### Go\n\n```go\nimport(\n\"math\"\n)\nfunc maxDepth(root *TreeNode) int {\n    if root == nil{\n        return 0\n    }\n    return int(math.Max(float64(maxDepth(root.Left)),float64(maxDepth(root.Right)))) +1\n}\n```\n\n### Rust\n\n```rust\nfn maxDepth(root:Option<Rc<RefCell<TreeNode>>>>>)-> i32{\n match root {\n            Some(a) => {\n                let l = Solution::max_depth(a.borrow().left.clone());\n                let r = Solution::max_depth(a.borrow().right.clone());\n                return std::cmp::max(l, r) + 1;\n            }\n            None => return 0,\n        }\n}\n```\n\n","n":0.118}}},{"i":77,"$":{"0":{"v":"Binary Tree","n":0.707}}},{"i":78,"$":{"0":{"v":"Binary Tree Traversal","n":0.577},"1":{"v":"## Graph\n\n![](/assets/images/2021-07-17-12-08-23.png)\n\n# PreOrder\n\n## Root --> Left --> Right\n\n## F B A D C E G I H\n\n## Code\n\n```python\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\n    if root == None :\n        return []\n    res= []\n    res.append(root.val)\n    if root.left!= None:\n        res = res + self.preorderTraversal(root.left)\n    if root.right!= None:\n        res = res + self.preorderTraversal(root.right)\n    return res\n```\n\n# InOrder\n\n## Left --> Root --> Right\n\n## A B C D E F G I J\n\n## Code\n\n```python\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\n    if root == None :\n        return []\n    res = []\n    if root.left!= None:\n        res = res + self.inorderTraversal(root.left)\n    res.append(root.val)\n    if root.right!= None:\n        res = res + self.inorderTraversal(root.right)\n    return res\n```\n\n# Post Order\n\n## Left --> Right --> Root\n\n## A C E D B H I G F\n\n## Code\n\n```python\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\n    if root == None :\n        return []\n    res= []\n    if root.left!= None:\n        res = res + self.postorderTraversal(root.left)\n    if root.right!= None:\n        res = res + self.postorderTraversal(root.right)\n    res.append(root.val)\n    return res\n```\n\n# Iterative Tree\n\n## Use Stack\n\n1. Push Root to stack\n2. Pop From Stack\n3. Push Popped Item left tree\n4. Push Popped Item right tree\n\n# Level Order\n\n## Use Queue\n\n1. Take Node\n2. Push Children into Queue\n3. Remove From Queue\n4. Go to Step 1\n\n## F, B G, A D I, C E H\n\n## Code\n\n```python\ndef levelOrder(self, root: TreeNode) -> List[List[int]]:\n    if not root:\n        return []\n    res, temp, queue, flag=[], [], [root], 1\n    while queue:\n        for i in iter(range(len(queue))):\n            ptr = queue.pop(0)\n            temp+=[ptr.val]\n            if ptr.left: queue+=[ptr.left]\n            if ptr.right: queue+=[ptr.right]\n        res+=[temp[::flag]]\n        temp=[]\n        flag = flag*-1\n    return res\n```\n\n","n":0.065}}},{"i":79,"$":{"0":{"v":"Sort","n":1}}},{"i":80,"$":{"0":{"v":"Selection Sort","n":0.707},"1":{"v":"\n# Selection Sort\n\nSelection sort finds the smallest element in the array and place it on the first place on the list, then it finds the second smallest element in the array and place it on the second place.\n\n\n## Time Complexity\n\n### Best: O(n*n)\n\n### Average: O(n*n)\n\n### Worst: O(n*n)\n\n## Space Complexity: O(1)\n\n# Implementation\n\n## [[python]]\n\n```python\ndef selectionSort(arr):\n    for i in range(len(arr)):\n        minIdx = 1\n        for j in range(i+1,len(arr)):\n            if arr[minIdx]>arr[j]:\n                arr[minIdx], arr[j] = arr[j], arr[minIdx]\n\na = [64, 25, 12, 22, 11]\nselectionSort(a)\nprint(a) #[11, 12, 22, 25, 64]\n\n```\n\n","n":0.111}}},{"i":81,"$":{"0":{"v":"Quick Sort","n":0.707},"1":{"v":"# Quick Sort\n\nIt is a Divide and Conquer Algorithm.\n\nPick an element in the array as `pivot` and move all elements less than pivot to its left and all elements greater to its right\n\n\n## Time Complexity\n\n### Best: O(nlog(n))\n\n### Average: O(nlog(n))\n\n### Worst: O(n*n)\n\n## Space Complexity: O(log(n))\n\n# Implementation\n\n## [[python]]\n\n```python\ndef quickSort(nums):\n    quickSortHelper(nums, 0, len(nums)-1)\n\n\ndef quickSortHelper(nums, low, high):\n    if low < high:\n        partitionIdx = partition(nums, low, high)\n        quickSortHelper(nums, low, partitionIdx-1)\n        quickSortHelper(nums, partitionIdx+1, high)\n\n\ndef partition(nums, low, high):\n    ptr = low\n    pivot = nums[ptr]\n    while low < high:\n        while low < len(nums) and nums[low] <= pivot:\n            low = low + 1\n        while nums[high] > pivot:\n            high = high - 1\n        if low < high:\n            nums[low], nums[high] = nums[high], nums[low]\n    print(high, ptr)\n    nums[high], nums[ptr] = nums[ptr], nums[high]\n    return high\n\n\narray = [10, 7, 8, 9, 1, 5]\nquickSort(array)\nprint(array)\n\n\n```","n":0.088}}},{"i":82,"$":{"0":{"v":"Lc","n":1}}},{"i":83,"$":{"0":{"v":"Find First and Last position of element in a sorted array","n":0.302},"1":{"v":"\nGiven an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n\nIf target is not found in the array, return [-1, -1].\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n\n\nExample 1:\n```\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\n```\n\nExample 2:\n```\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\n```\n\nExample 3:\n```\nInput: nums = [], target = 0\nOutput: [-1,-1]\n```\n\n\nConstraints:\n\n    0 <= nums.length <= 105\n    -109 <= nums[i] <= 109\n    nums is a non-decreasing array.\n    -109 <= target <= 109\n\n[[python]]\n```python\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        if len(nums) ==0:\n            return [-1,-1]\n        left = findStart(nums,target)\n        right = findEnd(nums,target)\n        return [left,right]\n\ndef findStart(nums,target):\n    idx = -1\n    low = 0\n    high = len(nums)-1\n\n    while low<=high:\n        mid = math.floor(low + (high - low)/2)\n        if nums[mid] ==target:\n            idx = mid\n            high = mid -1\n        elif nums[mid]>target:\n            high = mid -1\n        else:\n            low = mid+1\n    return idx\n\ndef findEnd(nums,target):\n    idx = -1\n    low = 0\n    high = len(nums)-1\n\n    while low<=high:\n        mid = math.floor(low + (high - low)/2)\n        if nums[mid] ==target:\n            idx = mid\n            low = mid +1\n        elif nums[mid]>target:\n            high = mid -1\n        else:\n            low = mid+1\n    return idx\n\n```","n":0.073}}},{"i":84,"$":{"0":{"v":"Dynamic Programming","n":0.707},"1":{"v":"\n# Intro\nDynamic programming is a powerful tool because it can break a complex problem into manageable subproblems, avoid unnecessary recalculation of overlapping subproblems, and use the results of those subproblems to solve the initial complex problem.\n\nMost common features of a dp problem\n\n- The problem can be broken down into \"overlapping subproblems\" - smaller versions of the original problem that are re-used multiple times\n\n- The problem has an \"optimal substructure\" - an optimal solution can be formed from optimal solutions to the overlapping subproblems of the original problem\n\n\n# Two Ways for DP\n\n## Memoization\n\n> **memoizing** a result means to store the result of a function call, usually in a hashmap or an array, so that when the same function call is made again, we can simply return the memoized result instead of recalculating the result.\n\n- Top Down approach\n- Implemented via recursion and optimized via memoization\n\n\n## Tabulation\n\n- Bottom Up Approach\n- Implemented via iteration\n\n# Identifying DP\n\nThe **first characteristic** that is common in DP problems is that the problem will ask for the optimum value (maximum or minimum) of something, or the number of ways there are to do something.\n\nFor example:\n\n> What is the minimum cost of doing...\n> What is the maximum profit from...\n> How many ways are there to do...\n> What is the longest possible...\n> Is it possible to reach a certain point...\n\n\nThe **second characteristic** that is common in DP problems is that future \"decisions\" depend on earlier decisions. Deciding to do something at one step may affect the ability to do something in a later step.\nThis characteristic is what makes a greedy algorithm invalid for a DP problem - we need to factor in results from previous decisions.\n\n\n# The Framework\n\n1. A function or data structure that will compute/contain the answer to the problem for every given state.\n2. A recurrence relation to transition between states.\n3. Base cases, so that our recurrence relation doesn't go on infinitely.","n":0.057}}},{"i":85,"$":{"0":{"v":"DailyByte","n":1}}},{"i":86,"$":{"0":{"v":"Stones and Jewels","n":0.577},"1":{"v":"## Problem\n\nThis question is asked by Amazon.\n\nGiven a string representing your stones and another string representing a list of jewels, return the number of stones that you have that are also jewels.\n\nEx: Given the following jewels and stones...\n\n> jewels = \"abc\", stones = \"ac\", return 2\n>\n> jewels = \"Af\", stones = \"AaaddfFf\", return 3\n>\n> jewels = \"AYOPD\", stones = \"ayopd\", return 0\n\n## [[python]]\n\n```python\ndef is_jewel_and_stone(jewels,stones):\n    return len(set(jewels).intersection(set(stones)))\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.121}}},{"i":87,"$":{"0":{"v":"Two Sum","n":0.707},"1":{"v":"## Problem\n\nThis question is asked by Google.\n\nGiven an array of integers, return whether or not two numbers sum to a given target, k.\n\nNote: you may not sum a number with itself.\n\nEx: Given the following...\n\n> [1, 3, 8, 2], k = 10, return true (8 + 2)\n>\n> [3, 9, 13, 7], k = 8, return false\n>\n> [4, 2, 6, 5, 2], k = 4, return true (2 + 2)\n\n## [[python]]\n\n```python\ndef twoSum(nums: List[int], target: int) -> List[int]:\n    num_map = {}\n    for idx,x in enumerate(nums):\n        if target-x in num_map:\n            return true\n            #return[idx,num_map[target-x]]\n        else:\n            num_map[x] = idx\n\n```\n\n## [[go]]\n\n```go\nfunc twoSum(nums []int, target int) []int {\n    var seen  = make(map[int]int)\n    for i,v := range nums{\n        idx := target - v\n        _,exists := seen[idx]\n        if exists {\n            return true\n            //return []int{i,seen[idx]}\n        }\n        seen[v]=i\n    }\n    return[]int{}\n}\n```\n\n## [[rust]]\n\n","n":0.088}}},{"i":88,"$":{"0":{"v":"Is Palindrome Again ??","n":0.5},"1":{"v":"## Problem\n\nThis question is asked by Facebook.\n\nGiven a string and the ability to delete at most one character, return whether or not it can form a palindrome.\n\nNote: a palindrome is a sequence of characters that reads the same forwards and backwards.\n\nEx: Given the following strings...\n\n> \"abcba\", return true\n>\n> \"foobof\", return true (remove the first 'o', the second 'o', or 'b')\n>\n> \"abccab\", return false\n\n## [[python]]\n\n```python\ndef validPalindrome(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            one, two = s[left:right], s[left + 1:right + 1]\n            return one == one[::-1] or two == two[::-1]\n        left, right = left + 1, right - 1\n    return True\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.095}}},{"i":89,"$":{"0":{"v":"Longest Common Shared Prefix","n":0.5},"1":{"v":"## Problem\n\nThis question is asked by Microsoft.\n\nGiven an array of strings, return the longest common prefix that is shared amongst all strings.\n\nNote: you may assume all strings only contain lowercase alphabetical characters.\n\nEx: Given the following arrays...\n\n> [\"colorado\", \"color\", \"cold\"], return \"col\"\n>\n> [\"a\", \"b\", \"c\"], return \"\"\n>\n> [\"spot\", \"spotty\", \"spotted\"], return \"spot\"\n\n## [[python]]\n\n```python\ndef longestCommonPrefix(strs)->string:\n        sz, ret = zip(*strs), \"\"\n        for c in sz:\n            if len(set(c)) > 1: break\n            ret += c[0]\n        return ret\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.116}}},{"i":90,"$":{"0":{"v":"Word Search","n":0.707},"1":{"v":"\n# Problem\n\nThis question is asked by Amazon.\n\n Given a 2D board that represents a word search puzzle and a string word, return whether or the given word can be formed in the puzzle by only connecting cells horizontally and vertically.\n\nEx: Given the following board and words‚Ä¶\n\n```\nboard =\n[\n  ['C','A','T','F'],\n  ['B','G','E','S'],\n  ['I','T','A','E']\n]\nword = \"CAT\", return true\nword = \"TEA\", return true\nword = \"SEAT\", return true\nword = \"BAT\", return false\n```\n\n## [[python]]\n\n```python\ndef exist(self, board, word):\n    self.word = word\n    self.found = False\n    for row in range(len(board)):\n        for col in range(len(board[0])):\n            self.visited = []\n            self.visitedSet = set()\n            self.dfs(board,row,col,0)\n            if self.found:\n                return True\n    return False\n\n\ndef dfs(self,board,row,col,i):\n\n    if i == len(self.word):\n        self.found = True\n\n    if not self.found and row >= 0 and col >= 0 and row<len(board) and col<len(board[0]) and board[row][col] == self.word[i] and (row,col) not in self.visitedSet:\n        self.visited += [(row,col)]\n        self.visitedSet.add((row,col))\n        self.dfs(board,row+1,col,i+1)\n        self.dfs(board,row-1,col,i+1)\n        self.dfs(board,row,col+1,i+1)\n        self.dfs(board,row,col-1,i+1)\n\n        if not self.found:\n            self.visitedSet.remove(self.visited.pop())\n\n```\n## [[go]]\n\n## [[rust]]","n":0.084}}},{"i":91,"$":{"0":{"v":"Binary Sum","n":0.707},"1":{"v":"## Problem\n\nThis question is asked by Apple.\n\nGiven two binary strings (strings containing only 1s and 0s) return their sum (also as a binary string).\n\nNote: neither binary string will contain leading 0s unless the string itself is 0\n\nEx: Given the following binary strings...\n\n> \"100\" + \"1\", return \"101\"\n>\n> \"11\" + \"1\", return \"100\"\n>\n> \"1\" + \"0\", return  \"1\"\n\n## [[python]]\n\n```python\ndef add(num1:str, num2:str)->str:\n    return bin(int(num1,2)+int(num2,2))[2:]\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.125}}},{"i":92,"$":{"0":{"v":"Generate Search Message","n":0.577},"1":{"v":"\n# Problem\n\nThis question is asked by Google.\n\nGiven a string of digits, return all possible text messages those digits could send.\n\nNote: The mapping of digits to letters is as follows‚Ä¶\n```\n0 -> null\n1 -> null\n2 -> \"abc\"\n3 -> \"def\"\n4 -> \"ghi\"\n5 -> \"jkl\"\n6 -> \"mno\"\n7 -> \"pqrs\"\n8 -> \"tuv\"\n9 -> \"wxyz\"\n```\n\n```\nEx: digits = \"23\" return [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n```\n\n## [[python]]\n\n```python\ndef generateMessage(digits):\n    chars_map = { 2: \"abc\", 3:\"def\", 4:\"ghi\", 5:\"jkl\", 6:\"mno\", 7:\"pqrs\", 8:\"tuv\", 9:\"wxyz\"}\n    message = []\n    for c in digits:\n        digit = int(c)\n        chars = chars_map.get(digit)\n        if chars is None:\n            continue\n        if len(message) == 0:\n            message = list(chars)\n        else:\n            perms = [ head + char for head in perms for char in chars]\n    return perms\n```\n\n## [[go]]\n\n## [[rust]]\n","n":0.091}}},{"i":93,"$":{"0":{"v":"String Permutations","n":0.707},"1":{"v":"\n# Problem\n\nThis question is asked by Amazon. Given a string s consisting of only letters and digits, where we are allowed to transform any letter to uppercase or lowercase, return a list containing all possible permutations of the string.\n\nEx: Given the following string‚Ä¶\n```\nS = \"c7w2\", return [\"c7w2\", \"c7W2\", \"C7w2\", \"C7W2\"]\n```\n\n## [[python]]\n\n```python\ndef letterCasePermutation(self, S):\n    def backtrack(sub=\"\", i=0):\n        if len(sub) == len(S):\n            res.append(sub)\n        else:\n            if S[i].isalpha():\n                backtrack(sub + S[i].swapcase(), i + 1)\n            backtrack(sub + S[i], i + 1)\n\n    res = []\n    backtrack()\n    return res\n``\n## [[go]]\n\n## [[rust]]\n\n","n":0.109}}},{"i":94,"$":{"0":{"v":"Sum Left Leaves","n":0.577},"1":{"v":"\n# Problem\nGiven a binary tree, return the sum of all left leaves of the tree. Ex: Given the following tree‚Ä¶\n\n<pre\n    5\n   / \\\n  2   12\n     /  \\\n    3    8\nreturn 5 (i.e. 2 + 3)\n</pre>\n\nEx: Given the following tree‚Ä¶\n\n<pre>\n       2\n      / \\\n    4    2\n   / \\\n  3   9\nreturn 3\n</pre>\n\n## [[python]]\n\n```python\ndef isLeaf(node):\n    if node is None:\n        return False\n    if node.left is None and node.right is None:\n        return True\n    return False\n\ndef leftLeavesSum(root):\n    res = 0\n    if root is not None:\n        if isLeaf(root):\n            res += root.left.key\n        else:\n            res += leftLeavesSum(root.left)\n        res += leftLeavesSum(root.right)\n    return res\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.104}}},{"i":95,"$":{"0":{"v":"Same Leaves","n":0.707},"1":{"v":"\n# Problem\n\nGiven two binary trees, return whether or not both trees have the same leaf sequence.\n\nTwo trees have the same leaf sequence if both trees‚Äô leaves read the same from left to right.\n\nEx: Given the following trees‚Ä¶\n<pre>\n   1\n /   \\\n1     3\n</pre>\nand\n\n<pre>\n   7\n /   \\\n1     2\n</pre>\n\nreturn false as both the trees' leaves don't read the same from left to right (i.e. [1, 3] and [1, 2]).\n\nEx: Given the following trees‚Ä¶\n<pre>\n    8\n   / \\\n  2   29\n    /  \\\n   3    9\n</pre>\nand\n<pre>\n    8\n   / \\\n  2  29\n /   /  \\\n2   3    9\n     \\\n      3\n</pre>\n\nreturn true as both the trees' leaves read the same from left to right (i.e. [2, 3, 9] and [2, 3, 9]).\n\n## [[python]]\n\n```python\ndef sameleaves(root1, root2):\n    output1 = []\n    output2 = []\n    get_leaves(root1, output1)\n    get_leaves(root2, output2)\n\n    if len(output1) != len(output2):\n        return False\n\n\n    for el1,el2 in zip(output1, output2):\n        if el1 != el2:\n            return False\n\n    return True\n\n\ndef get_leaves(node, output):\n\n    if not node:\n        return\n\n    if not node.left and not node.right:\n        output.append(node.value)\n\n    get_leaves(node.left, output)\n    get_leaves(node.right, output)\n\n```\n\n## [[go]]\n\n## [[rust]]","n":0.079}}},{"i":96,"$":{"0":{"v":"Is Symmetric Tree","n":0.577},"1":{"v":"# Problem\n\nGiven a binary tree, return whether or not it forms a reflection across its center (i.e. a line drawn straight down starting from the root).\nNote: a reflection is when an image, flipped across a specified line, forms the same image.\n\nEx: Given the following tree‚Ä¶\n<pre>\n   2\n /   \\\n1     1\n</pre>\nreturn true as when the tree is reflected across its center all the nodes match.\n\nEx: Given the following tree‚Ä¶\n<pre>\n    1\n   / \\\n  5   5\n   \\    \\\n    7    7\n</pre>\nreturn false as when the tree is reflected across its center the nodes containing sevens do not match.\n\n## [[python]]\n\n```python\ndef isSymmetric(root):\n    return self.isMirror(root.left, root.right)\n\ndef isMirror(t1,t2):\n    if t1 is None and t2 is None:\n        return True\n    if t1 is None or t2 is None:\n        return True\n    return t1.val == t2.val and isMirror(t1.right,t2.left) and isMirror(t1.right,t2.left)\n```\n\n## [[go]]\n\n## [[rust]]","n":0.088}}},{"i":97,"$":{"0":{"v":"Binary Path Sum","n":0.577},"1":{"v":"\n# Problem\n\nGiven a binary tree and a target, return whether or not there exists a root to leaf path such that all values along the path sum to the target.\n\nEx: Given the following tree‚Ä¶\n<pre>\n      1\n     / \\\n    5   2\n   /   / \\\n  1  12   29\n</pre>\n\nand a target of 15, return true as the path 1->2->12 sums to 15.\n\nEx: Given the following tree‚Ä¶\n<pre>\n     104\n    /   \\\n  39     31\n / \\    /  \\\n32  1  9    10\nand a target of 175, return true as the path 104->39->32 sums to 175.\n</pre>\n\n## [[python]]\n\n```python\ndef hasPathSum(root: TreeNode, targetSum: int) -> bool:\n        if root is None:\n            return False\n\n        targetSum -= root.val\n        if not root.left and not root.right:\n            return targetSum==0\n        return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right, targetSum)\n```\n## [[go]]\n\n## [[rust]]","n":0.092}}},{"i":98,"$":{"0":{"v":"Root To Leaf Paths","n":0.5},"1":{"v":"# Problem\n\nGiven a binary tree, return a list of strings containing all root to leaf paths.\n\nEx: Given the following tree‚Ä¶\n\n<pre>\n   1\n /   \\\n2     3\nreturn [\"1->2\", \"1->3\"]\n</pre>\n\nEx: Given the following tree‚Ä¶\n\n<pre>\n    8\n   / \\\n  2  29\n    /  \\\n   3    9\nreturn [\"8->2\", \"8->29->3\", \"8->29->9\"]\n</pre>\n\n## [[python]]\n\n```python\ndef binaryTreePath(root):\n    if not root:\n        return []\n    res, stack = [] ,[(root,\"\")]\n    while stack:\n        node, ls = stack.pop()\n        if not node.left and not node.right:\n            res.append(ls + str(node.val))\n        if node.right:\n            stack.append((node.right, ls+str(node.val) + \"->\"))\n        if node.left:\n            stack.append((node.left, ls+str(node.val) + \"->\"))\n    return res\n```\n## [[go]]\n\n## [[rust]]\n","n":0.108}}},{"i":99,"$":{"0":{"v":"Max Depth","n":0.707},"1":{"v":"\n\n# Problem\n\nGiven a binary tree, return its maximum depth.\n\nNote: the maximum depth is defined as the number of nodes along the longest path from root node to leaf node.\n\nEx: Given the following tree‚Ä¶\n<pre>\n    9\n   / \\\n  1   2\nreturn 2\n</pre>\n\nEx: Given the following tree‚Ä¶\n\n<pre>\n    5\n   / \\\n  1  29\n    /  \\\n   4   13\n\nreturn 3\n</pre>\n\n## [[python]]\n```python\ndef maxDepth(root):\n    if root is None:\n        return 0\n    return Math.max(maxDepth(root.left),maxDepth(root.right))\n```\n\n## [[go]]\n\n## [[rust]]","n":0.124}}},{"i":100,"$":{"0":{"v":"Gather Column","n":0.707},"1":{"v":"\n# Problem\nGiven a binary tree, return its column order traversal from top to bottom and left to right.\n\n Note: if two nodes are in the same row and column, order them from left to right.\n\nEx: Given the following tree‚Ä¶\n<pre>\n    8\n   / \\\n  2   29\n     /  \\\n    3    9\nreturn [[2], [8, 3], [29], [9]]\n</pre>\n\nEx: Given the following tree‚Ä¶\n\n<pre>\n     100\n    /   \\\n  53     78\n / \\    /  \\\n32  3  9    20\nreturn [[32], [53], [100, 3, 9], [78], [20]]\n</pre>\n\n## [[python]]\n```python\ndef helper(self, placement,level, root, dic):\n    if(not root):\n        return\n    dic[placement].append((level, root.val))\n    self.helper(placement-1, level+1, root.left, dic)\n    self.helper(placement+1, level+1, root.right, dic)\n\ndef verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n    dic = defaultdict(list)\n    self.helper(0,0, root, dic)\n    result = []\n    for i in sorted(dic.keys()):\n        temp = []\n        for j in sorted(dic[i]):\n            temp.append(j[1])\n        result.append(temp)\n    return result\n```\n## [[go]]\n\n## [[rust]]","n":0.089}}},{"i":101,"$":{"0":{"v":"Gather N-ary Tree Levels","n":0.5},"1":{"v":"\n# Problem\nGiven an n-ary tree, return its level order traversal.\nNote: an n-ary tree is a tree in which each node has no more than N children.\n\nEx: Give the following n-ary tree‚Ä¶\n<pre>\n    8\n  / | \\\n 2  3  29\nreturn [[8], [2, 3, 29]]\n</pre>\n\nEx: Given the following n-ary tree‚Ä¶\n\n<pre>\n     2\n   / | \\\n  1  6  9\n /   |   \\\n8    2    2\n   / | \\\n 19 12 90\nreturn [[2], [1, 6, 9], [8, 2, 2], [19, 12, 90]]\n</pre>\n\n## [[python]]\n```python\ndef naryTreeLevel(root):\n    if not root:\n        return []\n    q = [root]\n    view = []\n    while len(q):\n        temp_arr =[]\n        n = len(q)\n        for i in range(1,n+1):\n            temp = q[0]\n            q.pop(0)\n\n            temp_arr.append(temp.data)\n\n            for child in temp.children:\n                q.append(child)\n\n        view.append(temp_arr)\n    return view\n```\n## [[go]]\n\n## [[rust]]","n":0.094}}},{"i":102,"$":{"0":{"v":"Capitalized Properly ??","n":0.577},"1":{"v":"## Problem\n\nThis question is asked by Google.\n\nGiven a string, return whether or not it uses capitalization correctly. A string correctly uses capitalization if all letters are capitalized, no letters are capitalized, or only the first letter is capitalized.\n\nEx: Given the following strings...\n\n> \"USA\", return true\n>\n> \"Calvin\", return true\n>\n> \"compUter\", return false\n>\n> \"coding\", return true\n\n## [[python]]\n\n```python\ndef check(word:str)->bool:\n    if word.isupper():\n        return True\n    if word.islower():\n        return True\n    if word[0].isupper() and word[1:].islower():\n        return True\n    return False\n```\n\n## [[go]]\n\n```go\nfunc check(word string) bool {\n\tif isUpper(word) {\n\t\treturn true\n\t}\n\tif isLower(word) {\n\t\treturn true\n\t}\n\tif isUpper(word[:1]) && isLower(word[1:]) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isUpper(word string) bool {\n\tfor _, c := range word {\n\t\tif !unicode.IsUpper(c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc isLower(word string) bool {\n\tfor _, c := range word {\n\t\tif !unicode.IsLower(c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```\n\n## [[rust]]\n\n","n":0.092}}},{"i":103,"$":{"0":{"v":"Zig Zag Order","n":0.577},"1":{"v":"# Problem\nGiven a binary tree, return its zig-zag level order traversal (i.e. its level order traversal from left to right the first level, right to left the level the second, etc.).\n\nEx: Given the following tree‚Ä¶\n\n<pre>\n    1\n   / \\\n  2   3\nreturn [[1], [3, 2]]\n</pre>\n\nEx: Given the following tree‚Ä¶\n<pre>\n    8\n   / \\\n  2  29\n    /  \\\n   3    9\nreturn [[8], [29, 2], [3, 9]]\n</pre>\n## [[python]]\n```python\ndef zigZagOrderTraversal(root):\n    if not root:\n        return []\n    q = [root]\n    view = []\n    order = 1\n    while len(q):\n        temp_arr =[]\n        n = len(q)\n        for i in range(1,n+1):\n            temp = q[0]\n            q.pop(0)\n\n            temp_arr.append(temp.data)\n\n            if temp.left:\n                q.append(temp.left)\n\n            if temp.right:\n                q.append(temp.right)\n        view.append(temp_arr[::order])\n        order = order * -1\n    return view\n```\n\n## [[go]]\n\n## [[rust]]\n","n":0.096}}},{"i":104,"$":{"0":{"v":"Bottoms Up","n":0.707},"1":{"v":"\n# Problem\nGiven a binary tree, returns of all its levels in a bottom-up fashion (i.e. last level towards the root). Ex: Given the following tree‚Ä¶\n\n<pre>\n        2\n       / \\\n      1   2\nreturn [[1, 2], [2]]\n</pre>\n\nEx: Given the following tree‚Ä¶\n<pre>\n       7\n      / \\\n    6    2\n   / \\\n  3   3\nreturn [[3, 3], [6, 2], [7]]\n</pre>\n\n## [[python]]\n```python\ndef bottomToTop(root):\n    if not root:\n        return []\n    q = q[root]\n    view = []\n    while len(q):\n        temp_arr =[]\n        n = len(q)\n        for i in range(1,n+1):\n            temp = q[0]\n            q.pop(0)\n\n            temp_arr.append(temp.data)\n\n            if temp.left:\n                temp_arr.append(temp.left)\n\n            if temp.right:\n                temp_arr.append(temp.right)\n        view.append(temp_arr)\n    return view[::-1]\n```\n## [[go]]\n\n## [[rust]]\n","n":0.105}}},{"i":105,"$":{"0":{"v":"Visible Values","n":0.707},"1":{"v":"\n# Problem\n\nGiven a binary tree return all the values you‚Äôd be able to see if you were standing on the left side of it with values ordered from top to bottom.\n\nEx: Given the following tree‚Ä¶\n\n<pre>\n-->    4\n      / \\\n-->  2   7\nreturn [4, 2]\n</pre>\n\nEx: Given the following tree‚Ä¶\n\n<pre>\n-->        7\n         /  \\\n-->     4     9\n       / \\   / \\\n-->   1   4 8   9\n                 \\\n-->               9\nreturn [7, 4, 1, 9]\n</pre>\n\n## [[python]]\n\n```python\ndef leftview(root):\n    if not root:\n        return []\n    q = q[root]\n    view = []\n    while len(q):\n        n = len(q)\n        for i in range(1,n+1):\n            temp = q[0]\n            q.pop(0)\n\n            if i is == 1:\n                view.append(temp.data)\n\n            if temp.left:\n                q.append(temp.left)\n\n            if temp.right:\n                q.append(temp.right)\n    return view\n```\n## [[go]]\n\n## [[rust]]\n\n","n":0.097}}},{"i":106,"$":{"0":{"v":"Gather Level","n":0.707},"1":{"v":"## Problem\n\nGiven a binary tree, return its level order traversal where the nodes in each level are ordered from left to right.\n\n<pre>\nEx: Given the following tree...\n\n    4\n   / \\\n  2   7\nreturn [[4], [2, 7]]\n</pre>\n\n<pre>\nEx: Given the following tree...\n\n    2\n   / \\\n  10  15\n        \\\n         20\nreturn [[2], [10, 15], [20]]\n</pre>\n\n<pre>\nEx: Given the following tree...\n\n    1\n   / \\\n  9   32\n /      \\\n3        78\nreturn [[1], [9, 32], [3, 78]]\n</pre>\n\n## [[python]]\n\n```python\ndef levelOrder(root):\n    if not root: return []\n    result, temp, queue = [] [] [root]\n    while queue:\n        for x in iter(range(len(queue))):\n            q = queue.pop(0)\n            temp += [q.val]\n            if q.left: queue.append(q.left )\n            if q.right: queue.append(q.right )\n            result += [temp]\n            temp=[]\n    return result\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.096}}},{"i":107,"$":{"0":{"v":"Find Mode","n":0.707},"1":{"v":"## Problem\n\nGiven a binary search tree, return its mode (you may assume the answer is unique). If the tree is empty, return -1.\n\nNote: the mode is the most frequently occurring value in the tree.\n\n<pre>\nEx: Given the following tree...\n\n        2\n       / \\\n      1   2\nreturn 2.\n</pre>\n\n<pre>\nEx: Given the following tree...\n\n         7\n        / \\\n      4     9\n     / \\   / \\\n    1   4 8   9\n               \\\n                9\nreturn 9.\n</pre>\n\n## [[python]]\n\n```python\ndef findMode(root):\n    counts = collections.Counter()\n    modeValue = 0\n\n    def helper(node):\n        nonlocal modeValue\n        if not node:\n            return\n        counts[node.val] +=1\n        modeValue = max(mv,counts[node.val])\n        helper(node.left)\n        helper(node.right)\n    helper(root)\n    return [k for k,v in counts.items() if v == mv]\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.1}}},{"i":108,"$":{"0":{"v":"Minimum Difference","n":0.707},"1":{"v":"## Problem\n\nGiven a binary search tree, return the minimum difference between any two nodes in the tree.\n\n<pre>\nEx: Given the following tree...\n        2\n       / \\\n      3   1\nreturn 1.\n</pre>\n\n<pre>\nEx: Given the following tree...\n        29\n       /  \\\n     17   50\n    /     / \\\n   1    42  59\nreturn 8.\n</pre>\n\n<pre>\nEx: Given the following tree...\n        2\n         \\\n         100\nreturn 98.\n</pre>\n\n## [[python]]\n\n```python\ndef getMinDiff(root):\n    def solve(node,low,high):\n        if not node: return high-low\n        left = solve(node.left,low,node.val)\n        right = solve(node.right,node.val,high)\n        return min(left,right)\n   return solve(root,float('-inf'),float('inf'))\n\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.118}}},{"i":109,"$":{"0":{"v":"Identical Trees","n":0.707},"1":{"v":"## Problem\n\nGiven two binary trees, return whether or not the two trees are identical.\n\nNote: identical meaning they exhibit the same structure and the same values at each node.\n\nEx: Given the following trees...\n\n<pre>\n        2\n       / \\\n      1   3\n\n    2\n   / \\\n  1   3\n\n\nreturn true.\n</pre>\n\nEx: Given the following trees...\n\n<pre>\n\n        1\n         \\\n          9\n           \\\n           18\n\n    1\n   /\n  9\n   \\\n    18\n\n\nreturn false.\n</pre>\n\nEx: Given the following trees...\n\n<pre>\n        2\n       / \\\n      3   1\n\n    2\n   / \\\n  1   3\n\n\nreturn false.\n</pre>\n\n## [[python]]\n\n```python\nclass Node:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef isIdentical(r1,r2):\n    if not r1 and not r2:\n        return True\n    if not r1 or not r2:\n        return False\n    if r1.val != r2.val:\n        return False\n    return isIdentical(r1.right, r2.right) and isIdentical(r1.left, r2.left)\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.092}}},{"i":110,"$":{"0":{"v":"Sorted Array to Binary Search Tree","n":0.408},"1":{"v":"## Problem\n\nGiven an array of numbers sorted in ascending order, return a height-balanced binary search tree using every number from the array.\n\nNote: height-balanced meaning that the level of any node‚Äôs two subtrees should not differ by more than one.\n\nEx: Given the following nums...\n\n<pre>\nnums = [1, 2, 3] return a reference to the following tree...\n       2\n      /  \\\n     1    3\n</pre>\n\nEx: Given the following nums...\n\n<pre>\nnums = [1, 2, 3, 4, 5, 6] return a reference to the following tree...\n        3\n       / \\\n      2   5\n     /   / \\\n    1   4   6\n</pre>\n\n## [[python]]\n\n```python\nclass Node:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef arrayToBST(arr):\n    if not arr:\n        return None\n    mid = (len(arr))/2\n    root = Node(arr[mid])\n    root.left(arrToBST(arr[:mid]))\n    root.left(arrToBST(arr[mid+1:]))\n    return root\n\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.092}}},{"i":111,"$":{"0":{"v":"Lowest Common Ancestor","n":0.577},"1":{"v":"## Problem\n\nGiven a binary search tree that contains unique values and two nodes within the tree, a, and b, return their lowest common ancestor.\n\nNote: the lowest common ancestor of two nodes is the deepest node within the tree such that both nodes are descendants of it.\n\nEx: Given the following tree...\n\n<pre>\n       7\n      / \\\n    2    9\n   / \\\n  1   5\n\nand a = 1, b = 9, return a reference to the node containing 7.\n</pre>\n\nEx: Given the following tree...\n\n<pre>\n        8\n       / \\\n      3   9\n     / \\\n    2   6\n\nand a = 2, b = 6, return a reference to the node containing 3.\n</pre>\n\nEx: Given the following tree...\n\n<pre>\n        8\n       / \\\n      6   9\n\nand a = 6, b = 8, return a reference to the node containing 8.\n</pre>\n\n## [[python]]\n\n```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n            if root in (None, p, q): return root\n            left = self.lowestCommonAncestor(root.left,p,q)\n            right = self.lowestCommonAncestor(root.right,p,q)\n            return root if left and right else left or right\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.076}}},{"i":112,"$":{"0":{"v":"Convert Binary Search Tree to Sorted Linked List","n":0.354},"1":{"v":"## Problem\n\nGiven a binary search tree, rearrange the tree such that it forms a linked list where all its values are in ascending order.\n\nEx: Given the following tree...\n\n<pre>\n        5\n       / \\\n      1   6\n</pre>\n\nreturn...\n\n<pre>\n 1\n  \\\n   5\n    \\\n     6\n</pre>\n\nEx: Given the following tree...\n\n<pre>\n       5\n      / \\\n    2    9\n   / \\\n  1   3\n</pre>\n\nreturn...\n\n<pre>\n 1\n  \\\n   2\n    \\\n     3\n      \\\n       5\n        \\\n         9\n</pre>\n\nEx: Given the following tree...\n\n<pre>\n 5\n  \\\n   6\n</pre>\n\nreturn...\n\n<pre>\n 5\n  \\\n   6\n</pre>\n\n## [[python]]\n\n```python\nclass Node:\n    def __init__(self):\n        self.key = 0\n        self.left = None\n        self.right = None\n\ndef newNode(key):\n    node = Node()\n    node.key = key\n    node.left = node.right = None\n    return (node)\n\ndef flatten(root):\n    if (root == None or root.left == None and\n                        root.right == None):\n        return\n\n    if (root.left != None):\n\n        flatten(root.left)\n\n        tmpRight = root.right\n        root.right = root.left\n        root.left = None\n\n        t = root.right\n        while (t.right != None):\n            t = t.right\n\n        t.right = tmpRight\n\n    flatten(root.right)\n\n\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.084}}},{"i":113,"$":{"0":{"v":"Will It Return ??","n":0.5},"1":{"v":"## Problem\n\nThis question is asked by Amazon.\n\n Given a string representing the sequence of moves a robot vacuum makes, return whether or not it will return to its original position. The string will only contain L, R, U, and D characters, representing left, right, up, and down respectively.\n\nEx: Given the following strings...\n\n> \"LR\", return true\n>\n> \"URURD\", return false\n>\n> \"RUULLDRD\", return true\n\n## [[python]]\n\n```python\ndef does_it_return(word)->bool:\n    x,y = 0,0\n    for c in word:\n        if c == 'R':\n            x+=1\n        elif c == 'L':\n            x-=1\n        elif c == 'U':\n            y += 1\n        elif c == 'D':\n            y-=1\n    return x==0 and y==0\n```\n\n## [[go]]\n\n```go\nfunc doesitreturn(word string) bool {\n\tx := 0\n\ty := 00\n\tfor _, c := range word {\n\t\tif c == 'R' {\n\t\t\tx = x + 1\n\t\t} else if c == 'L' {\n\t\t\tx = x - 1\n\t\t} else if c == 'U' {\n\t\t\ty += 1\n\t\t} else if c == 'D' {\n\t\t\ty -= 1\n\t\t}\n\t}\n\treturn x == 0 && y == 0\n}\n```\n\n## [[rust]]\n\n```rust\nfn does_it_return(word:&str)->bool{\n    let mut x = 0;\n    let mut y = 0;\n\n    for c in word.chars() {\n        if c == 'R' {\n            x += 1;\n        } else if c == 'L' {\n            x -= 1;\n        } else if c == 'U' {\n            y += 1;\n        } else {\n            y -= 1;\n        }\n    }\n    x == 0 && y == 0\n}\n\n}\n```\n\n","n":0.069}}},{"i":114,"$":{"0":{"v":"Find Value in BST","n":0.5},"1":{"v":"## Problem\n\nThis question is asked by Google.\n\nGiven the reference to the root of a binary search tree and a search value, return the reference to the node that contains the value if it exists and null otherwise.\n\nNote: all values in the binary search tree will be unique.\n\nEx: Given the tree...\n\n> ```\n>    3\n>   / \\\n>  1   4\n> ```\n\nand the search value 1 return a reference to the node containing 1.\n\nEx: Given the following tree...\n\n> ```\n>     7\n>    / \\\n>   5   9\n>      / \\\n>     8   10\n> ```\n\nand the search value 9 return a reference to the node containing 9.\n\nEx: Given the following tree...\n\n> ```\n>    8\n>   / \\\n>  6   9\n> ```\n\nand the search value 7 return null.\n\n## [[python]]\n\n```python\ndef search(self, root, val):\n        def search_rec(root):\n            if root:\n                if root.val == val: return root\n                elif root.val < val: return search_rec(root.right)\n                return search_rec(root.left)\n\n        return rec(root)\n\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.085}}},{"i":115,"$":{"0":{"v":"Queue Based Stack","n":0.577},"1":{"v":"## Problem\n\nDesign a class to implement a stack using only a single queue.\n\nYour class, `QueueStack`, should support the following stack methods: `push()` (adding an item), `pop()` (removing an item), `peek()` (returning the top value without removing it), and `empty()` (whether or not the stack is empty).\n\n## [[python]]\n\n```python\nClass QueueStack:\n    def __init__(self):\n        self.q = []\n\n    def append(self,val):\n        size = len(self.q)\n        q.append[val]\n        for i in range(size):\n            q.append(q.pop(0))\n\n    def pop(self):\n        if len(self.q)==0:\n            return None\n        else:\n            return self.q.pop(0)\n\n    def peek(self):\n        if len(self.q)==0:\n            return None\n        else:\n            return self.q[-1]\n\n    def empty(self):\n        return len(self.q)==0\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.107}}},{"i":116,"$":{"0":{"v":"Moving Average","n":0.707},"1":{"v":"## Problem\n\nThis question is asked by Microsoft.\n\nDesign a class, MovingAverage, which contains a method, next that is responsible for returning the moving average from a stream of integers.\n\nNote: a moving average is the average of a subset of data at a given point in time.\n\nEx: Given the following series of events...\n\n> // i.e. the moving average has a capacity of 3.\n>\n> MovingAverage movingAverage = new MovingAverage(3);\n>\n> m.next(3) returns 3 because (3 / 1) = 3\n>\n> m.next(5) returns 4 because (3 + 5) / 2 = 4\n>\n> m.next(7) = returns 5 because (3 + 5 + 7) / 3 = 5\n>\n> m.next(6) = returns 6 because (5 + 7 + 6) / 3 = 6\n\nMovingAverage class definition:\n\n```\npublic class MovingAverage {\n    // TODO: declare any instance variables you require.\n\n    /**\n    * Initializes a MovingAverage with a\n    * capacity of `size`.\n    */\n    public MovingAverage(int size) {\n    // TODO: initialize your MovingAverage.\n    }\n\n    /**\n    * Adds `val` to the stream of numbers\n    * and returns the current average of the numbers.\n    */\n    public double next(int val) {\n    // TODO: implement this method.\n    }\n\n}\n```\n\n## [[python]]\n\n```python\nfrom collections import deque\n\nclass MovingAverage:\n    def __init__(self,size=3) -> None:\n        self.size = size\n        self.q = deque([],maxlen=size)\n\n    def next(self,val):\n        self.q.append(val)\n        return sum(self.q)/len(self.q)\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.071}}},{"i":117,"$":{"0":{"v":"Call Counter","n":0.707},"1":{"v":"## Problem\n\nThis question is asked by Google.\n\nCreate a class `CallCounter` that tracks the number of calls a client has made within the last 3 seconds.\n\nYour class should contain one method, `ping(int t)` that receives the current timestamp (in milliseconds) of a new call being made and returns the number of calls made within the last 3 seconds.\n\nNote: you may assume that the time associated with each subsequent call to `ping` is strictly increasing.\n\nEx: Given the following calls to ping‚Ä¶\n\n> ping(1), return 1 (1 call within the last 3 seconds)\n>\n> ping(300), return 2 (2 calls within the last 3 seconds)\n>\n> ping(3000), return 3 (3 calls within the last 3 seconds)\n>\n> ping(3002), return 3 (3 calls within the last 3 seconds)\n>\n> ping(7000), return 1 (1 call within the last 3 seconds)\n\n## [[python]]\n\n```python\nclass CallCounter:\n\n    def __init__(self):\n        self.ts_dict = {}\n\n    def ping(self,timestamp):\n        if timestamp not in self.ts_dict:\n            self.ts_dict[timestamp] = 1\n        else:\n            self.ts_dict[timestamp] += 1\n        return self.getPings(timestamp)\n\n    def getPings(self,timestamp):\n        t1 = timestamp - 3000\n        tc = 0\n        for ts, c in self.ts_dict.items():\n            if ts > t1:\n                tc += c\n        return tc\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.075}}},{"i":118,"$":{"0":{"v":"Next Greater Element","n":0.577},"1":{"v":"## Problem\n\nThis question is asked by Amazon.\n\nGiven two arrays of numbers, where the first array is a subset of the second array, return an array containing all the next greater elements for each element in the first array, in the second array. If there is no greater element for any element, output -1 for that number.\n\nEx: Given the following arrays‚Ä¶\n\n> nums1 = [4,1,2], nums2 = [1,3,4,2], return [-1, 3, -1] because no element in nums2 is greater than 4, 3 is the first number in nums2 greater than 1, and no element in nums2 is greater than 2.\n>\n> nums1 = [2,4], nums2 = [1,2,3,4], return [3, -1] because 3 is the first greater element that occurs in nums2 after 2 and no element is greater than 4.\n\n## [[python]]\n\n```python\ndef nextGreaterElement( nums1, nums2):\n    map = dict()\n    stk = nums2[0:1]\n\n    for num in nums2[1:]:\n        while stk and stk[-1] < num:\n            map[stk.pop()] = num\n        stk.append(num)\n    return [map.get(num, -1) for num in nums1]\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.079}}},{"i":119,"$":{"0":{"v":"Remove Adjacent Chars","n":0.577},"1":{"v":"## Problem\n\nThis question is asked by Facebook.\n\nGiven a string s containing only lowercase letters, continuously remove adjacent characters that are the same and return the result.\n\nEx: Given the following strings...\n\n> s = \"abccba\", return \"\"\n>\n> s = \"foobar\", return \"fbar\"\n>\n> s = \"abccbefggfe\", return \"a\"\n\n## [[python]]\n\n```python\ndef remove_adjacent(s1):\n    stk = []\n    for x in s1:\n        if len(stk)>0 and stk[-1] == x:\n            stk.pop()\n        else:\n            stk.append(x)\n\n    return \"\".join(stk)\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.122}}},{"i":120,"$":{"0":{"v":"Compare Keystrokes","n":0.707},"1":{"v":"## Problem\n\nThis question is asked by Amazon.\n\nGiven two strings s and t, which represents a sequence of keystrokes, where # denotes a backspace, return whether or not the sequences produce the same result.\n\nEx: Given the following strings...\n\n<pre>\ns = \"ABC#\", t = \"CD##AB\", return true\n\ns = \"como#pur#ter\", t = \"computer\", return true\n\ns = \"cof#dim#ng\", t = \"code\", return false\n</pre>\n\n## [[python]]\n\n```python\ndef compare_keystrokes(s1,s2) -> bool:\n    stk = []\n    stk2 = []\n    for x in s1:\n        if x == '#':\n            stk.pop()\n        else:\n            stk.append(x)\n    for x in s2:\n        if x == '#':\n            stk2.pop()\n        else:\n            stk2.append(x)\n    return stk==stk2\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.103}}},{"i":121,"$":{"0":{"v":"Balanced Brackets","n":0.707},"1":{"v":"## Problem\n\nThis question is asked by Google.\n\nGiven a string only containing the following characters `(`, `)`, `{`, `}`, `[`, and `]` return whether or not the opening and closing characters are in a valid order.\n\nEx: Given the following strings...\n\n> \"(){}\\[]\", return true\n>\n> \"(({\\[]}))\", return true\n>\n> \"{(})\", return false\n\n## [[python]]\n\n```python\ndef check_brackets(a):\n    stk = []\n    chars = { \"{\":\"}\",\"[\":\"]\",\"(\":\")\"}\n    for x in a:\n        if x in chars.keys():\n            stk.append(x)\n        if x in chars.values():\n            if x== chars.get(stk[-1]):\n                stk.pop()\n            else:\n                return False\n\n    return len(stk) == 0\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.11}}},{"i":122,"$":{"0":{"v":"Reverse Linked List","n":0.577},"1":{"v":"## Problem\n\nThis question is asked by Facebook.\n\nGiven a linked list, containing unique values, reverse it, and return the result.\n\nEx: Given the following linked lists...\n\n> 1->2->3->null, return a reference to the node that contains 3 which points to a list that looks like the following: 3->2->1->null\n>\n> 7->15->9->2->null, return a reference to the node that contains 2 which points to a list that looks like the following: 2->9->15->7->null\n>\n> 1->null, return a reference to the node that contains 1 which points to a list that looks like the following: 1->null\n\n## [[python]]\n\n```python\ndef reverseList(self, head: ListNode) -> ListNode:\n    prev = None\n    curr = head\n    while curr:\n        temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = temp\n    return prev\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.092}}},{"i":123,"$":{"0":{"v":"Where Cycle ?!","n":0.577},"1":{"v":"## Problem\n\nThis question is asked by Apple.\n\nGiven a potentially cyclical linked list where each value is unique, return the node at which the cycle starts. If the list does not contain a cycle, return null.\n\nEx: Given the following linked lists...\n\n> 1->2->3, return null\n>\n> 1->2->3->4->5->2 (5 points back to 2), return a reference to the node containing 2\n>\n> 1->9->3->7->7 (7 points to itself), return a reference to the node containing 7\n\n## [[python]]\n\n```python\ndef whereCycle(self, head)->Node:\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            break\n    else:\n        return None\n    while head != slow:\n        slow = slow.next\n        head = head.next\n    return head\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.095}}},{"i":124,"$":{"0":{"v":"Is Palindrome ??","n":0.577},"1":{"v":"## Problem\n\nThis question is asked by Facebook.\n\nGiven a string, return whether or not it forms a palindrome ignoring case and non-alphabetical characters.\n\nNote: a palindrome is a sequence of characters that reads the same forwards and backwards.\n\nEx: Given the following strings...\n\n> \"level\", return true\n>\n> \"algorithm\", return false\n>\n> \"A man, a plan, a canal: Panama.\", return true\n\n## [[python]]\n\n```python\ndef is_palindrome(word)->bool:\n    w1 = \"\".join(list(filter(lambda x: x.isalpha(),word.lower())))\n    return w1==w1[::-1]\n```\n\n## [[go]]\n\n```go\nfunc isPalindrome(word string) bool{\n    s := strings.ToLower(word)\n    i, j := 0, len(s)-1\n    for i < j {\n        if !isValid(s[i]) {\n            i++\n            continue\n        }\n        if !isValid(s[j]) {\n            j--\n            continue\n        }\n        if !strings.EqualFold(string(s[i]), string(s[j])) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nfunc isValid(a byte) bool {\n    if (a >= 'a' && a <= 'z') {\n        return true\n    }\n    return false\n}\n}\n```\n\n## [[rust]]\n\n```rust\nfn isPalindrome(word:&str)-> bool{\n    extern crate unicode_segmentation;\n    use unicode_segmentation::UnicodeSegmentation;\n    word == word\n        .graphemes(true)\n        .rev()\n        .flat_map(|g| g.chars())\n        .collect::<String>()\n}\n\n```\n\n","n":0.085}}},{"i":125,"$":{"0":{"v":"Has Cycle ?!","n":0.577},"1":{"v":"## Problem\n\nThis question is asked by Microsoft.\n\nGiven a linked list, containing unique numbers, return whether or not it has a cycle.\n\nNote: a cycle is a circular arrangement (i.e. one node points back to a previous node)\n\nEx: Given the following linked lists...\n\n> 1->2->3->1 -> true (3 points back to 1)\n>\n> 1->2->3 -> false\n>\n> 1->1 true (1 points to itself)\n\n## [[python]]\n\n```python\ndef hasCycle(self, head: ListNode) -> bool:\n    if not head: return False\n    if head.next is None:\n        return False\n\n    ptr = head.next\n    if head.next.next is None:\n        return False\n    cur = head.next.next\n    while cur != ptr:\n        if cur is None or cur.next is None:\n            return False\n        ptr = ptr.next\n        cur = cur.next.next\n    return True\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.095}}},{"i":126,"$":{"0":{"v":"Middle Node of Linked List","n":0.447},"1":{"v":"## Problem\n\nThis question is asked by Amazon.\n\nGiven a non-empty linked list, return the middle node of the list. If the linked list contains an even number of elements, return the node closer to the end.\n\nEx: Given the following linked lists...\n\n> 1->2->3->null, return 2\n>\n> 1->2->3->4->null, return 3\n>\n> 1->null, return 1\n\n## [[python]]\n\n```python\ndef middleNode(self, head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    return slow\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.119}}},{"i":127,"$":{"0":{"v":"Remove All Node Containing Value","n":0.447},"1":{"v":"## Problem\n\nThis question is asked by Google.\n\nGiven a linked list and a value, remove all nodes containing the provided value, and return the resulting list.\n\nEx: Given the following linked lists and values...\n\n> 1->2->3->null, value = 3, return 1->2->null\n>\n> 8->1->1->4->12->null, value = 1, return 8->4->12->null\n>\n> 7->12->2->9->null, value = 7, return 12->2->9->null\n\n## [[python]]\n\n```python\ndef remove_nodes(head,val)\n    while head and head.val == val:\n        head = head.next\n    if not head:\n        return head\n    prev, cur = head, head.next\n    while cur:\n        while cur and cur.val == val:\n            cur = cur.next\n        prev.next = cur\n        if cur:\n            prev, cur = prev.next, cur.next\n    return head\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.102}}},{"i":128,"$":{"0":{"v":"Remove nth to last node","n":0.447},"1":{"v":"## Problem\n\nThis question is asked by Facebook.\n\nGiven a linked list and a value n, remove the nth to last node and return the resulting list.\n\nEx: Given the following linked lists...\n\n> 1->2->3->null, n = 1, return 1->2->null\n>\n> 1->2->3->null, n = 2, return 1->3->null\n>\n> 1->2->3->null, n = 3, return 2->3->null\n\n## [[python]]\n\n```python\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n    fast = slow = head\n    for _ in range(n):\n        fast = fast.next\n    if not fast:\n        return head.next\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n    slow.next = slow.next.next\n    return head\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.107}}},{"i":129,"$":{"0":{"v":"Merge Sorted Linked Lists","n":0.5},"1":{"v":"## Problem\n\nThis question is asked by Apple.\n\nGiven two sorted linked lists, merge them together in ascending order and return a reference to the merged list\n\nEx: Given the following lists...\n\n> list1 = 1->2->3, list2 = 4->5->6->null, return 1->2->3->4->5->6->null\n>\n> list1 = 1->3->5, list2 = 2->4->6->null, return 1->2->3->4->5->6->null\n>\n> list1 = 4->4->7, list2 = 1->5->6->null, return 1->4->4->5->6->7->null\n\n## [[python]]\n\n```python\nclass LinkedList:\n    def __init__(self,value):\n        self.value = value\n        self.next = None\n\ndef mergeLists(h1,h2):\n    ptr1 = h1\n    ptr1_prev =None\n    ptr2 = h2\n    while ptr1 is not None and ptr2 is not None:\n        if ptr1.value < ptr2.value:\n            ptr1_prev = ptr1\n            ptr1 = ptr1.net\n        else:\n            if ptr1_prev is not None:\n                ptr1_prev.next = ptr2\n            ptr1_prev = p2\n            ptr2 = ptr2.next\n            ptr1_prev.next = ptr1\n    if ptr1 is None:\n        ptr1_prev.next = ptr2\n    return h1 if h1.value < h2.value else h2\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.089}}},{"i":130,"$":{"0":{"v":"String Symmetric Difference","n":0.577},"1":{"v":"## Problem\n\nThis question is asked by Amazon.\n\nGiven two strings representing sentences, return the words that are not common to both strings (i.e. the words that only appear in one of the sentences). You may assume that each sentence is a sequence of words (without punctuation) correctly separated using space characters.\n\nEx: given the following strings...\n\n> sentence1 = \"the quick\", sentence2 = \"brown fox\", return [\"the\", \"quick\", \"brown\", \"fox\"]\n>\n> sentence1 = \"the tortoise beat the haire\", sentence2 = \"the tortoise lost to the haire\", return [\"beat\", \"to\", \"lost\"]\n>\n> sentence1 = \"copper coffee pot\", sentence2 = \"hot coffee pot\", return [\"copper\", \"hot\"]\n\n## [[python]]\n\n```python\ndef findCommon(s1,s2):\n    def findCommon(s1,s2):\n    s = set()\n    t = set()\n    for w in s1.split():\n       s.add(w)\n    for w in s2.split():\n       t.add(w)\n    return s.symmetric_difference(t)\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.09}}},{"i":131,"$":{"0":{"v":"Intersection Of Two Arrays","n":0.5},"1":{"v":"## Problem\n\nThis question is asked by Google. Given two integer arrays, return their intersection.\n\nNote: the intersection is the set of elements that are common to both arrays.\n\nEx: Given the following arrays...\n\n> nums1 = [2, 4, 4, 2], nums2 = [2, 4], return [2, 4]\n>\n> nums1 = [1, 2, 3, 3], nums2 = [3, 3], return [3]\n>\n> nums1 = [2, 4, 6, 8], nums2 = [1, 3, 5, 7], return \\[]\\`\n\n## [[python]]\n\n```python\ndef intersection(nums1,nums2):\n    return set(nums1).intersection(set(nums2))\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.115}}},{"i":132,"$":{"0":{"v":"Find Randomly Added Letter","n":0.5},"1":{"v":"## Problem\n\nThis question is asked by Google.\n\nYou are given two strings, s and t which only consist of lowercase letters. t is generated by shuffling the letters in s as well as potentially adding an additional random character. Return the letter that was randomly added to t if it exists, otherwise, return ' '.\n\nNote: You may assume that at most one additional character can be added to t.\n\nEx: Given the following strings...\n\n> s = \"foobar\", t = \"barfoot\", return 't'\n>\n> s = \"ide\", t = \"idea\", return 'a'\n>\n> s = \"coding\", t \"ingcod\", return ''\n\n## [[python]]\n\n```python\nfrom collections import Counter\ndef findDiff(word1,word2):\n    for x in (Counter(word2)-Counter(word1)).keys():\n        return x\n    return ' '\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.095}}},{"i":133,"$":{"0":{"v":"First Unique Character Index","n":0.5},"1":{"v":"## Problem\n\nThis question is asked by Microsoft.\n\nGiven a string, return the index of its first unique character.\nIf a unique character does not exist, return -1.\n\nEx: Given the following strings...\n\n> \"abcabd\", return 2\n>\n> \"thedailybyte\", return 1\n>\n> \"developer\", return 0\n\n## [[python]]\n\n```python\ndef first_unique_char(s):\n    for i,j in OrderedDict(Counter(s)).items():\n        if j == 1:\n            return s.index(i)\n    return -1\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.136}}},{"i":134,"$":{"0":{"v":"Is Anagram ??","n":0.577},"1":{"v":"## Problem\n\nThis question is asked by Facebook.\n\nGiven two strings s and t return whether or not s is an anagram of t.\n\nNote: An anagram is a word formed by reordering the letters of another word.\n\nEx: Given the following strings...\n\n> s = \"cat\", t = \"tac\", return true\n>\n> s = \"listen\", t = \"silent\", return true\n>\n> s = \"program\", t = \"function\", return false\n\n## [[python]]\n\n```python\ndef is_anagram(s1,s2):\n    return len(s1)==len(s2) and set(s1) == set(s2)\n```\n\n## [[go]]\n\n## [[rust]]\n\n","n":0.117}}},{"i":135,"$":{"0":{"v":"Reverse String","n":0.707},"1":{"v":"## Problem\n\nThis question is asked by Google.\n\nGiven a string, reverse all of its characters and return the resulting string.\n\nEx: Given the following strings...\n\n> \"Cat\", return \"taC\"\n>\n> \"The Daily Byte\", return \"etyB yliaD ehT\"\n>\n> \"civic\", return \"civic\"\n\n## [[python]]\n\n```python\ndef reverse(word)\n    return word[::-1]\n```\n\n## [[go]]\n\n```go\nfunc reverse(s string) string {\n    // Handle UTF-16\n    rns := []rune(s)\n    for i, j := 0, len(rns)-1; i < j; i, j = i+1, j-1 {\n        rns[i], rns[j] = rns[j], rns[i]\n    }\n    return string(rns)\n}\n```\n\n## [[rust]]\n\n```rust\n// Handle UTF-16\nuse unicode_segementation:UnicodeSegmentation;\nfn reverse(word:&str)-> String{\n    word\n        .graphemes(true)\n        .rev()\n        .flat_map(|g| g.chars())\n        .collect()\n}\n```\n\n","n":0.108}}},{"i":136,"$":{"0":{"v":"Cache","n":1}}},{"i":137,"$":{"0":{"v":"Least Frequently Used Cache","n":0.5},"1":{"v":"\n\n```python\nfrom collections import defaultdict\nfrom collections import OrderedDict\n\n\nclass Node:\n    def __init__(self,key,val,count) -> None:\n        self.key = key\n        self.val = val\n        self.count = count\n\nclass LFUCache(object):\n    def __init__(self,capacity) -> None:\n        self.cap = capacity\n        self.key_to_node = {}\n        self.count_to_node = defaultdict(OrderedDict)\n        self.minCount = None\n\n    def get(self, key):\n        if key not in self.key_to_node:\n            return -1\n\n        node = self.key_to_node[key]\n        del self.count_to_node[node.count][key]\n\n        if not self.count_to_node[node.count]:\n            del self.count_to_node[node.count]\n\n        node.count +=1\n        self.count_to_node[node.count][key] = node\n\n        if not self.count_to_node[self.minCount]:\n            self.minCount += 1\n\n        return node.val\n\n    def put(self, key, value):\n\n        if not self.cap:\n            return\n\n        if key in self.key_to_node:\n            self.key_to_node[key].val = value\n            self.get(key)\n            return\n\n        if len (self.key_to_node) == self.cap:\n            k,n = self.count_to_node[self.minCount].popitem(last = False)\n            del self.key_to_node[k]\n\n        self.count_to_node[1][key] = self.key_to_node[key] = Node(key,value,1)\n        self.minCount = 1\n        return\n\n\nlfu =  LFUCache(2)\nlfu.put(1, 1);\nlfu.put(2, 2);\nlfu.get(1);\nlfu.put(3, 3);\nlfu.get(2);\nlfu.get(3);\nlfu.put(4, 4);\nlfu.get(1);\nlfu.get(3);\nlfu.get(4);\n```","n":0.093}}},{"i":138,"$":{"0":{"v":"Algodaily","n":1}}},{"i":139,"$":{"0":{"v":"Fizz Buzz","n":0.707}}},{"i":140,"$":{"0":{"v":"Dollar Sign Deletion","n":0.577},"1":{"v":"\n## Problem\n\nYou're given an array of strings containing alphabetical characters and certain `$` characters.\n\nA `$` represents a DELETE action whereby the character before it is deleted.\n\nEach of these strings will be run through a method to operate on the `$` DELETE action.\n\nWe want to find out if the final string is the same for all of them.\n\nLet's take an example:\n\n```\nconst input = [\"f$st\", \"st\"]\nisDollarDeleteEqual(input);\n// true\n// true because both become \"st\"\n```\nGiven the below function signature, can you find a solution in O(n) time and constant space?\n\n```\nfunction isDollarDeleteEqual(arr) {\n  return;\n}\n```\nConstraints\n\n    The input arrays can be of any size\n    Every string has at least a single character\n    The string will consist of dollar signs and lowercase alphabets\n    Expected overall time complexity : O(n)\n    Expected space complexity : O(n)\n\n## [python]\n```python\n\n```","n":0.089}}},{"i":141,"$":{"0":{"v":"Detect Substring in String","n":0.5},"1":{"v":"\n## Problem\n\nHow would you write a function to detect a substring in a string?\n\nIf the substring can be found in the string, return the index at which it starts. Otherwise, return -1.\n\n```\nfunction detectSubstring(str, subStr) {\n  return -1;\n}\n```\nImportant-- do not use the native String class's built-in substring or substr method. This exercise is to understand the underlying implementation of that method.\n\nConstraints\n\n    Length of both the given strings <=100000\n    The strings would never be null\n    The strings will only consist of lowercase letters\n    Expected time complexity : O(n)\n    Expected space complexity : O(1)\n\n\n## [python]\n```python\ndef substr(haystack, needle):\n    n, h = len(needle), len(haystack)\n    i, j, nxt = 1, 0, [-1]+[0]*n\n    while i < n:\n        if j == -1 or needle[i] == needle[j]:\n            i += 1\n            j += 1\n            nxt[i] = j\n        else:\n            j = nxt[j]\n    i = j = 0\n    while i < h and j < n:\n        if j == -1 or haystack[i] == needle[j]:\n            i += 1\n            j += 1\n        else:\n            j = nxt[j]\n    return i-j if j == n else -1\n```","n":0.077}}},{"i":142,"$":{"0":{"v":"Sum Digits Until One","n":0.5},"1":{"v":"\n## Problem\n\nWe're provided a positive integer num. Can you write a method to repeatedly add all of its digits until the result has only one digit?\n\nHere's an example: if the input was 49, we'd go through the following steps:\n\n> // start with 49\n> 4 + 9 = 13\n>\n> // move onto 13\n> 1 + 3 = 4\n\nWe would then return 4.\n\nConstraints\n\n    Input will be in the range between 0 and 1000000000\n    Expected time complexity : O(log n)\n    Expected space complexity : O(1)\n\n\n\n## [[python]]\n\n```python\ndef sumTillOne(n):\n    new = n\n    while new>9:\n        sum = 0\n        while new > 9:\n           sum = sum + new % 10\n           new = new // 10\n        sum = sum + new\n        new = sum\n    return new\n```","n":0.092}}},{"i":143,"$":{"0":{"v":"Array Intersection","n":0.707},"1":{"v":"## Problem\n\nWrite a function that takes two arrays as inputs and returns to us their intersection?\n\nEx\n\n> const nums1 = [1, 2, 2, 1];\n> const nums2 = [2, 2];\n>\n> intersection(nums1, nums2);\n> // [2]\n\n**Constraints**\n\n- Length of the array &lt;= 100000\n- The values in the array will be in the range -1000000000 and 1000000000\n- Expected time complexity: O(n+m) where n and m are the lengths of the array.\n- Expected space complexity: O(max(n,m)).\n\n  ## [[python]]\n\n```python\ndef intersection(arr1,arr2):\n    return list(set(arr1).intersection(set(arr2)))\n```\n\n","n":0.116}}}]}
